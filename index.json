[{"contents":"Qutebrowser: vim-like browser 這是一篇推薦文與介紹文。\n已經忘記開始使用 qutebrowser 的契機是什麼了，可能是看到（東東）學長用覺得很酷。\n在熟悉 vim 之後，qutebrowser 作為一個「Keyboard-driven」的瀏覽器吸引力會大大提昇，其 UI 簡潔與配置的靈活也讓我愛不釋手\nInstallation https://qutebrowser.org/doc/install.html\n在 Arch 下安裝不是難事。\n1 2 3 4  sudo pacman -S qutebrowser # Some optional dependencies sudo pacman -S pdfjs python-adblock python-tldextract \\  python-pygments python-babel   Ubuntu 也一樣是 sudo apt install qutebrowser 就可以了，但是版本似乎有點舊，以下提到的有些功能可能沒有或是行為不一樣。\nKeybind 簡介 首先，hjkl 跟 vim 一樣是上下左右。\n使用 : 就可以進入 command mode，當然一樣可以使用各種快捷鍵來做各種瀏覽器內的操作。\n以下是平常最常用的 keybindings！\n   command keybinding 功能     :open {url} o 在目前的分頁開啟某個 URL   :open -t {url} O 在新分頁開啟某個 URL   :tab-close d 關閉目前的分頁   :undo u 重新開啟前一次關閉的分頁或視窗   :tab-prev J 下一個分頁（右邊）   :tab-next K 上一個分頁（左邊）   :back H 回到上一頁   :forward L 回到下一頁   :set-cmd-text :open {url:pretty} go 打開網址列（？）   :zoom-in + 增加縮放倍數   :zoom-out - 減少縮放倍數   :zoom = 重置縮放倍數   :reload r 重新整理   :reload -f R 強制重新整理   :yank yy 複製網址列   :open -- {clipboard} pp 打開剪貼簿所複製的網址   :open -t -- {clipboard} Pp 在新分頁打開剪貼簿所複製的網址   :tab-move + gJ 把目前的分頁往上（右邊）移動   :tab-move - gK 把目前的分頁往下（左邊）移動   :q  關閉目前的視窗   :quit --save ZZ 關閉 qutebrowser （這會關閉所有視窗）    下面是在瀏覽一個頁面的時候的一些移動方法：\n   keybinding 功能     gg 跳到最上面   G 跳到最下面   \u0026lt;Ctrl-F\u0026gt; 向下捲動一頁   \u0026lt;Ctrl-B\u0026gt; 向上捲動一頁   \u0026lt;Ctrl-D\u0026gt; 向下捲動半頁   \u0026lt;Ctrl-U\u0026gt; 向上捲動半頁   / 向前搜尋   ? 向後搜尋    可以在 qutebrowser 中打開 qute://help/img/cheatsheet-big.png 看到更多。\nhint hint 應該可以說是 qutebrowser 的一大特色之一。\n在 normal mode 下按 f 後，目前視窗中所有元素就會出現一個小提示在旁邊（預設是黃色三角形+黑色 homerow 字母），當按下對應的按鍵之後瀏覽器就會做出「按下那個元素」的操作，而這也是 qutebrowser 的一大優點之一：可以完全不用滑鼠就完成瀏覽器所需的所有功能（當然，滑鼠功能預設還是可以用）。\n與 f 類似的是 F，不同之處在於如果點擊的是超連結會在新分頁開啟頁面。\n事實上 f 是 :hint all 指令的快捷鍵，除了 f/F 以外還有許多常用的 hint 組合，例如 ;t/;y/;h 等等，分別代表「只 hint 所有 input fields」、「複製 hint 選到的元素連結」以及「hover hint 選到的元素」。可以說你沒想到的 qutebrowser 都想到了(X\n熟練使用這個機制的話會對這個機制上癮，因為按鍵預設都是 homerow 的字母所以很好按，此外如果是同樣的 html，通常 parse 之後同樣的元素通常會對應到同樣的按鍵組合，例如在 youtube 回到首頁在我目前的電腦上就是 da、facebook 回到首頁是 ga、instagram 看限動是 fa 等等。\nConfiguration config 可以大致分成用 :set 設定的變數與用 :bind 設定的鍵盤快捷鍵兩部份。\n首先，和 vim 一樣，qutebrowser 有許多的 option，可以用 :set {option} {value} 來設定一個 option 的 value，此外只要輸入指令就會有非常完整的提示，不用擔心要背下來（？）\n一些例子：\n   option 功能     zoom.default 設定預設的縮放倍數   url.searchengines 設定在 open 一個不是網址的東西時的預設搜尋引擎   content.javascript.can_access_clipboard 設定網站可以存取剪貼簿（這樣複製按鈕才能用）   fonts.default_size 設定字型預設大小   fonts.web.family.fixed 設定等寬字體    還有很多的東西可以客製化，包含各種 tab、statusbar 的顏色，可以調整成自己喜歡的主題。\n:bind 則是跟 vim 的 map 很類似，可以訂製快捷鍵叫出自己需要的功能。以下是一些例子：\n   bindkey command 功能     \u0026lt;Alt-Esc\u0026gt; fake-key \u0026lt;Esc\u0026gt; 因為按 esc 只會進入 normal mode，所以有一個替代的按 esc 的方法。   ;v hint links spawn mpv {hint-url} 可以用 mpv （一個本機的影音軟體）打開一個影片網址，包含 youtube。   gs greasemonkey-reload ;; later 1 reload 重新載入 greasemonkey script。有時候沒載入 YT 就跑出影片廣告很煩人   zl spawn --userscript qute-pass 使用 qute-pass 的快捷鍵   zb hint inputs tab-bg --first ;; later 1 spawn --userscript qute-pass 使用 qute-pass + 自動跳到 input field 的快捷鍵    另外還有更進階的 configuration 功能，詳細要看 qute://help/configuring.html，例如其實可以有一個 config.py 的檔案之類的。\nOptional dependencies pdfjs 安裝了這個可以在瀏覽器中打開 PDF，跟 chrome 一樣（？）\n在下載 PDF 檔案時 qutebrowser 會問你要不要用 pdfjs 打開，按 \u0026lt;Ctrl-P\u0026gt; 就會自動下載到 /tmp 之類的地方再用 pdfjs 在 qutebrowser 中打開。\n現在瀏覽器不能看 PDF 都會被說不及格(X\npython-adblock 安裝這個似乎是可以使用跟 Brave browser 一樣的 adblock 機制（要設定 content.blocking.method = 'both'），不過我在 youtube 上看到的廣告還是不少。\npython-tldextract qute-pass 的 dependency。\npython-pygments 似乎是在 :view-source 的時候可以 :view-source --pygments，會改用 pygments 做 syntax highlight。\npython-babel 這個真的沒有研究，似乎是跟語言翻譯有關的套件。\nqute-pass pass 是一個簡單的密碼管理軟體，而 qutebrowser 有內建一個 userscript qute-pass 可以把存在 pass 裡面的帳號密碼自動填入網站。\n雖然有點小麻煩但真的很乾淨（？）\nyoutube ads 因為 qutebrowser 的 adblock 沒有使用太複雜的機制，因此對於 youtube 影片式廣告沒什麼辦法，目前我看到的一個解決方案是使用 greasemonkey script。\nhttps://gist.github.com/codiac-killer/87e027a2c4d5d5510b4af2d25bca5b01\n結語 Give qutebrowser a try!\n","permalink":"https://omeletwithoutegg.github.io/2022/03/29/qutebrowser/","tags":["arch","linux","qutebrowser","vim"],"title":"Qutebrowser 瀏覽器"},{"contents":"心態 和 ericxiao 去看咒術迴戰 0。\n光是走在路上就遇到很多認識的人，懷疑他是不是替身使者或啥的（X\n吃飯的時候討論上的課，覺得大家都會好多東西（？）\n之後散會時剛好走到公館哈拉，想說走上去打一道 SDVX 結果遇到也是 ICPC 培訓班的一個學長（？）\n很驚訝他有打音遊，總之他站在我後面看，然後我本來就只有剛力羅而且去年三級警戒之後大概打不到十次而已，實在是打的非常爛。\n被問說要不要一起打，刷了卡之後，又是暴龍天，雖然我覺得我很冷靜但我其實不知道我那時候表情怎麼樣（？？）\n總之選歌也很尷尬、打完也很尷尬，彷彿是因為我太弱而沒有資格有發語權一樣（我知道基本上並沒有這種事）\n有點像道德又有點像自我心態管理，我本來以為自己不會這樣子想的，但我果然還是會有不健康的心態。\n就像 HNO2 說過和別人比較只會讓自己不開心，相信自己在做自己喜歡的事情，還有對自己有自信真的是很重要的事情。\n","permalink":"https://omeletwithoutegg.github.io/2022/03/10/introspection-20220310/","tags":[],"title":"心態"},{"contents":"好．傳囉！ Nice Boat！ Description 給定一個長度 $N$ 的整數序列 $A_i$。\n如果你可以找出一個區間，他的前綴和每個數字都大於等於0，而且他的後綴和的每個數字也都大於等於0，我們就稱他是安全區間，請你找出最長的安全區間長度是多少。\nSolution 考慮原序列的前綴和 $p_i = A_1+A_2+\\cdots+A_i$，$p_0=0$，一個區間 $(l, r]$ 是安全區間若且唯若：\n$$\n\\begin{cases}\n\\forall l \\leq x \u0026lt; r ,\u0026amp; p_r - p_x \\geq 0 \\\\\n\\forall l \u0026lt; x \\leq r ,\u0026amp; p_x - p_l \\geq 0 \\\\\n\\end{cases}\n$$\n也就是說，$p_r$ 和 $p_l$ 分別必須要是這段區間的最大值與最小值。\n可以用單調隊列對於每個 $r$ 求出它左邊第一個嚴格比 $p_r$ 大的數字 $left_r$，以及對於每個 $l$ 求出它右邊第一個嚴格比 $p_l$ 小的數字 $right_l$。\n那麼，安全區間的定義又可以寫成\n$$\nleft_r \u0026lt; l \\leq r \u0026lt; right_l\n$$\n對 $l$ 做掃描線，$l$ 從 $0$ 到 $n$ 每次把符合 $left_r \u0026lt; l$ 的 $r$ 丟進去一個 set 裡面，然後查詢小於 $right_l$ 的 $r$ 最大是多少。這樣時間複雜度 $O(N\\log N)$。\n不過這題空間限制很緊，無情吃 RE 之後改用 BIT 維護再加上輸入優化才 AC。\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143  // An AC a day keeps the doctor away. #pragma GCC optimize(\u0026#34;Ofast\u0026#34;) #include \u0026lt;bits/stdc++.h\u0026gt;#ifdef local #define safe \\ std::cerr \u0026lt;\u0026lt; __PRETTY_FUNCTION__ \u0026lt;\u0026lt; \u0026#34; line \u0026#34; \u0026lt;\u0026lt; __LINE__ \u0026lt;\u0026lt; \u0026#34; safe\\n\u0026#34; #define debug(args...) qqbx(#args, args) #define orange(args...) danb(#args, args) using std::cerr; template \u0026lt;typename... T\u0026gt; void qqbx(const char *s, T... args) { int cnt = sizeof...(T); ((cerr \u0026lt;\u0026lt; \u0026#34;\\e[1;32m(\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;) = (\u0026#34;), ..., (cerr \u0026lt;\u0026lt; args \u0026lt;\u0026lt; (--cnt ? \u0026#34;, \u0026#34; : \u0026#34;)\\e[0m\\n\u0026#34;))); } template \u0026lt;typename T\u0026gt; void danb(const char *s, T L, T R) { cerr \u0026lt;\u0026lt; \u0026#34;\\e[1;32m[ \u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34; ] = [ \u0026#34;; for (int f = 0; L != R; ++L) cerr \u0026lt;\u0026lt; (f++ ? \u0026#34;, \u0026#34; : \u0026#34;\u0026#34;) \u0026lt;\u0026lt; *L; cerr \u0026lt;\u0026lt; \u0026#34; ]\\e[0m\\n\u0026#34;; } #else #define safe ((void)0) #define debug(...) ((void)0) #define orange(...) ((void)0) #endif // local #define all(v) begin(v), end(v)  using namespace std; const int inf = 1e9; template \u0026lt;typename U, typename V\u0026gt; ostream \u0026amp;operator\u0026lt;\u0026lt;(ostream \u0026amp;o, pair\u0026lt;U,V\u0026gt; p) { return o \u0026lt;\u0026lt; \u0026#39;(\u0026#39; \u0026lt;\u0026lt; p.first \u0026lt;\u0026lt; \u0026#39;,\u0026#39; \u0026lt;\u0026lt; p.second \u0026lt;\u0026lt; \u0026#39;)\u0026#39;; } inline char readchar() { constexpr int B = 1 \u0026lt;\u0026lt; 20; static char buf[B], *p, *q; if (p == q \u0026amp;\u0026amp; (q = (p = buf) + fread(buf, 1, B, stdin)) == buf) return EOF; return *p++; } inline int nextint() { int x = 0, c = readchar(), f = false; while (c \u0026lt; \u0026#39;0\u0026#39; \u0026amp;\u0026amp; c != \u0026#39;-\u0026#39;) c = readchar(); if (c == \u0026#39;-\u0026#39;) f = true, c = readchar(); while (c \u0026gt;= \u0026#39;0\u0026#39;) x = x * 10 + (c ^ \u0026#39;0\u0026#39;), c = readchar(); return f ? -x : x; } inline void readline(char* s) { char c = readchar(); while (c != \u0026#39;\\n\u0026#39;) *s++ = c, c = readchar(); } struct FastOut { constexpr static int B = 1 \u0026lt;\u0026lt; 20; static char buf[B]; int q; inline void writeint(int x, char sep = \u0026#39;\\n\u0026#39;) { static char stk[20]; char p = 0; if (!x) stk[p++] = \u0026#39;0\u0026#39;; while (x) stk[p++] = x % 10 ^ \u0026#39;0\u0026#39;, x /= 10; while (p) buf[q++] = stk[--p]; buf[q++] = sep; if (q + 20 \u0026gt;= B) fwrite(buf, 1, q, stdout), q = 0; } ~FastOut() { fwrite(buf, 1, q, stdout); } } ouf; char FastOut::buf[B]; const int maxn = 1000025; int64_t a[maxn]; int R[maxn]; pair\u0026lt;int,int\u0026gt; evt[maxn]; int stk[maxn]; int sz; void Add(int x) { for (++x; x \u0026lt;= sz; x += x \u0026amp; -x) a[x] += 1; } int Query(int p) { int sum = 0; for (++p; p \u0026gt; 0; p -= p \u0026amp; -p) sum += a[p]; int res = 0; for (int s = 1\u0026lt;\u0026lt;20; s; s \u0026gt;\u0026gt;= 1) if (res + s \u0026lt;= sz \u0026amp;\u0026amp; sum \u0026gt; a[res + s]) sum -= a[res += s]; return res; } signed main() { // ios_base::sync_with_stdio(false);  // cin.tie(nullptr);  int T = nextint(); // const int64_t C = 1e9;  for (int tc = 0; tc \u0026lt; T; tc++) { int n = nextint(); for (int i = 1; i \u0026lt;= n; i++) a[i] = nextint(); for (int i = 1; i \u0026lt;= n; i++) a[i] += a[i-1]; int m = 0; { int p = 0; for (int i = 0; i \u0026lt;= n; i++) { while (p \u0026amp;\u0026amp; a[stk[p-1]] \u0026lt;= a[i]) --p; int l = !p ? -1 : stk[p-1]; stk[p++] = i; evt[m++] = { l, i }; } } { int p = 0; for (int i = n; i \u0026gt;= 0; i--) { while (p \u0026amp;\u0026amp; a[stk[p-1]] \u0026gt;= a[i]) --p; R[i] = !p ? n+1 : stk[p-1]; stk[p++] = i; } } sort(evt, evt+m); // use a as an BIT  sz = n+2; for (int i = 0; i \u0026lt;= sz; i++) a[i] = 0; int ans = 0; int it = 0; for (int i = 0; i \u0026lt;= n; i++) { while (it \u0026lt; m \u0026amp;\u0026amp; evt[it].first \u0026lt; i) { int j = evt[it++].second; Add(j); } int len = Query(R[i]) - i; ans = max(ans, len); } ouf.writeint(ans); } }   至於怎麼用假解拿到 topcoder 又是另一個故事了…應該很快會更新測資（\n","permalink":"https://omeletwithoutegg.github.io/2022/02/11/TIOJ-1841/","tags":["TIOJ","stack","monotone-queue","data-structure"],"title":"TIOJ 1841"},{"contents":"安裝 arch 這篇文章是分享與紀錄我在筆電上裝 arch-linux 的過程，其實要裝還是直接看 arch wiki 最快XD 不過那個頁面沒有講怎麼裝 bootloader 與桌面環境。\n製作開機隨身碟（Live USB） 下載 .iso 檔案，並將其寫入 USB 當中（假設 USB 是 /dev/sdb）。\n1  dd bs=4M if=~/Downloads/archlinux-2022.02.01-x86_64.iso of=/dev/sdb \u0026amp;\u0026amp; sync   使用隨身碟開機 通常在開機時按下某個按鍵可以進入選擇開機媒介的選單，例如我現在這台 ASUS 的筆電就是在出現 logo 時按 F2 就會出現選單，在 boot 的地方可以選擇用\nusb 開機。\n在使用隨身碟（使用 live 環境）開機時會有 .iso 裡面自帶的套件可以用，例如 vim、iwd、zsh 等等指令，但這些套件在安裝完成的 arch 裡面不會自動附上。\n確認啟動模式 1  ls /sys/firmware/efi/efivars   如果指令沒有報錯，則系統在 UEFI 模式下啓動。如果目錄不存在，系統可能以 BIOS 或 CSM 模式啓動。\n連上網路 使用 iwctl 連上 Wi-Fi 網路\n1 2 3 4  iwctl [iwd]# device list [iwd]# station DEVICE scan [iwd]# station DEVICE connect SSID   其中 DEVICE 是你的網路介面裝置的名稱\n可以用 ping 確認連線狀態\n1  ping archlinux.org   更新系統時間 1  timedatectl set-ntp true   切割與格式化硬碟 把你的硬碟分區，至少要切出用來當 root（/）跟 boot（/boot）的兩塊，其中 boot 要至少大約 260 MB。非常推薦把（/home）也切成獨立的一塊，到時候重裝的時候比較方便。\n另外還可以切一塊來當作 swap，我自己切大約 2G（？）\n假設你的硬碟是 /dev/sda，那麼可以用 fdisk /dev/sda 來修改與查詢分割區。\n基本上 fdisk 指令按 m 就可以獲得很多提示，此外在下 w （儲存）指令之前都不會真正的修改分割區，因此 w 要小心一點下。\n接著就是要格式化每個切割出來的分區。\n格式化一般的 linux 檔案系統（通常是 ext4）的指令如下，假設要格式化的是 /dev/sda3 與 /dev/sda4 分區，分別當作根分區（root partition）與 home 分區。\n1 2  mkfs.ext4 /dev/sda3 mkfs.ext4 /dev/sda4   swap 分割區可以用 mkswap 格式化。\n1  mkswap /dev/dev/sda2   一個 EFI 系統分區通常是用 FAT32 格式化\n1  mkfs.fat -F 32 /dev/sda1   掛載處理好的硬碟 將根分區掛載到 /mnt，其他對應的硬碟分區也掛載到對應的掛載點。\n例如：\n1 2 3 4 5  mount /dev/sda3 /mnt mkdir /mnt/{home,boot} mount /dev/sda1 /mnt/boot # mount /dev/sda1 on boot mount /dev/sda4 /mnt/home # mount /dev/sda4 on home swapon /dev/sda2 # enable swap   安裝 使用 pacstrap 指令在 /mnt 安裝以下三個 package\n1  pacstrap /mnt base linux linux-firmware   再次注意 base 軟體包中不包含 live 環境中的所有工具，因此像是 vi、git 等基礎設施（？）可以記得安裝。\n配置系統 接下來我們會換根成 /mnt 並對裡面的文件做一些修改\n首先把 fstab 文件放到 etc/fstab\n1  genfstab -U /mnt \u0026gt;\u0026gt; /mnt/etc/fstab   正式把 /mnt 當成我們的新根，進入新系統。\n1  arch-chroot /mnt   接下來，可以看到 console 最前面有 (chroot) 字樣，表示你的操作現在只會看得到並且只會影響原本的 /mnt，也是新的 /。\n時區 1  ln -sf /usr/share/zoneinfo/Asia/Taipei /etc/localtime   執行 hwclock\n1  hwclock --systohc   locale 編輯 /etc/locale.gen，取消註釋 en_US.UTF-8 UTF-8 和其它需要的 locale，然後執行以下指令來生成它們：\n1  locale-gen   在 /etc/locale.conf 設定\n1  LANG=en_US.UTF-8   host name 編輯 /etc/hostname 成自己喜歡的名字（？）\n順帶一提前面所說的編輯只可以用已經安裝在新根的軟體，例如 vi 之類的。\n1  pacman -S vi   設定 root 密碼 1  passwd   安裝 bootloader 我使用的 bootloader 是 GRUB。\n1 2 3  pacman -S grub efibootmgr grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=GRUB grub-mkconfig -o /boot/grub/grub.cfg   安裝 KDE 桌面環境 1 2  pacman -S xorg plasma sddm networkmanager pacman -S kate dolphin git zsh konsole openssh gvim # 一些我常用的基礎東東（？）   途中的選項我都是選預設的。\n安裝完成後，記得啟用 sddm 與 networkmanager 的 service\n1 2  systemctl enable sddm systemctl enable NetworkManager   注意不要同時啟用 iwd 與 NetworkManager 兩個網路 service，否則打架會讓你的 sudo 動不了很難受…\n增加非 root user 以及給予 sudo 1 2  useradd USER -m passwd USER   編輯 sudoer 的設定檔，把\n1  %sudo ALL=(ALL:ALL) ALL   這行的註解取消掉，讓 sudo 這個 group 的人可以使用 sudo。\n接著\n1 2  groupadd sudo usermod -aG sudo USER   會需要新增一個 user 是因為 plasma 不允許 root 直接登入桌面環境，而讓其有 sudo 權限是因為做任何事情像是裝套件都會需要有 sudo 權限。\n結束！ 退出 chroot（exit 或 Ctrl + D），並 reboot\n一切搞定，可以去用 GUI 改 KDE 的一些設定，像是 theme、工作列或是觸控版方向（？）\n還有可以裝一個 web browser，我自己常用 google-chrome，可以用 AUR 安裝。\n1 2 3  git clone https://aur.archlinux.org/google-chrome.git cd google-chrome makepkg -si # build the package, install dependencies, install itself   ","permalink":"https://omeletwithoutegg.github.io/2022/02/08/arch-install-202202/","tags":["arch","linux","pacman","KDE","plasma","grub"],"title":"Arch Install 202202"},{"contents":"First semester in csie 部落格已經年久失修ㄌ…\n來講講這學期都在做什麼好了\n計算機程式設計 系上大一必修，大致上是教 C 的語法，從基本 IO 到指標、檔案操作、簡單遞迴等等。\n在高中有參加過程式競賽可以向教授申請當「真強者」，可以不用小考、上課就會在學期末拿到 A+，而通常「真強者」負責的工作是讓這門課的學生可以問問題，並且要負責驗題，整學期總共 30 題吧。\n劉邦鋒教授很毒舌（？）常常嘴砲學生跟助教，然後這學期說助教出的測資太爛，我們又多了一個出測資的工作。\n普通物理學甲上 另一個大一必修，上課教授是呂榮祥教授。\n上課不點名（超優！！），所以我後面都沒有去上課XD\n作業每個禮拜有似乎是從課本挑的題目，以及 VPython 模擬。\nVPython 照著 pdf 做大概就可以抄掉九成的 code 了，真的不想認真的話可以找到網路上一模一樣的題目。\n推薦每個禮拜好好做作業，因為段考會出作業題，剩下的大概就佛系看投影片吧（？）\n沒去上課還能抱佛腳拿到 A+ 應該算甜涼課吧。\n微積分一二（？） 在高三的時候有修所以抵免掉了。\n計算機概論 就教計概。\n作業是 nand2tetris 前面的幾個 project，要學會寫一些奇怪的語言。\n沒有期末考，只有 Final Project，我們的 Final Project 是用很像組合語言的 Jack 語言做一個小遊戲。\n期中考考上課有講的東西，應該不算難（？）\n可是我只有拿到 A-，但也沒有追根究底因為 C+ 根本稀釋不了ㄌ。\n可能還有一個原因是罪惡感，前半有比較認真看影片但後面就沒看QQ\n線性代數 在學期初努力（？）加簽到的大二必修。單班李明穗教授。\n我們這群有修線代的人因為老師上課沒有留任何投影片或是紀錄檔，所以有一起做一個共筆，把上課的東西抄下來。\n學期前半我沒怎麼上課，後面有跟著有去修的人借教室一起聽線上課。\n大部分人都覺得教的內容太少，不如自己看課本學比較快。\n然後每個禮拜有作業、有三次期末考，其實大部分都是熟練計算，和我想像的有差距。\n說得誇張一點，這門課就是教你怎麼做高斯消去法的。期末考計算量真的死人。\n順帶一提這學期的考試有至少兩次題目有問題，然後後來考完才說是題意不清，讓人很煩躁，不過反正最後還是 A+。\n醫學與生活 和王勻一起修的通識，但拿到 C+ 有夠慘…\n據說是學期當中有兩次抽點名我們都沒點到，有一次甚至還是因為為了體育分數去參加拔河@@\n反正是一個每週三要去醫學院聽兩小時左右的東西的課程，每次的講者都不同，另外還有一次實體參訪醫學人文博物館。\n分數除了出席（抽點…）以外還有實體參訪心得、整學期任選一些課的心得，還有期末考分數。\n後來去問為什麼會 C+ ，分數要不回來，老師所說期末考只是考考形式我也不想在乎了@@\n健康體適能 就體育課，從小到大上的那種。\n他是唯一一門我要早起的課（計程也在早上但不用上課），然後最後一兩堂我睡過頭沒請假出席分數被扣爆，再加上我有一些加分也沒有加滿，最後被老師憐憫才拿到 B-，我好像不太能說什麼…\n演算法設計與分析（ADA） 也是在學期初加簽到的大二必修，是系上著名硬課之一。\n這門課主要學到的會是如何好好（因為我覺得我常常寫的不嚴謹但還是有分數，所以我不會說嚴謹）證明演算法的正確性跟時間複雜度。\n作業的部份有程式題跟手寫證明，還有在 NTU COOL 上的mini HW。\n程式題引用別人的說法就是「助教沒有在控難度」XD，但給人寫的時間都很長（三個禮拜），所以如果不太會可以到處問人或是利用 TA hour 問助教。\n手寫證明通常不難，只是要寫的落落長很煩而已。\nmini HW 可能是選擇題或是簡答題，反正就是就算沒去上課每個禮拜最好也記得寫的東西。\n這次的期中考平均分數悽慘兮兮，題目基本上沒什麼人可以寫完，而且還有一堆難題@@；而期末考就比較佛心一點了，少了一題而且有很多不用寫理由的題目。\n如果你是高中有摸到 TOI 的一員，你大概會覺得前半都在講很多廢話，而且考試相對不難（但是時間還是很少）\n大致上來說，投影片的內容你都看過覺得會，那考試大概就不用太擔心了。推薦熟記名詞，以及去看考古題（例如要你構某個假解的反例，但注意題目可能跟考古題有微妙不同）還有練習寫字。總是會 A+ 的。\n程式設計技巧（ICPC 培訓班） 要參加 ICPC 的人會來參加的課。每週六打五小時的比賽。\n這門三學分也不算是輕鬆的三學分，想拿到 A+ 大概不是要常常練習就是要在學期末把大部分的題目都補完。\n這學期實質上花很多時間的課，因為隊友們超級認真（？）每週團練兩三次，感覺不太到自己有什麼成長，但我們三個合作的能力應該有練習起來（吧？）\n結語 不是資工系的課通常都不是特別甜，最好小心像是出席或是參加特定活動加分等等，搞不好掉 A+ 的原因就是這樣QQ\n另外寫完這篇我才發現因為周圍的人都很注重 GPA 讓我現在講的好像分數是一切一樣，但其實我不知道 GPA 實質用途是什麼，好像人生的重心不應該是這個？？\n對未來缺乏規劃的廢人…\n娛樂、閒話 這學期學會打日麻了，快速中毒，每天通勤必定打開雀魂 XD\n另外也覺得自己比較會 tetris 了（雖然還是好菜），有一小段時間是會玩 tetr.io 一個晚上的（？）\n音遊好像好久好久沒有打了，疫情讓我拿掉這個習慣，新埔的點又撤掉我常玩的音遊，要玩音遊的麻煩度直接直線上升就沒玩了。\n不知道是大學後大家才開始有卦還是只是我國高中太邊，反正好像偶爾閒聊的時候話題都稍微會出現八卦，又或許只是我現在才意識到這叫做八卦吧（？）\n這個禮拜爆重裝 arch，覺得自己快變成重灌狂人了。\n下一篇來紀錄自己裝 arch 的流程好了。或是講貓樹？總之不知道下一篇文章會是什麼時候。\n","permalink":"https://omeletwithoutegg.github.io/2022/02/04/csie-1st-sem/","tags":["CSIE"],"title":"第一學期修課心得"},{"contents":"2021 TOI 模考 可能因為以前 TOI 模考題也不太公開，好像從來沒人做過這種事情，但因為現在模考題甚至可以在公開的 facebook 社團看到，所以我認為這樣沒有太不妥。\n今年的題目相較於去年簡單很多（去年好難…），所以就嘗試把四次模擬考總共 16 題的解寫完啦～要是能幫上想做今年模考題的人就好了！\n如果想在 hackmd 上看的話可以戳 https://hackmd.io/@omeletwithoutegg/TOI-2021-sols\n如果只想看題目可以戳\nhttps://www.facebook.com/notes/%E8%B3%87%E8%A8%8A%E7%AB%B6%E8%B3%BD%E9%81%B8%E6%89%8B%E6%96%B0%E6%89%8B%E6%9D%91/toi-2021/823380795202246/\n免責條款 因為測資不一定夠強，有些解也是賽後討論才AC或是甚至只有精神AC的\n所以這裡的解有可能任何錯誤或是唬爛，不可全盤相信。\n註：三模跟四模的 code 幾乎都沒有丟到師大開放的臨時 judge 上跑，所以不保證正確。\n一模 p1 shortcut 題意 定義一張圖的總花費是所有點對之間的最短距離總和。\n給定一張 $n$ 點 $m$ 邊的簡單無向連通圖，在你可以加一條邊的情況下，和原圖相比最多可以減少多少總花費？又有幾種加邊的方式可以減少那麼多花費？\n限制 $3 \\leq n \\leq 500; n-1 \\leq m \\leq n(n-1)/2-1$\n subtask 1 (9) $n \\leq 40$ subtask 2 (22) $n \\leq 150$ subtask 3 (18) $m = n-1$ subtask 4 (51) 無額外限制  作法  $\\mathcal{O}(n^5)$\n$\\mathcal{O}(n^2)$枚舉要加的邊，每次重新做$n$次BFS(一次$\\mathcal{O}(n+m)$)或是Floyd-Warshall $\\mathcal{O}(n^4)$\n每次枚舉要加的邊$(a,b)$時，計算每個點對的距離減少了多少，也就是$\\sum_{i \u0026lt; j} \\max(0, d(i,j) - (d(i,a)+1+d(b,j)), d(i,j)-(d(i,b)+1+d(a,j)))$，其中$d(i,j)$是原圖中$i$與$j$的最短距離，可以$\\mathcal{O}(n^3)$預處理。 $\\mathcal{O}(n^3)$\n前面的那個式子裡面的項代表的分別是$i\\to a\\to b\\to j$和$i\\to b\\to a\\to j$兩條路徑所減少的距離。可以發現這兩條路徑只有其中一條可能比原圖$i\\to j$的路徑短，因為如果兩條都比原本的最短路徑短的話，那麼$i\\to a\\to j$或是$i\\to b\\to j$其中一個會是更短路徑，矛盾。\n也就是說，我們在算總花費減少多少的時候可以改為計算$\\sum_{ i,j}\\max(0,d(i,j)-(d(i,a)+1+d(b,j)))$\n考慮固定 $i,b$，那麼$j,a$之間是獨立的，我們可以拆成$\\max(0,(d(i,j)-d(b,j)-1) - d(i,a))$，而對於每個$A_i$，$\\sum_{j} \\max(0,B_j-A_i)$是一個經典的問題，可以利用前綴和、後綴和的概念，或是排序（counting sort）+爬行法在線性時間內解決。總複雜度是枚舉所有$i,b$所需的$\\mathcal{O}(n^2)$乘上對每個$a$計算$\\max(0,(d(i,j)-d(b,j)-1) - d(i,a))$所需要的複雜度$\\mathcal{O}(n)$，也就是$\\mathcal{O}(n^3)$。  code 註：下面的code可能有些變數跟上面寫的不太一樣，例如$i,j,a,b$的角色可能有點顛倒。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95  #pragma GCC optimize(\u0026#34;Ofast\u0026#34;, \u0026#34;unroll-loops\u0026#34;) #pragma loop_opt(on) #include \u0026lt;bits/stdc++.h\u0026gt;#ifdef local #define debug(a...) qqbx(#a, a) #define safe cerr\u0026lt;\u0026lt;__PRETTY_FUNCTION__\u0026lt;\u0026lt;\u0026#34; line \u0026#34;\u0026lt;\u0026lt;__LINE__\u0026lt;\u0026lt;\u0026#34; safe\\n\u0026#34; template \u0026lt;typename ...T\u0026gt; void qqbx(const char *s, T ...a) { int cnt = sizeof...(T); ((std::cerr \u0026lt;\u0026lt; \u0026#34;\\033[1;32m(\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;) = (\u0026#34;), ... , (std::cerr \u0026lt;\u0026lt; a \u0026lt;\u0026lt; (--cnt ? \u0026#34;, \u0026#34; : \u0026#34;)\\033[0m\\n\u0026#34;))); } #else #define debug(...) ((void)0) #define safe ((void)0) #endif // local  using namespace std; using ll = int64_t; const int maxn = 505, inf = 1e9; int dis[maxn][maxn]; int ans[maxn][maxn]; ll sum[maxn]; int cnt[maxn]; int n, m; signed main() { ios_base::sync_with_stdio(0), cin.tie(0); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 0; i \u0026lt; n; i++) for (int j = 0; j \u0026lt; n; j++) if (i != j) dis[i][j] = inf; for (int i = 0; i \u0026lt; m; i++) { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; --a, --b; dis[a][b] = dis[b][a] = 1; } for (int k = 0; k \u0026lt; n; k++) { for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n; j++) { dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]); } } } for (int a = 0; a \u0026lt; n; a++) { for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n; j++) sum[j] = cnt[j] = 0; for (int b = 0; b \u0026lt; n; b++) { int d = dis[a][b] - dis[i][b] - 1; if (d \u0026lt; 0) continue; cnt[d] += 1; sum[d] += d; /* for (int j = 0; j \u0026lt; i; j++) { ans[i][j] += max(0, dis[a][b] - dis[i][b] - 1 - dis[a][j]); // \\sum _ {d \u0026gt;= dis[a][j]} (d - dis[a][j]) // where d = dis[a][b] - dis[i][b] - 1 } */ } for (int j = n-1; j \u0026gt;= 0; j--) sum[j] += sum[j+1], cnt[j] += cnt[j+1]; for (int j = 0; j \u0026lt; i; j++) { int d = dis[a][j]; ans[i][j] += sum[d] - cnt[d] * d; } } } ll mx = -1; int cnt = 0; for (int i = 0; i \u0026lt; n; i++) for (int j = 0; j \u0026lt; i; j++) { if (ans[i][j] == mx) ++cnt; else if (ans[i][j] \u0026gt; mx) mx = ans[i][j], cnt = 1; } cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; mx \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } /* 5 4 1 2 2 3 3 4 2 5 5 5 1 2 2 3 3 4 4 5 5 1 */   p2 multiple 題意 給定 $n, m, k, R$，請輸出所有二進位表示法（不含前導 0）恰好有 $n$ 個 1， $m$ 個 0，且可以被 $k$ 整除的數字中，第 $R$ 大的數字。若答案不存在則輸出 impossible 。\n限制 $1 \\leq n, m \\leq 20000$\n$1 \\leq k \\leq 500$\n$1 \\leq R \\leq 10^9$\n subtask 1 (13) $n, m, k \\leq 10$ subtask 2 (5) $k = 3$ subtask 3 (39) $n, m, k \\leq 500$ subtask 4 (24) $R = 1$ subtask 5 (19) 無額外限制  作法  $n,m,k\\leq 10$\n可以$\\mathcal{O}(2^{n+m})$枚舉所有$n$個1、$m$個0的數字 $n,m,k \\leq 500$\n先考慮答案是否是impossible的問題，等價於問說所有$n$個1、$m$個0、被$k$整除，且沒有前導0的數字是否有至少$R$種。先不管前導0的問題，我們可以列出DP式\n$$\nf(i,j,r) = f(i-1,j,r-2^{i+j-1}) + f(i,j-1,r)\n$$\n其中$f(i,j,r)$代表有$i$個1、$j$個0、除以$k$餘數是$r$的數字種類。\n那麼，只要看$f(n-1,m,-2^{n+m-1})$就能得知符合條件的數字有多少種。\n要如何得知第$R$大的字串呢？最高位必須先填1，我們從第二高位開始看。\n對於第 $i$ 位，假設填了1之後，後面剩下的後綴有$x$種方法使得整個數字是符合條件的，那麼如果$x \\geq R$，我們就知道第$R$大的數字第 $i$ 位是1了，因此就繼續看下一位，求取剩下的後綴的第$R$大符合條件的字串。如果$x \u0026lt; R$的話，第$R$大的數字第 $i$ 位就是0，要注意的是有 $x$ 個符合條件的數字第 $i$ 會是 $1$，也就是說我們必須求取剩下的後綴的第$R-x$大的符合條件的字串。\n說了那麼多其實就跟在二元樹上二分搜第$R$大的數有點類似，注意：不要找成第$R$小、不要忘記前導0、往左邊走的時候不要忘記扣掉右邊子樹大小。在計算$f$的時候可能會爆int，但是其實過程中可以跟1e9取min之類的，因為大於$R$的數字我們也不需要。\n時間跟空間複雜度是$\\mathcal{O}(nmk)$，似乎空間常數有點緊。 無額外限制\n$n$個1、$m$個0的字串有$\\binom{n+m}{n}$個，猜測平均大約每種可能出現的餘數會有$\\binom{n+m}{n}/k$個，那麼只要湊出每種餘數的方法數都超過$R$，就能不dp而直接從最高位開始不斷的拿1，直到$\\binom{n+m}{n}/k$足夠小。實際打表驗證，$\\min(n,m) \\geq 22$足夠使得每種mod下的每種餘數都出現至少$10^9$種字串。\n$\\min(n,m) \u0026lt; 22$的話，$\\mathcal{O}(nmk)$的演算法就足夠在時限內算出答案了，因為$nmk\\leq 20000\\times 22\\times 100 \\approx 4e8$  code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105  #pragma GCC optimize(\u0026#34;Ofast\u0026#34;) #include \u0026lt;bits/stdc++.h\u0026gt;#ifdef local #define debug(a...) qqbx(#a, a) #define safe cerr\u0026lt;\u0026lt;__PRETTY_FUNCTION__\u0026lt;\u0026lt;\u0026#34; line \u0026#34;\u0026lt;\u0026lt;__LINE__\u0026lt;\u0026lt;\u0026#34; safe\\n\u0026#34; template \u0026lt;typename ...T\u0026gt; void qqbx(const char *s, T ...a) { int cnt = sizeof...(T); ((std::cerr \u0026lt;\u0026lt; \u0026#34;\\033[1;32m(\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;) = (\u0026#34;), ... , (std::cerr \u0026lt;\u0026lt; a \u0026lt;\u0026lt; (--cnt ? \u0026#34;, \u0026#34; : \u0026#34;)\\033[0m\\n\u0026#34;))); } #else #define debug(...) ((void)0) #define safe ((void)0) #endif // local #define pb emplace_back #define all(v) begin(v),end(v)  using namespace std; using ll = int64_t; const int maxn = 20005, maxm = 22, maxk = 500; const int inf = 1e9; void fail() { cout \u0026lt;\u0026lt; \u0026#34;impossible\\n\u0026#34;; exit(0); } void add(int \u0026amp;x, int v) { x = min(inf + 1, x + v); } int p2[maxn*2]; int dp[maxn][maxm][maxk]; signed main() { ios_base::sync_with_stdio(0), cin.tie(0); int n, m, k, R; assert( cin \u0026gt;\u0026gt; m \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k \u0026gt;\u0026gt; R ); // while (k % 2 == 0);  p2[0] = 1; for (int i = 1; i \u0026lt; maxn*2; i++) p2[i] = p2[i-1] * 2 % k; dp[0][0][0] = 1; for (int i = 0; i \u0026lt; maxn; i++) { for (int j = 0; j \u0026lt; maxm; j++) { for (int r = 0; r \u0026lt; k; r++) { if (i+1 \u0026lt; maxn) add(dp[i+1][j][r], dp[i][j][r]); if (j+1 \u0026lt; maxm) add(dp[i][j+1][(r + p2[i+j]) % k], dp[i][j][r]); } } } string ans; if (m \u0026lt; maxm) { int r = 0; for (int i = 0; i \u0026lt; n+m; i++) r = (r + p2[i]) % k; ans += \u0026#39;1\u0026#39;; --n; if (dp[n][m][r] \u0026lt; R) fail(); while (n \u0026gt; 0 || m \u0026gt; 0) { if (n \u0026gt; 0 \u0026amp;\u0026amp; dp[n-1][m][r] \u0026gt;= R) { ans += \u0026#39;1\u0026#39;; --n; } else { ans += \u0026#39;0\u0026#39;; if (n) R -= dp[n-1][m][r]; r = (r - p2[n+m-1] + k) % k; --m; } } } else { int r = 0; ans += \u0026#39;1\u0026#39;; r = (r - p2[n+m-1] + k) % k; --n; while (n \u0026gt;= maxm) { ans += \u0026#39;1\u0026#39;; r = (r - p2[n+m-1] + k) % k; --n; } if (dp[m][n][r] \u0026lt; R) fail(); while (n \u0026gt; 0 || m \u0026gt; 0) { if (n \u0026gt; 0 \u0026amp;\u0026amp; dp[m][n-1][(r-p2[n+m-1]+k)%k] \u0026gt;= R) { ans += \u0026#39;1\u0026#39;; r = (r - p2[n+m-1] + k) % k; --n; } else { ans += \u0026#39;0\u0026#39;; if (n) R -= dp[m][n-1][(r-p2[n+m-1]+k)%k]; --m; } } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }   p3 bacteria 題意 互動題，現在有一個遞迴數列形如\n$$\n\\left\\{\\begin{matrix}\na_0 = \u0026amp; A \\\\\na_1 = \u0026amp; A+B \\\\\na_n = \u0026amp; a_{n-1}+a_{n-2}+f(n) \u0026amp; (n \\geq 2)\n\\end{matrix}\\right.\n$$\n其中$f(n)$是下列四種的其中一種\n $f(n) = 1$ $f(n) = n^2$ $f(n) = n^2 \\times 2^n$ 如果$n$是奇數，$f(n) = 2^n$，否則$f(n) = 0$  另外有一個祕密的$T$，保證$T \\geq 5$。\n現在給你$t(t \u0026gt; 0)$，請回答$a_{T+t}$除以$10^9+7$的餘數。你可以呼叫history(x)(必須滿足$0\\leq x\\leq 10^6$)，如果$x \\leq T$，評測系統會回答你$a_{T-x}$除以$10^9+7$的餘數，否則會回答你0。\n同時你也可以詢問$A$，$B$的值，或是$f(n)$是四種的哪一種，但是會被扣一定比例的分數。\n限制與計分 假設你呼叫的 history 次數為 $C_h$ ，此外同時定義 $C_M, C_A, C_B$ 三個數值，其中 $C_M$ 的值為 1 或 0，表示有無詢問$f(n)$的種類。$C_A$和$C_B$也相似，分別代表有無詢問$A$，$B$的值。得到的分數比重 $S$ 定義如下：\n$S = \\min(1.0, \\sqrt{\\frac{\\log 6}{\\log C_h}}) \\times (1.0 - 0.5 C_M - 0.1 C_A - 0.1 C_B)$\n對於每個 subtask ，若你成功回答所有詢問，你的得分就是該子任務的分數，乘上那筆 subtask 所有測資中 $S$ 最低者。\nsubtask 1 (4) $f(n)$是第一種，並且 $1 \\leq t \\leq 10^6$\nsubtask 2 (5) $f(n)$是第二種，並且 $1 \\leq t \\leq 10^6$\nsubtask 3 (6) $f(n)$是第三種，並且 $1 \\leq t \\leq 10^6$\nsubtask 4 (7) $f(n)$是第四種，並且 $1 \\leq t \\leq 10^6$\nsubtask 5 (23) $T \\leq 1000$，並且 $1 \\leq t \\leq 10^{18}$\nsubtask 6 (55) $T$ 無限制，$1 \\leq t \\leq 10^{18}$\n作法   subtask 1 ~ 4\n注意到不管$f(n)$是四種的哪一種，$a_n$都一樣是線性遞迴數列，並且遞迴關係跟$A,B,T$都沒有關係。因此若$a_n$是$k$階線性遞迴數列，那麼就問前$k$項之後想辦法求線性遞迴的下$t$項就好了。並且對於四種$f(n)$，$k$不會大於$5$，所以詢問次數不會太多。\n要列出算式可以：\n 用紙筆硬推 假設遞迴關係，然後用高斯消去法 不要直接求出線性遞迴，只要想辦法寫出矩陣快速冪的形式，但裡面的項必須跟$A,B,T,n$都無關。 用BM演算法（    （有點唬爛的）滿分解\n首先不知道$f(n)$是哪一個了，只好按照遞迴階數由小到大帶進去，如果符合就回答，不符合就繼續看下一個遞迴關係是否符合。\n注意到，要確認是否是某種遞迴關係需要至少6項，正好可以問$x=0\\dots 5$，而不會超出範圍得到0。\n接著$t$的範圍也變得很大，必須用矩陣快速冪或是快速線性遞迴讓我們可以在$\\mathcal{O}(\\mathrm{poly}(k)\\log(t))$內得到接下來的第$t$項。\n  只用高斯消去\n假設遞迴階數至多$k$階，那麼問了$2k$項之後就能直接用BM或是高斯消去解出遞迴關係，直接固定$k$傳上去可以撈到80分上下（\n  code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124  #include \u0026lt;bits/stdc++.h\u0026gt;#ifdef local #define debug(a...) qqbx(#a, a) #define safe cerr\u0026lt;\u0026lt;__PRETTY_FUNCTION__\u0026lt;\u0026lt;\u0026#34; line \u0026#34;\u0026lt;\u0026lt;__LINE__\u0026lt;\u0026lt;\u0026#34; safe\\n\u0026#34; #define pary(a...) danb(#a, a) template \u0026lt;typename ...T\u0026gt; void qqbx(const char *s, T ...a) { int cnt = sizeof...(T); ((std::cerr \u0026lt;\u0026lt; \u0026#34;\\033[1;32m(\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;) = (\u0026#34;), ... , (std::cerr \u0026lt;\u0026lt; a \u0026lt;\u0026lt; (--cnt ? \u0026#34;, \u0026#34; : \u0026#34;)\\033[0m\\n\u0026#34;))); } template \u0026lt;typename T\u0026gt; void danb(const char *s, T L, T R) { std::cerr \u0026lt;\u0026lt; \u0026#34;\\033[1;32m[ \u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34; ] = [ \u0026#34;; for (auto it = L; it != R; ++it) std::cerr \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#39; \u0026#39;; std::cerr \u0026lt;\u0026lt; \u0026#34;]\\033[0m\\n\u0026#34;; } #else #define debug(...) ((void)0) #define safe ((void)0) #define pary(...) ((void)0) #endif // local #define pb emplace_back #define all(v) begin(v),end(v)  using namespace std; using ll = long long; const int MOD = 1000000007; int history(int); #ifdef local namespace solution { #endif // local const int maxk = 10, maxn = 1000025; vector\u0026lt;int\u0026gt; rec[4] = { {2, 0, 1000000006}, // 1  // {3, 1000000006, 1000000005}, // 2^k  {1, 5, 1000000003, 1000000003}, // k\u0026amp;1 ? 2^k : 0  {7, 999999990, 14, 4, 999999999}, // k^2 * 2^k  {4, 1000000002, 1, 2, 1000000006}, // k^2 }; int fastLinearRecurrence(vector\u0026lt;int\u0026gt; init, vector\u0026lt;int\u0026gt; rel, long long n) { vector\u0026lt;int\u0026gt; R{1}, E{0, 1}; auto mul = [\u0026amp;rel](vector\u0026lt;int\u0026gt; \u0026amp;a, const vector\u0026lt;int\u0026gt; \u0026amp;b) { vector\u0026lt;int\u0026gt; c(a.size() + b.size() - 1); for (size_t i = 0; i \u0026lt; a.size(); i++) for (size_t j = 0; j \u0026lt; b.size(); j++) c[i+j] = (c[i+j] + 1LL * a[i] * b[j]) % MOD; for (size_t i = c.size()-1; i \u0026gt;= rel.size(); i--) for (size_t j = 0; j \u0026lt; rel.size(); j++) c[i-j-1] = (c[i-j-1] + 1LL * rel[j] * c[i]) % MOD; c.resize(rel.size()); a = c; }; while (n) { if (n \u0026amp; 1) mul(R, E); mul(E, E); n \u0026gt;\u0026gt;= 1; } int sum = 0; for (size_t i = 0; i \u0026lt; R.size(); i++) sum = (sum + 1LL * init[i] * R[i]) % MOD; return sum; } int predict(ll t) { const int k = 6; vector\u0026lt;int\u0026gt; h(k); for (int i = 0; i \u0026lt; k; i++) h[i] = history(i); auto match = [\u0026amp;](vector\u0026lt;int\u0026gt; rel) { vector\u0026lt;int\u0026gt; v = h; if (rel.size() * 2 \u0026lt; v.size()) v.resize(rel.size() * 2); reverse(all(v)); pary(all(v)); pary(all(rel)); for (int i = v.size()-1, cnt = 0; i \u0026gt;= (int)rel.size(); i--) { ll sum = 0; for (size_t j = 0; j \u0026lt; rel.size(); j++) { sum = (sum + 1LL * rel[j] * v[i-j-1]) % MOD; } if (sum != v[i]) return debug(i, sum, v[i], rel.size()), false; } return true; }; for (int i = 0; i \u0026lt; 4; i++) { vector\u0026lt;int\u0026gt; v = h; v.resize(rec[i].size()); reverse(all(v)); pary(all(v)); debug(fastLinearRecurrence(v, rec[i], i+v.size()-1)); if (match(rec[i])) return fastLinearRecurrence(v, rec[i], t+v.size()-1); } return -1; } #ifdef local } const int maxn = 1000000; int val[maxn]; int pw[maxn]; int start, A, B; int history(int z) { if (z \u0026gt; start) return 0; return val[start - z]; } signed main() { cin \u0026gt;\u0026gt; start \u0026gt;\u0026gt; A \u0026gt;\u0026gt; B; val[0] = A; val[1] = A+B; pw[0] = 1; for (int i = 1; i \u0026lt; maxn; i++) pw[i] = pw[i-1] * 2 % MOD; for (int i = 2; i \u0026lt; maxn; i++) val[i] = 1LL*i*i%MOD*pw[i]%MOD; for (int i = 2; i \u0026lt; maxn; i++) val[i] = (0LL + val[i] + val[i-1] + val[i-2]) % MOD; cout \u0026lt;\u0026lt; solution::predict(1) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; debug(history(-1)); } #endif // local   p4 shooting 題意 有 $n$ 個目標物，每個目標物都是一個水平線段 $[s, t]$ 或是只含一點（$s = t$ 的情形），並且有各自的分數 $w$，所有目標物的高度（Y 值）均大於 0 且互不相同（輸入按照 Y 座標由大到小排序）。\n現在依序發射了 $m$ 發砲彈，第 $i$ 次會從 X 軸上的整數點 $x_i$ 往上垂直發射砲彈，路線上第一個碰到的目標物就是擊中的目標，射中目標後砲彈與目標物一起消失，不會穿透。如果沒有擊中任何目標物，則該次射擊分數為 0。請輸出每次有擊中的目標物的分數總和。\n限制 $1 \\leq n, m \\leq 5 \\times 10^5$\n$0 \\leq s \\leq t \\leq 10^9, 0 \\leq w \\leq 1000$\n$0 \\leq x_i \\leq 10^9$\nsubtask 1 (5) $n, m \\leq 10^5$；X 座標範圍不超過 10000；對於所有目標物皆有 $s = t$\nsubtask 2 (7) $n, m \\leq 10^5$；X 座標範圍不超過 10000；對於每個目標線段皆有 $t-s \\leq 10$\nsubtask 3 (15) $n, m \\leq 10^5$；砲彈射擊位置為由左至右，也就是 $x_1 \\leq \u0026hellip; \\leq x_n$\nsubtask 4 (25) $n, m \\leq 10^5$\nsubtask 5 (48) 無額外限制 （ $n, m \\leq 5 \\times 10^5$ ）\n作法  $s = t$\n開一個vector\u0026lt;int\u0026gt; seg[10001]存每個X座標的目標物編號，接著每次發射砲彈就把那一格嘗試pop出東西來。 $t - s \\leq 10$\n延續前一個subtask的作法，但每一格存的是包含這一格的目標物編號，空間複雜度是$\\mathcal{O}(\\sum (t-s))$ 滿分解\n首先可以對$x_i$離散化（值域壓縮）\n從線段樹的結構出發，把每個目標物的區間拆成$\\mathcal{O}(\\log n)$個節點代表的區間，並把編號存在那些節點上，每個節點開一個vector之類的存。那麼要查一次射擊會打到誰，就是看那個葉子到根的路徑，Y座標最小而且還沒被射掉的目標物是誰了。 另一種滿分解\n從Y座標最小的目標物開始看，考慮他會被哪次射擊打到，也就是查詢這個區間裡面發射時間最早的是誰。假如整個區間都沒有發射過，那麼就直接忽略這個目標物；否則就把對應到的那一次發射記為已經用過。寫一個單點改值區間查詢最大值的線段樹之類的就完工啦～\n上面兩種解的時間複雜度都是$\\mathcal{O}(n\\log n)$，不過第一種作法要注意空的deque有點肥，因此使用deque、stack、queue都有可能MLE。  code 第一種解\nnote: not verified\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89  #pragma GCC optimize(\u0026#34;Ofast\u0026#34;) #include \u0026lt;bits/stdc++.h\u0026gt;#ifdef local #define safe cerr\u0026lt;\u0026lt;__PRETTY_FUNCTION__\u0026lt;\u0026lt;\u0026#34; line \u0026#34;\u0026lt;\u0026lt;__LINE__\u0026lt;\u0026lt;\u0026#34; safe\\n\u0026#34; #define pary(a...) danb(#a, a) #define debug(a...) qqbx(#a, a) template \u0026lt;typename ...T\u0026gt; void qqbx(const char *s, T ...a) { int cnt = sizeof...(T); ((std::cerr \u0026lt;\u0026lt; \u0026#34;\\033[1;32m(\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;) = (\u0026#34;) , ... , (std::cerr \u0026lt;\u0026lt; a \u0026lt;\u0026lt; (--cnt ? \u0026#34;, \u0026#34; : \u0026#34;)\\033[0m\\n\u0026#34;))); } template \u0026lt;typename T\u0026gt; void danb(const char *s, T L, T R) { std::cerr \u0026lt;\u0026lt; \u0026#34;\\033[1;32m[ \u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34; ] = [ \u0026#34;; for (int f = 0; L != R; ++L) std::cerr \u0026lt;\u0026lt; (f++ ? \u0026#34;, \u0026#34; : \u0026#34;\u0026#34;) \u0026lt;\u0026lt; *L; std::cerr \u0026lt;\u0026lt; \u0026#34; ]\\033[0m\\n\u0026#34;; } #else #define debug(...) ((void)0) #define safe ((void)0) #define pary(...) ((void)0) #endif // local #define all(v) begin(v),end(v) #define pb emplace_back #define get_pos(u,x) int(lower_bound(all(u),x)-begin(u))  using namespace std; using ll = int_fast64_t; using ld = long double; template \u0026lt;typename T\u0026gt; using min_heap = priority_queue\u0026lt;T, vector\u0026lt;T\u0026gt;, greater\u0026lt;T\u0026gt;\u0026gt;; const int mod = 1000000007; const int inf = 1e9; const ll INF = 1e18; const int maxn = 500002; bool removed[maxn]; struct Segtree { int n; vector\u0026lt;int\u0026gt; st[maxn * 4]; void init(int _n) { n = _n; } void add(int l, int r, int id) { for (l += n, r += n; l \u0026lt; r; l \u0026gt;\u0026gt;= 1, r \u0026gt;\u0026gt;= 1) { if (l \u0026amp; 1) st[l++].push_back(id); if (r \u0026amp; 1) st[--r].push_back(id); } } int query(int p) { int res = -1; for (p += n; p; p \u0026gt;\u0026gt;= 1) { while (!st[p].empty() \u0026amp;\u0026amp; removed[st[p].back()]) st[p].pop_back(); res = max(res, st[p].empty() ? -1 : st[p].back()); } return res; } } sgt; signed main() { ios_base::sync_with_stdio(0), cin.tie(0); int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; vector\u0026lt;tuple\u0026lt;int,int,int\u0026gt;\u0026gt; seg(n); vector\u0026lt;int\u0026gt; xs(m), u; for (auto \u0026amp;[s, t, w]: seg) cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t \u0026gt;\u0026gt; w, ++t, u.pb(s), u.pb(t); for (int \u0026amp;x: xs) cin \u0026gt;\u0026gt; x; u.insert(u.end(), all(xs)); sort(all(u)), u.erase(unique(all(u)), u.end()); sgt.init(u.size()); for (int i = 0; i \u0026lt; n; i++) { auto [s, t, w] = seg[i]; s = get_pos(u, s); t = get_pos(u, t); sgt.add(s, t, i); } ll ans = 0; for (int x: xs) { x = get_pos(u, x); int id = sgt.query(x); if (id != -1) { debug(id); auto [s, t, w] = seg[id]; ans += w; removed[id] = true; } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }   第二種解\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72  #include \u0026lt;bits/stdc++.h\u0026gt;#ifdef local #define debug(a...) qqbx(#a, a) #define safe cerr\u0026lt;\u0026lt;__PRETTY_FUNCTION__\u0026lt;\u0026lt;\u0026#34; line \u0026#34;\u0026lt;\u0026lt;__LINE__\u0026lt;\u0026lt;\u0026#34; safe\\n\u0026#34; template \u0026lt;typename ...T\u0026gt; void qqbx(const char *s, T ...a) { int cnt = sizeof...(T); ((std::cerr \u0026lt;\u0026lt; \u0026#34;\\033[1;32m(\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;) = (\u0026#34;), ... , (std::cerr \u0026lt;\u0026lt; a \u0026lt;\u0026lt; (--cnt ? \u0026#34;, \u0026#34; : \u0026#34;)\\033[0m\\n\u0026#34;))); } #else #define debug(...) ((void)0) #define safe ((void)0) #endif // local #define pb emplace_back #define all(v) begin(v),end(v)  using namespace std; using ll = int64_t; const int maxn = 505, inf = 1e9; struct Segtree { int n; vector\u0026lt;int\u0026gt; mn; Segtree(int sz, function\u0026lt;int(int)\u0026gt; v) : n(sz), mn(sz*2) { for (int i = 0; i \u0026lt; n; i++) mn[i+n] = v(i); for (int i = n-1; i \u0026gt; 0; i--) mn[i] = min(mn[i\u0026lt;\u0026lt;1], mn[i\u0026lt;\u0026lt;1|1]); } int queryMin(int l, int r) { int res = inf; for (l += n, r += n; l \u0026lt; r; l \u0026gt;\u0026gt;= 1, r \u0026gt;\u0026gt;= 1) { if (l \u0026amp; 1) res = min(res, mn[l++]); if (r \u0026amp; 1) res = min(res, mn[--r]); } return res; } void edit(int p, int v) { for (mn[p+=n] = v; p\u0026gt;1; p\u0026gt;\u0026gt;=1) mn[p\u0026gt;\u0026gt;1] = min(mn[p], mn[p^1]); } }; signed main() { ios_base::sync_with_stdio(0), cin.tie(0); int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; vector\u0026lt;tuple\u0026lt;int,int,int\u0026gt;\u0026gt; seg(n); vector\u0026lt;int\u0026gt; xs(m), u; for (auto \u0026amp;[s, t, w]: seg) cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t \u0026gt;\u0026gt; w, ++t, u.pb(s), u.pb(t); for (int \u0026amp;x: xs) cin \u0026gt;\u0026gt; x; u.insert(u.end(), all(xs)); sort(all(u)), u.erase(unique(all(u)), u.end()); vector\u0026lt;multiset\u0026lt;int\u0026gt;\u0026gt; ms(u.size()); for (int i = 0; i \u0026lt; m; i++) { int x = lower_bound(all(u), xs[i]) - u.begin(); ms[x].insert(i); xs[i] = x; } Segtree sgt(u.size(), [\u0026amp;ms](int i){ return ms[i].empty() ? inf : *ms[i].begin(); }); reverse(all(seg)); ll ans = 0; for (auto \u0026amp;[s, t, w]: seg) { s = lower_bound(all(u), s) - u.begin(); t = lower_bound(all(u), t) - u.begin(); int id = sgt.queryMin(s, t); if (id == inf) continue; ans += w; ms[xs[id]].erase(id); sgt.edit(xs[id], ms[xs[id]].empty() ? inf : *ms[xs[id]].begin()); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }   二模 p1 stone 題意 A和B在玩拿石頭的遊戲，共有 $n$ 堆石頭，數量分別是 $a_1, a_2, \u0026hellip;, a_n$。\n首先A可以任選一堆，並從該堆取至少一個，至多 $R$ 個石頭（不能取超過該堆石頭數量）， 接著輪到B，再輪到A \u0026hellip;\n並且除了第一輪A取石頭以外，取的石頭數量都不能比對手多，但至少要取一個石頭。\n拿到最後一個石頭的人就勝利了，問A第一次取石頭有幾種方法可以讓A必勝？\n限制 $1 \\leq n \\leq 10^5$\n$1 \\leq R \\leq 10^9$\n$1 \\leq a_i \\leq 10^9$\nsubtask 1 (24) $1 \\leq n \\leq 3; 1 \\leq R \\leq 100; 1 \\leq a_i \\leq 100$\nsubtask 2 (13) $1 \\leq R \\leq 2$\nsubtask 3 (12) $n = 1$\nsubtask 4 (23) $1 \\leq n \\leq 5; 1 \\leq R \\leq 100; 1 \\leq a_i \\leq 100$\nsubtask 5 (28) 無額外限制\n作法  考慮 $R \\leq 2$ 的subtask。可以知道如果任何人拿了石頭之後，石頭的總數是偶數，那對方拿 1 個石頭就會勝利了，所以如果一開始石頭總數是奇數，那想要贏應該會盡量拿兩個石頭，而場上總共可以拿 $\\sum \\lfloor \\frac{a_i}{2} \\rfloor$ 次兩個石頭，因此判斷奇偶性就能知道誰最後會被迫拿奇數個石頭。 其實仔細想就能知道，不管 $R$ 是多少，沒有人會想讓自己拿完之後總石頭剩下奇數個，也就是說如果一開始總石頭是偶數個，那兩個人都會盡量避免拿奇數個石頭。\n可以發現只要 $R \u0026gt; 1$ ，設 $a_i'=\\lfloor \\frac{a_i}{2} \\rfloor, R'=\\lfloor \\frac{R}{2} \\rfloor$ ，解還是跟原本一樣 至此結論已經出來：從 $0 \\sim \\lfloor \\log_2 R \\rfloor$ 枚舉 $k$ 看 $\\sum \\lfloor \\frac{a_i}{2^k} \\rfloor$，如果任何一個 $k$ 發現 $\\sum \\lfloor \\frac{a_i}{2^k} \\rfloor$ 是奇數就表示先手必勝，否則先手必敗。事實上可以發現這等價於看所有 $a_i$ 的 xor 和的 lowbit 有沒有 $\\leq R$。 那要怎麼計算有幾種方法數呢？我們分開看每個 $i$ ，因為拿了之後剩下的數字 xor 和 lowbit 一定要 $\u0026gt;$ 你拿的數字，考慮枚舉這個 lowbit 是多少，可以發現對於每種lowbit 至多有一個數字會符合條件，總時間複雜度是 $\\mathcal{O}(n\\log R)$。  code 感謝 wiwiho 讓我參考 code\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62  // An AC a day keeps the doctor away. #pragma GCC optimize(\u0026#34;Ofast\u0026#34;) #include \u0026lt;bits/stdc++.h\u0026gt;#ifdef local #define safe std::cerr\u0026lt;\u0026lt;__PRETTY_FUNCTION__\u0026lt;\u0026lt;\u0026#34; line \u0026#34;\u0026lt;\u0026lt;__LINE__\u0026lt;\u0026lt;\u0026#34; safe\\n\u0026#34; #define debug(args...) qqbx(#args, args) #define orange(args...) danb(#args, args) using std::cerr; template \u0026lt;typename ...T\u0026gt; void qqbx(const char *s, T ...args) { int cnt = sizeof...(T); ((cerr \u0026lt;\u0026lt; \u0026#34;\\e[1;32m(\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;) = (\u0026#34;), ..., (cerr \u0026lt;\u0026lt; args \u0026lt;\u0026lt; (--cnt ? \u0026#34;, \u0026#34; : \u0026#34;)\\e[0m\\n\u0026#34;))); } template \u0026lt;typename T\u0026gt; void danb(const char *s, T L, T R) { cerr \u0026lt;\u0026lt; \u0026#34;\\e[1;32m[ \u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34; ] = [ \u0026#34;; for (int f = 0; L != R; ++L) cerr \u0026lt;\u0026lt; (f++ ? \u0026#34;, \u0026#34; : \u0026#34;\u0026#34;) \u0026lt;\u0026lt; *L; cerr \u0026lt;\u0026lt; \u0026#34; ]\\e[0m\\n\u0026#34;; } #else #define safe ((void)0) #define debug(...) ((void)0) #define orange(...) ((void)0) #endif // local #define all(v) begin(v),end(v)  using namespace std; int lowbit(int x) { return x \u0026amp; -x; } signed main() { ios_base::sync_with_stdio(0), cin.tie(0); int n, R; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; R; vector\u0026lt;int\u0026gt; a(n); for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; int xor_sum = 0; for (int i = 0; i \u0026lt; n; i++) xor_sum ^= a[i]; if (xor_sum == 0 || lowbit(xor_sum) \u0026gt; R) return cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;, 0; int ans = 0; for (int i = 0; i \u0026lt; n; i++) { int newA = a[i]; for (int j = 0; j \u0026lt; 30; j++) { // assume 1 \u0026lt;\u0026lt; j as highbit of R\u0026#39;  // lowbit(xor_sum ^ a[i] ^ (a[i] - R\u0026#39;)) \u0026gt; R\u0026#39;  if ((xor_sum ^ a[i] ^ newA) \u0026gt;\u0026gt; j \u0026amp; 1) { if (newA \u0026lt; (1 \u0026lt;\u0026lt; j)) break; newA -= 1 \u0026lt;\u0026lt; j; } int newR = a[i] - newA; if (newR \u0026gt; 0 \u0026amp;\u0026amp; newR \u0026lt;= R \u0026amp;\u0026amp; (int)__lg(newR) == j) { ++ans; } } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }   p2 paving 題意 有 $n$ 個格子排成一列，分別編號為 $1, 2, \\dots, n$，一開始皆是未被塗色的狀態。\n另外有 $m$ 個操作，每個操作形如 $(l, r, x)$，表示要將編號介在 $[l, r]$ 之間且與 $x$ 互質的格子塗上顏色，問你最後未被塗色的格子有幾個。\n限制 $1 \\leq n \\leq 10^9$\n$1 \\leq m \\leq 1000$\n$1 \\leq l \\leq r \\leq n$\n$1 \\leq x \\leq 100$\nsubtask 1 (17) $n, m \\leq 1000$\nsubtask 2 (29) $1 \\leq x \\leq 20$\nsubtask 3 (28) 所有操作的 $[l, r]$ 並無任何交集\nsubtask 4 (26) 無額外限制\n作法  第一個 subtask 屬於比較簡單的分數。 第三個 subtask 可以直接排容。想算 $[l, r]$ 內跟 $x$ 有共同質因數的數字個數可以用前綴和相減，但是給定 $L,x$ 要怎麼算 $\\leq L$ 且跟 $x$ 不互質的數字個數呢？舉例來說，假設 $x = 30$，那麼答案就是 「所有 2 的倍數」+「所有 3 的倍數」+「所有 5 的倍數」-「所有 6 的倍數」-「所有 10 的倍數」-「所有 15 的倍數」+「所有 30 的倍數」。可以推出式子長得像 $\\sum_{d|x} \\left \\lfloor \\frac{L}{d} \\right \\rfloor \\cdot (-\\mu(d))$。 接著直接講 AY 教我的滿分解。首先可以把 $[1,n]$ 分成 $\\mathcal{O}(m)$ 個區間，對於每個 $[l,r]$ 有一個集合 $X$ ，想計算有多少正整數 $y$ 使得 $l \\leq y \\leq r$ 且 $\\forall x \\in X, \\gcd(y,x) \\neq 1$。考慮枚舉根號以下的質數是否是 $y$ 的因數，也就是 $2,3,5,7$。一個數字大於等於根號的質因數至多只有一個，因此如果 $x$ 不包含任何我們想讓 $y$ 包含的小質因數，那麼他的大質因數（可能不存在）$y$ 就必須擁有。對於一種枚舉，可以知道說 $y$ 必須跟哪些小質數互質、必須跟哪些質數不互質，而最後方法數可以透過排容計算。\n如果 $y$ 必須 $\\leq L$ 、跟集合 $S$ 內的小質數互質、並且是集合 $P$ 內的質數的倍數，那麼這樣的 $y$ 的種類大概是  $$\n\\sum _ {T \\subseteq S} (-1) ^ {|T|} \\left \\lfloor \\frac{L}{(\\prod _ {p\\in P} p)(\\prod _ {t\\in T} t)} \\right \\rfloor\n$$\n這樣計算的複雜度大概是 $\\mathcal{O}(c \\times 3^s \\times m)$，其中 $c$ 是值域而 $s$ 是值域的根號以下的質數數量（這題範圍是 4）\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141  // #define _GLIBCXX_DEBUG #pragma GCC optimize(\u0026#34;Ofast\u0026#34;) #include \u0026lt;bits/stdc++.h\u0026gt;#ifdef local #define safe cerr\u0026lt;\u0026lt;__PRETTY_FUNCTION__\u0026lt;\u0026lt;\u0026#34; line \u0026#34;\u0026lt;\u0026lt;__LINE__\u0026lt;\u0026lt;\u0026#34; safe\\n\u0026#34; #define pary(a...) danb(#a, a) #define debug(a...) qqbx(#a, a) template \u0026lt;typename ...T\u0026gt; void qqbx(const char *s, T ...a) { int cnt = sizeof...(T); ((std::cerr \u0026lt;\u0026lt; \u0026#34;\\033[1;32m(\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;) = (\u0026#34;) , ... , (std::cerr \u0026lt;\u0026lt; a \u0026lt;\u0026lt; (--cnt ? \u0026#34;, \u0026#34; : \u0026#34;)\\033[0m\\n\u0026#34;))); } template \u0026lt;typename T\u0026gt; void danb(const char *s, T L, T R) { std::cerr \u0026lt;\u0026lt; \u0026#34;\\033[1;32m[ \u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34; ] = [ \u0026#34;; for (int f = 0; L != R; ++L) std::cerr \u0026lt;\u0026lt; (f++ ? \u0026#34;, \u0026#34; : \u0026#34;\u0026#34;) \u0026lt;\u0026lt; *L; std::cerr \u0026lt;\u0026lt; \u0026#34; ]\\033[0m\\n\u0026#34;; } #else #define debug(...) ((void)0) #define safe ((void)0) #define pary(...) ((void)0) #endif // local #define all(v) begin(v),end(v) #define pb emplace_back  using namespace std; using ll = int64_t; template \u0026lt;typename T\u0026gt; using max_heap = priority_queue\u0026lt;T, vector\u0026lt;T\u0026gt;, less\u0026lt;T\u0026gt;\u0026gt;; const int maxn = 100025; const long long inf = 1000000001; const int prs[4] = {2, 3, 5, 7}; int bp[1 \u0026lt;\u0026lt; 4]; int square_free(int x) { for (int p: prs) while (x % (p*p) == 0) x /= p; return x; } int mul(int a, int b) { return min(inf, 1LL*a*b); } int cnt[101]; int calc(int L) { vector\u0026lt;int\u0026gt; has; for (int j = 1; j \u0026lt;= 100; j++) if (cnt[j]) has.push_back(j); int ans = 0; for (int s = 0, U = (1\u0026lt;\u0026lt;4)-1; s \u0026lt; (1\u0026lt;\u0026lt;4); s++) { bool fail = false; int prod = 1; bool inProd[100] = {}; for (int j: has) { bool coprime = (__gcd(j, bp[U ^ s]) == 1); if (coprime) { int bigPart = j / __gcd(j, 2 * 3 * 5 * 7); if (bigPart == 1) { prod = inf; break; } else { if (!inProd[bigPart]) prod = mul(prod, bigPart); inProd[bigPart] = true; } } } int M = L / bp[U ^ s] / prod; if (M == 0) continue; for (int m = s; ; m = (m-1) \u0026amp; s) { int coef = __builtin_parity(m) ? -1 : 1; ans += coef * (M / bp[m]); if (!m) break; } } #ifdef local  int c = 0; for (int i = 1; i \u0026lt;= L; i++) { bool ok = true; for (int j: has) if (__gcd(j, i) == 1) ok = false; if (ok) ++c; } pary(all(has)); debug(ans, L, c); #endif // local  return ans; } signed main() { for (int s = 0; s \u0026lt; (1\u0026lt;\u0026lt;4); s++) { bp[s] = 1; for (int i = 0; i \u0026lt; 4; i++) if (s \u0026gt;\u0026gt; i \u0026amp; 1) bp[s] *= prs[i]; } ios_base::sync_with_stdio(0), cin.tie(0); int n, m; assert( cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m ); vector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; evt; for (int i = 0; i \u0026lt; m; i++) { int l, r, x; assert( cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r \u0026gt;\u0026gt; x ); assert( 1 \u0026lt;= l \u0026amp;\u0026amp; l \u0026lt;= r \u0026amp;\u0026amp; r \u0026lt;= n ); assert( 1 \u0026lt;= x \u0026amp;\u0026amp; x \u0026lt;= 100 ); x = square_free(x); --l; evt.emplace_back(l, x); evt.emplace_back(r, -x); } evt.emplace_back(0, 0); evt.emplace_back(n, 0); sort(all(evt)); int ans = 0; for (int i = 0, j = 0; i \u0026lt; evt.size(); i = j) { for (j = i; j \u0026lt; evt.size(); j++) { if (evt[j].first != evt[i].first) break; int x = evt[j].second; if (x \u0026gt; 0) { ++cnt[x]; } else if (x \u0026lt; 0) { --cnt[-x]; } } if (j == evt.size()) continue; int l = evt[i].first; int r = evt[j].first; int cur = calc(r) - calc(l); ans += cur; debug(l, r, cur); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } /* 15 2 1 15 3 1 15 15 10000 2 1 10000 22 1 10000 33 */   p3 pairing 題意 給定一個序列 $a_1, a_2, \u0026hellip;, a_n$，現在要從 ${1, 2, \\dots n}$ 中選一些點配對，並且獲得最高的總分。\n一個點只能被匹配最多一次，當兩個點 $i$ 與 $j$ 配對時（$i \u0026lt; j$），就會獲得 $a_i + a_{i+1} + \\cdots + a_j$ 的分數。\n此外，任何配對都不能出現部份相交的情形，也就是說，對於任兩個配對 $i \u0026lt; j$ 與 $k \u0026lt; l$，不能出現 $i \u0026lt; k \u0026lt; j \u0026lt; l$ 的情形。\n匹配結束後，所有沒有被匹配到的點 $i$ ，如果 $a_i \u0026gt; 0$，可以獲得額外的 $a_i$ 分。\n最終得分就是所有選中的配對獲得的分數，與上述的額外分數的總和。\n請找出最終得分最大是多少。\n限制 $1 \\leq n \\leq 10^5$\n$-10^9 \\leq a_i \\leq 10^9$\nsubtask 1 (9) $1 \\leq n \\leq 20$\nsubtask 2 (16) $1 \\leq n \\leq 500$\nsubtask 3 (33) $1 \\leq n \\leq 3000$\nsubtask 4 (42) 無額外限制\n作法 首先要注意題意的理解，因為範測實在蠻爛的。\n原本筆者以為兩個配對的點中間不能再有其他配對的點，像是AI666那樣，但其實不是，題目的意思是兩組配對不能「交叉」，但可以完全包含在另一個配對中間，例如$a = [1,2,3,4]$的話，我們可以把1跟4配、2跟3配來得到15分。\n  subtask 2, 3\n理解了正確的題意之後會發現這跟括弧匹配有點像，可以嘗試dp。應該有蠻多種方式去dp的，這裡列出$\\mathcal{O}(n^3)$和$\\mathcal{O}(n^2)$各一種。\n $\\mathcal{O}(n^3)$ $sum_{l,r}$是$[l,r]$區間的和。\n$$dp_{l,r}=\\max(dp_{l+1,r-1}+sum_{l,r},dp_{l+1,r}+a_l,dp_{l,r-1}+a_r,\\max\\limits_{l\\leq m \u0026lt; r}(dp_{l,m}+dp_{m+1,r}))$$ $\\mathcal{O}(n^2)$ $pre_i$是前綴和\n$dp_{i,b}$表示前綴$i$、左括弧比右括弧多$b$個\n$$\ndp_{i,b}=\\max(dp_{i-1,b}+\\max(a_i,0), dp_{i-1,b-1}-pre_{i-1},dp_{i-1,b+1}+pre_i)\n$$    滿分解\n如果對括弧匹配再仔細想的話，可以發現這題可以歸約成這題。\n對於每個點，我可以計算他當左括弧的收益$-pre_{i-1}-\\max(a_i,0)$、他當右括弧的收益$pre_i-\\max(a_i,0)$（最後的額外加分用扣的算），而都不當的代價當成0，接著我們從左到右依序決定每個點應該當左括弧、右括弧還是都不當。我們維護兩個heap，一個放前面未配對的點，key是他變成左括弧增加的價值；一個放前面已經當右括弧的點，key是他變成未配對的點損失的價值，那每次遇到一個點就會先看他當右括弧的價值，左括弧跟他配的可能有兩種情況：\n 前面還沒有配對的點，會貪心的選價值最大的 拆開前面某對配對，等於跟前面的右括弧替換，會貪心的選替換之後損失最少  兩種情況可以選價值比較大的那個，假如配起來的總價值是正的那我們就把他改成右括弧，否則就把他先當作未配對的點變成潛力左括弧，兩種情況都需要好好更新heap。如果再想細一點其實這兩個heap可以併在一起XD說明就略過了。\n這個技巧被ZCK稱為可undo greedy，因為我們可以很輕鬆的把已經選的配對點拆開或是計算拆開之後減少的價值，所以就可以維護heap來決定要do誰跟undo誰。\n  code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  #pragma GCC optimize(\u0026#34;Ofast\u0026#34;) #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 100025; template \u0026lt;typename T\u0026gt; using max_heap = priority_queue\u0026lt;T, vector\u0026lt;T\u0026gt;, less\u0026lt;T\u0026gt;\u0026gt;; int a[maxn]; long long pre[maxn]; signed main() { int n; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; for (int i = 1; i \u0026lt;= n; i++) pre[i] = pre[i-1] + a[i]; max_heap\u0026lt;long long\u0026gt; pq; long long ans = 0; for (int i = 1; i \u0026lt;= n; i++) ans += max(a[i], 0); for (int i = 1; i \u0026lt;= n; i++) { long long lbraceValue = -pre[i-1] - max(a[i], 0); long long rbraceValue = pre[i] - max(a[i], 0); if (!pq.empty() \u0026amp;\u0026amp; rbraceValue + pq.top() \u0026gt; 0) { ans += rbraceValue + pq.top(), pq.pop(); pq.push(lbraceValue); pq.push(-rbraceValue); } else { pq.push(lbraceValue); } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }   p4 tangent 題意 記憶體限制為 128 MB\n二維平面上有 $n$ 個點 $(x, y)$，有 $m$ 條線段分別從上方無窮遠處落下，要對每個線段輸出最先碰到的點是誰，如果沒有碰到任何點要輸出 $-1$，如果有多個最先碰到的點請輸出 $x$ 座標最小的。\n線段在下落的過程中保持斜率不變，故每個線段可以用三個參數 $(a, w, h)$ 描述，\n表示若在下落的過程中，左端點和右端點的座標分別是 $(x_l, y_l), (x_r, y_r)$，\n則 $x_l = a，x_r - x_l = w, y_r - y_l = h$。\n限制 $1 \\leq n \\leq 5 \\times 10^5$\n$1 \\leq m \\leq 10^5$\n$-10^9 \\leq x, y \\leq 10^9$\n所有點皆相異\n$-10^9 \\leq a \\leq 10^9$\n$0 \\leq w \\leq 2 \\times 10^9; -10^9 \\leq h \\leq 10^9; (w, h) \\neq (0, 0)$\nsubtask 1 (19) $n, m \\leq 1000$\nsubtask 2 (30) $n, m \\leq 10^5$\nsubtask 3 (51) 無額外限制\n作法 這題的 subtask 切的蠻爛的@@\n注意鉛直線的case最好小心處理，此外賽中subtask 1的測資沒有強到會驗出鉛直線的問題，許多人被這件事影響。\n假設這題不是詢問線段而是詢問直線的話，那麼我們可以維護點的上凸包，每次詢問一條直線就相當於詢問凸包在某個方向的極點（extreme point），而這可以用三分搜解決，或是對詢問依照斜率排序之後用類似單調stack的方式解決。\n現在詢問並不是一整條直線，而是 $x$ 座標的一段區間，要怎麼處理區間詢問呢？答案就是開線段樹，每個節點存包含對應區間的所有點形成的上凸包，就能只詢問 $x$ 座標介於一段區間的點了。空間複雜度大概是 $\\mathcal{O}(n\\log n)$ ，本題範圍差不多是可以開下 $3 \\times 10^7$ 個 int，而 $n\\log n$大約是 $10^7$，所以要小心常數不要太多倍，線段樹裡面可能只能存點的編號。時間複雜度可以是 $\\mathcal{O}(n\\log n + m\\log^2n)$ 或是\n$\\mathcal{O}(n\\log n + m(\\log m + \\log n))$，依照實做方式而定。\n當然，如果想要空間 $\\mathcal{O}(N)$ 的話，也可以用分塊在時間 $\\mathcal{\\tilde O}(N+M\\sqrt{N})$ 解決本題，或是離線之後讓線段樹每一層分開處理，因為一層只需要 $\\mathcal{O}(N)$ 的空間。\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134  // #define _GLIBCXX_DEBUG #pragma GCC optimize(\u0026#34;Ofast\u0026#34;) #include \u0026lt;bits/stdc++.h\u0026gt;#ifdef local #define safe cerr\u0026lt;\u0026lt;__PRETTY_FUNCTION__\u0026lt;\u0026lt;\u0026#34; line \u0026#34;\u0026lt;\u0026lt;__LINE__\u0026lt;\u0026lt;\u0026#34; safe\\n\u0026#34; #define pary(a...) danb(#a, a) #define debug(a...) qqbx(#a, a) template \u0026lt;typename ...T\u0026gt; void qqbx(const char *s, T ...a) { int cnt = sizeof...(T); ((std::cerr \u0026lt;\u0026lt; \u0026#34;\\033[1;32m(\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;) = (\u0026#34;) , ... , (std::cerr \u0026lt;\u0026lt; a \u0026lt;\u0026lt; (--cnt ? \u0026#34;, \u0026#34; : \u0026#34;)\\033[0m\\n\u0026#34;))); } template \u0026lt;typename T\u0026gt; void danb(const char *s, T L, T R) { std::cerr \u0026lt;\u0026lt; \u0026#34;\\033[1;32m[ \u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34; ] = [ \u0026#34;; for (int f = 0; L != R; ++L) std::cerr \u0026lt;\u0026lt; (f++ ? \u0026#34;, \u0026#34; : \u0026#34;\u0026#34;) \u0026lt;\u0026lt; *L; std::cerr \u0026lt;\u0026lt; \u0026#34; ]\\033[0m\\n\u0026#34;; } #else #define debug(...) ((void)0) #define safe ((void)0) #define pary(...) ((void)0) #endif // local #define all(v) begin(v),end(v) #define pb emplace_back  using namespace std; using ll = int64_t; template \u0026lt;typename T\u0026gt; using max_heap = priority_queue\u0026lt;T, vector\u0026lt;T\u0026gt;, less\u0026lt;T\u0026gt;\u0026gt;; const int maxn = 500025, maxq = 100025; const ll INF = 3e18; struct Point { int x, y, id; } p[maxn]; int u[maxn]; void buildConvexHull(vector\u0026lt;int\u0026gt; \u0026amp;v) { static const auto check = [](int a, int b, int c) { ll x1 = p[b].x - p[a].x, y1 = p[b].y - p[a].y; ll x2 = p[c].x - p[b].x, y2 = p[c].y - p[b].y; return x1 * y2 - x2 * y1 \u0026gt;= 0; }; size_t j = 0; for (size_t i = 0; i \u0026lt; v.size(); i++) { while (j \u0026gt;= 2 \u0026amp;\u0026amp; check(v[j-2], v[j-1], v[i])) --j; v[j++] = v[i]; } v.resize(j); } tuple\u0026lt;ll,int,int\u0026gt; queryConvexHull(vector\u0026lt;int\u0026gt; \u0026amp;v, int w, int h) { tuple\u0026lt;ll,int,int\u0026gt; ans(-INF, 0, -1); if (v.empty()) return ans; auto f = [\u0026amp;](int i) { auto [x, y, id] = p[i]; return tuple\u0026lt;ll,int,int\u0026gt;(1LL * w * y - 1LL * h * x, x, id); }; while (v.size() \u0026gt;= 2 \u0026amp;\u0026amp; f(v.rbegin()[0]) \u0026lt;= f(v.rbegin()[1])) v.pop_back(); return f(v.back()); } struct Segtree { int n; vector\u0026lt;int\u0026gt; st[maxn * 2]; void build(int _n) { n = _n; for (int i = 0; i \u0026lt; n; i++) st[i+n].push_back(i); for (int i = n-1; i \u0026gt; 0; i--) { st[i].resize(st[i\u0026lt;\u0026lt;1].size() + st[i\u0026lt;\u0026lt;1|1].size()); merge(all(st[i\u0026lt;\u0026lt;1]), all(st[i\u0026lt;\u0026lt;1|1]), st[i].begin(), [](int a, int b){ return a \u0026lt; b; }); buildConvexHull(st[i]); } } int query(int l, int r, int w, int h) { tuple\u0026lt;ll,int,int\u0026gt; res(-INF, 0, -1); for (l += n, r += n; l \u0026lt; r; l \u0026gt;\u0026gt;= 1, r \u0026gt;\u0026gt;= 1) { if (l \u0026amp; 1) res = max(res, queryConvexHull(st[l++], w, h)); if (r \u0026amp; 1) res = max(res, queryConvexHull(st[--r], w, h)); } return get\u0026lt;2\u0026gt;(res); } } sgt; struct Query { int l, r, w, h; int qid; } qs[maxq]; int ans[maxq]; signed main() { ios_base::sync_with_stdio(0), cin.tie(0); int n; cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; p[i].x \u0026gt;\u0026gt; p[i].y, p[i].id = i+1; sort(p, p+n, [](Point a, Point b){ return a.x \u0026lt; b.x; }); { int j = 0; for (int i = 0; i \u0026lt; n; i++) { if (!i || p[i].x != p[i-1].x) { p[j++] = p[i]; } else if (p[j-1].y \u0026lt; p[i].y) { p[j-1] = p[i]; } } n = j; } for (int i = 0; i \u0026lt; n; i++) u[i] = p[i].x; sgt.build(n); int q; cin \u0026gt;\u0026gt; q; for (int i = 0; i \u0026lt; q; i++) { int a, w, h; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; w \u0026gt;\u0026gt; h; int l = lower_bound(u, u+n, a) - u; int r = lower_bound(u, u+n, a+w+1) - u; qs[i] = { l, r, w, h, i }; } sort(qs, qs+q, [](Query a, Query b) { return 1LL * a.w * b.h \u0026gt; 1LL * a.h * b.w; }); for (int i = 0; i \u0026lt; q; i++) { auto [l, r, w, h, qid] = qs[i]; ans[qid] = sgt.query(l, r, w, h); } for (int i = 0; i \u0026lt; q; i++) cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }   三模 p1 flower 題意 有排成一列的 $n$ 朵花，品種分別是 $F_1, F_2, \u0026hellip; F_n$\n要你選出 $k$ 朵品種不同的花，並且他們的位置也都不相鄰，請由小到大輸出選的花的位置。\n若有多組解請輸出字典序最小的解，無解則輸出 $0$。\n限制 一組輸入檔案有 $T$ 筆測試資料\n$T \\leq 5$ （賽中 clarification）\n$1 \\leq n \\leq 10 ^ 6$\n$1 \\leq k \\leq \\min(22, n)$\n$1 \\leq F_i \\leq n$\nsubtask 1 (16) $1 \\leq k \\leq n \\leq 18$\nsubtask 2 (41) $1 \\leq n \\leq 100; 1 \\leq k \\leq 20; k \\leq n$\nsubtask 3 (43) 無額外限制\n作法 直接講滿分解。\n考慮最左邊的花，也就是 $F_1$，\n如果不選 $F_1$ 的話，最佳解一定包含 $F_2$ 這朵花，不論 $F_2$ 和 $F_1$ 是否相同（兩者都不選的話可以把最後一朵或是同樣顏色的換成最前面這朵）\n更一般地，假設目前已經選了一些花，那麼把不能選的花去除之後，最前面的那朵花和他的下一朵一定恰好會選一朵，因此這樣遞迴下去時間複雜度會類似 $T(k) = T(k-1) + T(k-1) + \\mathcal{O}(f(n, k))$ 之類的，其中 $f(n, k)$ 是快速維護「選了一個花之後剩下來最前面可以拿的花是誰」的複雜度，只要好好寫的話都可以通過本題，一種方法是只維護最先出現的 $2k$ 種顏色目前還沒被佔據的位置最前面是誰，總複雜度 $\\mathcal{O}(n + k2^k)$。\nsubtask 1 是直接枚舉\nsubtask 2 應該是給糟糕的 $f(n, k)$。\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143  // An AC a day keeps the doctor away. #pragma GCC optimize(\u0026#34;Ofast\u0026#34;) #include \u0026lt;bits/stdc++.h\u0026gt;#ifdef local #define safe std::cerr\u0026lt;\u0026lt;__PRETTY_FUNCTION__\u0026lt;\u0026lt;\u0026#34; line \u0026#34;\u0026lt;\u0026lt;__LINE__\u0026lt;\u0026lt;\u0026#34; safe\\n\u0026#34; #define debug(args...) qqbx(#args, args) #define orange(args...) danb(#args, args) using std::cerr; template \u0026lt;typename ...T\u0026gt; void qqbx(const char *s, T ...args) { int cnt = sizeof...(T); ((cerr \u0026lt;\u0026lt; \u0026#34;\\e[1;32m(\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;) = (\u0026#34;), ..., (cerr \u0026lt;\u0026lt; args \u0026lt;\u0026lt; (--cnt ? \u0026#34;, \u0026#34; : \u0026#34;)\\e[0m\\n\u0026#34;))); } template \u0026lt;typename T\u0026gt; void danb(const char *s, T L, T R) { cerr \u0026lt;\u0026lt; \u0026#34;\\e[1;32m[ \u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34; ] = [ \u0026#34;; for (int f = 0; L != R; ++L) cerr \u0026lt;\u0026lt; (f++ ? \u0026#34;, \u0026#34; : \u0026#34;\u0026#34;) \u0026lt;\u0026lt; *L; cerr \u0026lt;\u0026lt; \u0026#34; ]\\e[0m\\n\u0026#34;; } #else #define safe ((void)0) #define debug(...) ((void)0) #define orange(...) ((void)0) #endif // local #define all(v) begin(v),end(v)  using namespace std; using ll = long long; const int maxn = 1000025; int color[maxn]; int nxt[maxn]; bool usedColor[50]; int curPos[50]; vector\u0026lt;int\u0026gt; ans; int dfs_call; bool dfs(int cs, int k) { ++dfs_call; if (k == 0) return true; int pos1 = maxn-1; for (int j = 0; j \u0026lt; cs; j++) { if (!usedColor[j]) { pos1 = min(pos1, curPos[j]); } } if (pos1 == maxn-1) return false; int color1 = color[pos1]; usedColor[color1] = true; int color2 = -1, color3 = -1; int pos2 = -1, pos3 = -1; for (int j = 0; j \u0026lt; cs; j++) if (!usedColor[j] \u0026amp;\u0026amp; curPos[j] == pos1 + 1) { assert (color2 == -1); color2 = j; pos2 = curPos[color2]; } if (color2 != -1) { curPos[color2] = nxt[curPos[color2]]; } if (dfs(cs, k-1)) { ans.push_back(pos1); return true; } if (color2 != -1) { curPos[color2] = pos2; } usedColor[color1] = false; if (color2 == -1) return false; usedColor[color2] = true; assert (color1 != color2 \u0026amp;\u0026amp; color2 != color3); // maybe color1 == color3  { curPos[color1] = nxt[curPos[color1]]; } for (int j = 0; j \u0026lt; cs; j++) if (!usedColor[j] \u0026amp;\u0026amp; curPos[j] == pos2 + 1) { assert (color3 == -1); color3 = j; pos3 = curPos[j]; } if (color3 != -1) { curPos[color3] = nxt[curPos[color3]]; } if (dfs(cs, k-1)) { ans.push_back(pos2); return true; } if (color3 != -1) { curPos[color3] = pos3; } { curPos[color1] = pos1; } usedColor[color2] = false; return false; } int mp[maxn]; void solve() { int n, k; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; int tot = 0; for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; color[i]; for (int i = 1; i \u0026lt;= n; i++) mp[i] = -7122; for (int i = 0; i \u0026lt; n; i++) { if (tot \u0026lt; k * 2 \u0026amp;\u0026amp; mp[color[i]] == -7122) { mp[color[i]] = tot++; } } for (int j = 0; j \u0026lt; tot; j++) curPos[j] = maxn-1, usedColor[j] = false; nxt[maxn-1] = maxn-1; for (int i = n-1; i \u0026gt;= 0; i--) { if (mp[color[i]] \u0026gt;= 0) { int id = mp[color[i]]; nxt[i] = curPos[id]; curPos[id] = i; color[i] = id; } else { color[i] = -7122222; } } ans.clear(); if (dfs(tot, k)) { reverse(all(ans)); for (int i = 0; i \u0026lt; k; i++) cout \u0026lt;\u0026lt; ans[i]+1 \u0026lt;\u0026lt; (i+1==k ? \u0026#39;\\n\u0026#39; : \u0026#39; \u0026#39;); } else { cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } signed main() { ios_base::sync_with_stdio(0), cin.tie(0); int T; cin \u0026gt;\u0026gt; T; while (T--) solve(); debug(dfs_call); }   p2 neko_atsume 題意 給定一棵 $n$ 點的樹，邊有邊權，並且有 m 個節點上有會參加宴會的貓咪 $x_1, x_2, \u0026hellip; x_m$。巧克力想要選一個節點舉辦宴會，使得「要參加宴會的貓咪與宴會地點的距離中最遠的」越短越好，請回答在選擇最好的節點的情況下這個距離是多少。\n此外還會有 $d$ 個修改 $p_i$，若 $p_i \u0026gt; 0$ 表示 $p_i$ 這個節點的貓咪可以前來宴會，若 $p_i \u0026lt; 0$ 表示 $|p_i|$ 這個節點的貓咪無法前來宴會，請在每次修改之後輸出前述的距離。\n當沒有貓咪參加宴會時請輸出 $0$。\n限制 $2 \\leq n \\leq 10^5$\n$0 \\leq m \\leq n$\n$1 \\leq x_i \\leq n$\n$0 \\leq d \\leq 2 \\times 10^5$\n$-n \\leq p_i \\leq n; p_i \\neq 0$\n樹的邊權介在 $[1, 1000]$ 之間\n保證 $p_i \u0026gt; 0$ 時，原本該節點的貓咪無法參加宴會，\n而 $p_i \u0026lt; 0$ 時原本該節點的貓咪可以參加宴會\nsubtask 1 (7) $n \\leq 100; d \\leq 100$\nsubtask 2 (12) 任意時間點參加的人數只有 $2$ 人（註：是 $\\leq 2$ 人）\nsubtask 3 (22) 每個時間點參加宴會的人數總和 $\\leq 4 \\times 10^6$\nsubtask 4 (24) $p_i \u0026gt; 0$\nsubtask 5 (35) 無額外限制\n作法  subtask 1 是水分。 subtask 2 是一個提示。可以二分搜說兩點中間距離「兩點距離 / 2」最近的點距離是多少，可能會用到跟 LCA 有關的資料結構。 接著講筆者在賽中想到的滿分解。考慮要參加的貓咪的那些頂點形成的虛樹（對於一個頂點集合 $V$ 來說，一條邊被包含在虛樹裡面若且唯若原本的樹拔掉這條邊之後會使得 $V$ 變成兩個連通塊），可以知道要舉辦宴會的那個點一定處在直徑這條路徑上，因此我們只要動態維護任意一條直徑的兩個端點之後，再用 subtask 2 的方法就可以 AC 了。 要如何動態維護直徑呢？考慮 subtask 4 ，如果只一直加入點的話，可以知道如果直徑變了，新的直徑一定是新加入的點跟原本其中一條直徑的一個端點構成的，因此可以透過查 $\\mathcal{O}(1)$ 次距離來動態維護直徑，再搭配時間線段樹的技巧就可以 AC 整題了。如果用 $\\mathcal{O}(1)$ 的 LCA （像是 ladder 或是 sparse table）的話，時間複雜度會是 $\\mathcal{O}(n\\log n + m\\log m + m\\log n)$。  答案會在直徑上的證明：\n首先假設有一條直徑的兩個端點分別是 $A,B$，那麼對於任何頂點 $P$ 來說，$A$ 或是 $B$ 至少其中之一會是距離他最遠的頂點（可能有其他頂點距離一樣遠），否則假設 $Q$ 是其中一個距離 $P$ 最遠的頂點，那麼\n$$\ndis(P, Q) \u0026gt; \\max(dis(P, B), dis(P, A))\n$$\n又 $AB$ 是直徑，所以\n$$\ndis(A,B) \\geq \\max(dis(A, Q), dis(B, Q))\n$$\n考慮下圖的兩種 case 都會產生矛盾，所以對於所有頂點 $P$ 來說，\n$\\max_{Q \\in V} dis(P, Q) = \\max(dis(P, A), dis(P, B))$。\n接著如果 $P$ 不在 $AB$ 路徑上的話，令 $AB$ 路徑上離 $P$ 最近的點 $P'$，$P'$ 的答案一定比 $P$ 更好，所以 $P$ 一定在 $AB$ 路徑上，而且距離 $P$ 最遠的點只需要考慮 $A,B$ 兩個點就好了。\n順帶一提筆者是用這題的技巧動態維護樹直徑的，現在看起來超級中毒XD\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153  // An AC a day keeps the doctor away. #pragma GCC optimize(\u0026#34;Ofast\u0026#34;) #include \u0026lt;bits/stdc++.h\u0026gt;#ifdef local #define safe std::cerr\u0026lt;\u0026lt;__PRETTY_FUNCTION__\u0026lt;\u0026lt;\u0026#34; line \u0026#34;\u0026lt;\u0026lt;__LINE__\u0026lt;\u0026lt;\u0026#34; safe\\n\u0026#34; #define debug(args...) qqbx(#args, args) #define orange(args...) danb(#args, args) using std::cerr; template \u0026lt;typename ...T\u0026gt; void qqbx(const char *s, T ...args) { int cnt = sizeof...(T); ((cerr \u0026lt;\u0026lt; \u0026#34;\\e[1;32m(\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;) = (\u0026#34;), ..., (cerr \u0026lt;\u0026lt; args \u0026lt;\u0026lt; (--cnt ? \u0026#34;, \u0026#34; : \u0026#34;)\\e[0m\\n\u0026#34;))); } template \u0026lt;typename T\u0026gt; void danb(const char *s, T L, T R) { cerr \u0026lt;\u0026lt; \u0026#34;\\e[1;32m[ \u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34; ] = [ \u0026#34;; for (int f = 0; L != R; ++L) cerr \u0026lt;\u0026lt; (f++ ? \u0026#34;, \u0026#34; : \u0026#34;\u0026#34;) \u0026lt;\u0026lt; *L; cerr \u0026lt;\u0026lt; \u0026#34; ]\\e[0m\\n\u0026#34;; } #else #define safe ((void)0) #define debug(...) ((void)0) #define orange(...) ((void)0) #endif // local #define all(v) begin(v),end(v)  using namespace std; using ll = long long; const int maxn = 100025; const int maxq = 200025; vector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; g[maxn]; int wsum[maxn], pa[20][maxn], dep[maxn]; void dfs(int i, int f) { for (int L = 1; L \u0026lt; 20; L++) pa[L][i] = pa[L-1][pa[L-1][i]]; for (auto [w, j]: g[i]) { if (j == f) continue; dep[j] = dep[i] + 1; wsum[j] = wsum[i] + w; pa[0][j] = i; dfs(j, i); } } int lca(int a, int b) { if (dep[a] \u0026gt; dep[b]) swap(a, b); int d = dep[b] - dep[a]; for (int i = 0; i \u0026lt; 20; i++) if (d \u0026gt;\u0026gt; i \u0026amp; 1) b = pa[i][b]; if (a == b) return a; for (int i = 19; i \u0026gt;= 0; i--) if (pa[i][a] != pa[i][b]) a = pa[i][a], b = pa[i][b]; return pa[0][a]; } int dis(int a, int b) { return wsum[a] + wsum[b] - 2 * wsum[lca(a, b)]; } int solveTwoPoints(int a, int b, int d) { if (a == -1 || b == -1) return 0; int c = lca(a, b); if (wsum[a] - wsum[c] \u0026lt;= d / 2) swap(a, b); assert (wsum[a] - wsum[c] \u0026gt;= (d + 1) / 2); int x = a; for (int i = 19; i \u0026gt;= 0; i--) if (dep[x] - dep[c] \u0026gt;= (1 \u0026lt;\u0026lt; i) \u0026amp;\u0026amp; wsum[a] - wsum[pa[i][x]] \u0026lt;= d / 2) x = pa[i][x]; int ans = max(dis(a, x), dis(b, x)); if (x != c) ans = min(ans, max(dis(a, pa[0][x]), dis(b, pa[0][x]))); return ans; } struct Diameter { int a, b; int d; Diameter() : a(-1), b(-1), d(0) {} bool add(int x) { if (a == -1) return a = x, true; if (b == -1) return b = x, d = dis(a, b), true; if (int nd = dis(a, x); nd \u0026gt; d) return b = x, d = nd, true; if (int nd = dis(b, x); nd \u0026gt; d) return a = x, d = nd, true; return false; } }; struct Segtree { vector\u0026lt;int\u0026gt; event[maxq * 2]; int n; int ans[maxq]; void add(int l, int r, int e) { for (l += n, r += n; l \u0026lt; r; l \u0026gt;\u0026gt;= 1, r \u0026gt;\u0026gt;= 1) { if (l \u0026amp; 1) event[l++].push_back(e); if (r \u0026amp; 1) event[--r].push_back(e); } } void dfs(int i, Diameter d) { for (int x: event[i]) d.add(x); if (i \u0026lt; n) { dfs(i \u0026lt;\u0026lt; 1, d); dfs(i \u0026lt;\u0026lt; 1 | 1, d); } else { ans[i - n] = solveTwoPoints(d.a, d.b, d.d); } } } sgt; signed main() { ios_base::sync_with_stdio(0), cin.tie(0); int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt; n; i++) { int a, b, w; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; w; g[a].emplace_back(w, b); g[b].emplace_back(w, a); } dfs(1, 0); map\u0026lt;int,int\u0026gt; mp; for (int i = 0; i \u0026lt; m; i++) { int x; cin \u0026gt;\u0026gt; x; mp[x] = 0; } int q; cin \u0026gt;\u0026gt; q; sgt.n = q + 1; for (int i = 1; i \u0026lt;= q; i++) { int p; cin \u0026gt;\u0026gt; p; assert (p != 0); if (p \u0026gt; 0) { assert (!mp.count(p)); mp[p] = i; } else { assert (mp.count(p)); p = -p; sgt.add(mp[p], i, p); mp.erase(p); } } for (auto [p, t]: mp) sgt.add(t, q+1, p); sgt.dfs(1, Diameter()); for (int i = 0; i \u0026lt;= q; i++) cout \u0026lt;\u0026lt; sgt.ans[i] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }   p3 production 題意 給定一張 $n$ 點 $m$ 邊的有向圖，從頂點 $1$ 開始走，每個點有一個等待時間 $t_i$ ，到達一個頂點並等待完之後將會從該頂點的出邊中選一條走，而走每一條出邊的機率皆有給定（選擇某條出邊的機率是「該邊邊權 / 所有出邊的邊權」）。\n另外有 $k$ 個加速器，在頂點 $i$ 使用 $x$ 個加速器可以讓等待時間變成 $t_i / (1 + x)$，\n假設走邊的時間不計，你想求「從頂點 $1$ 開始走，走到沒有出邊的點所花的時間期望值」經過加裝一些加速器後最少是多少。\n限制 $1 \\leq n \\leq 10 ^ 5$\n$1 \\leq m \\leq 2 \\times 10 ^ 5$\n$1 \\leq k \\leq 10 ^ 5$\n$1 \\leq t_i \\leq 10 ^ 9$\n$1 \\leq $ 邊權 $ \\leq 10 ^ 6$\n保證可以從頂點 $1$ 抵達任何頂點、保證任何頂點都可以抵達其中一個終點\n輸出浮點數與正確答案相對誤差 $\\leq 10^{-6}$ 的答案視為正確\nsubtask 1 (9) $n \\leq 100; m = n-1; k \\leq 1000$\nsubtask 2 (49) $m = n-1$\nsubtask 3 (23) 保證圖是 DAG\nsubtask 4 (19) $n \\leq 100$\n作法 先考慮沒有加裝任何加速器的時候期望值是怎麼算的。\n定義 $X_i$ 是一個隨機變數代表「從頂點 $1$ 開始走，走到終點為止經過頂點 $i$ 的次數」\n那麼花費的總時間就是 $\\sum t_i X_i$，期望值 $E(\\sum t_i X_i) = \\sum E(t_i X_i) = \\sum t_i E(X_i)$，因為期望值可以拆開來，不管 $X_i$ 之間是否獨立。\n那麼要如何求出 $E(X_i)$ 呢？首先可以列出遞迴的式子：\n$$\nE(X_i) = [i = 1] + \\sum p_{j,i} E(X_j)\n$$\n其中 $[i=1]$ 是艾佛森括號，$p_{j,i}$ 代表現在在頂點 $j$ 的話走到頂點 $i$ 的機率\n仔細看 subtask 的話可以發現前三個 subtask 都是 DAG ，可以用 DP 的方式求出 $E(X_i)$，而最後一個 subtask 可能會有各種環出現，但是 $n$ 只有 100，可以用高斯消去的方法得到 $E(X_i)$（至於為什麼一定有解我不知道，可能跟「保證可以從頂點 $1$ 抵達任何頂點、保證任何頂點都可以抵達其中一個終點」有關）。\n接著是第二步，也就是如何加裝加速器。可以發現在同一個頂點裝加速器的效益是越來越低的，那麼有一個很直覺的貪心就是每次拿「能夠減少的時間」最多的頂點一直拿，因為如果不拿的話可以把最後一個裝的加速器直接換給那個頂點而使得最佳解至少不會變壞。\n因為 $k$ 只有 $10^5$ 所以甚至可以直接用 heap 或 multiset 維護最大一直拿就好了。如果 $k$ 到 $10^9$ 或更多的話可能可以用二分搜去算，類似今年入營考那題。\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135  // An AC a day keeps the doctor away. #pragma GCC optimize(\u0026#34;Ofast\u0026#34;) #include \u0026lt;bits/stdc++.h\u0026gt;#ifdef local #define safe std::cerr\u0026lt;\u0026lt;__PRETTY_FUNCTION__\u0026lt;\u0026lt;\u0026#34; line \u0026#34;\u0026lt;\u0026lt;__LINE__\u0026lt;\u0026lt;\u0026#34; safe\\n\u0026#34; #define debug(args...) qqbx(#args, args) #define orange(args...) danb(#args, args) using std::cerr; template \u0026lt;typename ...T\u0026gt; void qqbx(const char *s, T ...args) { int cnt = sizeof...(T); ((cerr \u0026lt;\u0026lt; \u0026#34;\\e[1;32m(\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;) = (\u0026#34;), ..., (cerr \u0026lt;\u0026lt; args \u0026lt;\u0026lt; (--cnt ? \u0026#34;, \u0026#34; : \u0026#34;)\\e[0m\\n\u0026#34;))); } template \u0026lt;typename T\u0026gt; void danb(const char *s, T L, T R) { cerr \u0026lt;\u0026lt; \u0026#34;\\e[1;32m[ \u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34; ] = [ \u0026#34;; for (int f = 0; L != R; ++L) cerr \u0026lt;\u0026lt; (f++ ? \u0026#34;, \u0026#34; : \u0026#34;\u0026#34;) \u0026lt;\u0026lt; *L; cerr \u0026lt;\u0026lt; \u0026#34; ]\\e[0m\\n\u0026#34;; } #else #define safe ((void)0) #define debug(...) ((void)0) #define orange(...) ((void)0) #endif // local #define all(v) begin(v),end(v)  using namespace std; using ld = long double; const int maxn = 100025; namespace gauss { const ld eps = 1e-10; ld A[105][105], b[105]; // Ax = b, solve x  void elim(int n) { for (int k = 0; k \u0026lt; n; k++) { if (abs(A[k][k]) \u0026lt;= eps) { int p = -1; for (int i = k+1; i \u0026lt; n; i++) if (abs(A[i][k]) \u0026gt; eps) { p = i; break; } assert (p != -1); for (int j = 0; j \u0026lt; n; j++) swap(A[k][j], A[p][j]); swap(b[k], b[p]); } for (int i = 0; i \u0026lt; n; i++) if (i != k) { ld r = A[i][k] / A[k][k]; for (int j = 0; j \u0026lt; n; j++) A[i][j] -= A[k][j] * r; b[i] -= b[k] * r; } } for (int i = 0; i \u0026lt; n; i++) for (int j = 0; j \u0026lt; n; j++) if (i != j) assert (abs(A[i][j]) \u0026lt;= eps); for (int i = 0; i \u0026lt; n; i++) assert (abs(A[i][i]) \u0026gt; eps); for (int i = 0; i \u0026lt; n; i++) b[i] /= A[i][i]; } } int t[maxn]; int out[maxn]; vector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; g[maxn]; int indeg[maxn]; ld E[maxn]; int rat[maxn]; signed main() { ios_base::sync_with_stdio(0), cin.tie(0); int n, m, k; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k; for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; t[i]; for (int i = 0; i \u0026lt; m; i++) { int a, b, c; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c; --a, --b; g[a].emplace_back(c, b); out[a] += c; indeg[b] += 1; } if (n \u0026gt; 100) { E[0] = 1; queue\u0026lt;int\u0026gt; que; for (int i = 0; i \u0026lt; n; i++) if (indeg[i] == 0) { que.push(i); } assert (que.size() == 1 \u0026amp;\u0026amp; que.front() == 0); while (!que.empty()) { int i = que.front(); que.pop(); for (auto [c, j]: g[i]) E[j] += E[i] * c / ld(out[i]); for (auto [c, j]: g[i]) if (--indeg[j] == 0) que.push(j); } for (int i = 0; i \u0026lt; n; i++) assert (indeg[i] == 0); } else { for (int i = 0; i \u0026lt; n; i++) gauss::A[i][i] = 1; for (int i = 0; i \u0026lt; n; i++) { // E[i] = [i=1] + \\sum p_{j,i} E[j]  for (auto [c, j]: g[i]) { ld p = c / ld(out[i]); gauss::A[j][i] = -p; } } gauss::b[0] = 1; gauss::elim(n); for (int i = 0; i \u0026lt; n; i++) E[i] = gauss::b[i]; } for (int i = 0; i \u0026lt; n; i++) E[i] *= t[i]; priority_queue\u0026lt;pair\u0026lt;ld,int\u0026gt;\u0026gt; pq; for (int i = 0; i \u0026lt; n; i++) { rat[i] = 1; pq.emplace(E[i] / rat[i] - E[i] / (rat[i] + 1), i); } for (int t = 0; t \u0026lt; k; t++) { auto [_, i] = pq.top(); pq.pop(); rat[i] += 1; pq.emplace(E[i] / rat[i] - E[i] / (rat[i] + 1), i); } ld ans = 0; for (int i = 0; i \u0026lt; n; i++) ans += E[i] / rat[i]; cout \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(10); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }   p4 breadboard 題意 有 $n$ 個元件與 $m$ 條導線需要被安置在麵包版上，並且希望同時符合下列兩個規則\n 每個元件只能被放在 $(x, y)$ 的位置上，其中 $x$ 是正整數，$y$ 座標只能是 $1$ 或 $0$ 每條導線連接兩個元件 $(u, v)$，連接方式是從一個元件拉一條直線線段到另一個元件上。每條導線連接的元件需要放在不同的 $y$ 座標上，且任兩條導線不能有交叉，連到同一個元件的導線不視為交叉。  在滿足上述規則的同時，希望所有元件放置的 $x$ 座標都在 $k$ 以下，且 $k$ 越小越好。\n請輸出最小的 $k$ 值，若沒有一種滿足規則的方法請輸出 $-1$。\n限制 $1 \\leq n \\leq 10^5$\n$0 \\leq m \\leq 10^6$\n保證沒有兩條導線連接相同的兩個元件，並且每條導線的兩個端點是不同的元件。\nsubtask 1 (5) $n \\leq 20$\nsubtask 2 (10) $n \\leq 100$\nsubtask 3 (31) $n \\leq 10000$\nsubtask 4 (54) 無額外限制\n作法 其實看到題目給的附圖就會知道這題跟二分圖有關係了（？）\n首先把元件當成點、導線當成邊，那麼題目等於是給定一張圖要你判他是不是同時是二分圖又可以照規則畫出來。\n稍微畫幾個例子就可以知道，可以滿足規則的連通圖大概會是一條鏈加上一堆葉子。\n可以用幾個規則來判這件事：首先圖要是樹，接著每個 $\\deg \u0026gt; 1$ 的頂點只能有最多兩個鄰居也是 $\\deg \u0026gt; 1$ 的。\n另外，只要決定好哪些點要放上面哪些點要放下面的話，那麼最大的 $x$ 座標至少就是 $\\min($ 下面的點數 $,$ 上面的點數 $)$，並且也可以達成這樣的最小值。\n因此我們相當於每個連通塊有兩種放法，讓某個點在上面還是下面會造成上面或是下面增加一定的點數。可以用背包問題類型的 DP 來解決這樣類似 0/1 背包問題的部份，但是複雜度可能有點不太對，有兩個方法可以解決並 AC 本題：\n 使用 bitset 加速。必須把 DP 的狀態改成「是否可以湊出來」。 因為連通塊點數總和是 $\\mathcal{O}(n)$ ，不同的數字種類最多只有 $\\mathcal{O}(\\sqrt{n})$，可以對每個數字做類似多重背包的東西。  code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96  // An AC a day keeps the doctor away. #pragma GCC optimize(\u0026#34;Ofast\u0026#34;) #include \u0026lt;bits/stdc++.h\u0026gt;#ifdef local #define safe std::cerr\u0026lt;\u0026lt;__PRETTY_FUNCTION__\u0026lt;\u0026lt;\u0026#34; line \u0026#34;\u0026lt;\u0026lt;__LINE__\u0026lt;\u0026lt;\u0026#34; safe\\n\u0026#34; #define debug(args...) qqbx(#args, args) #define orange(args...) danb(#args, args) using std::cerr; template \u0026lt;typename ...T\u0026gt; void qqbx(const char *s, T ...args) { int cnt = sizeof...(T); ((cerr \u0026lt;\u0026lt; \u0026#34;\\e[1;32m(\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;) = (\u0026#34;), ..., (cerr \u0026lt;\u0026lt; args \u0026lt;\u0026lt; (--cnt ? \u0026#34;, \u0026#34; : \u0026#34;)\\e[0m\\n\u0026#34;))); } template \u0026lt;typename T\u0026gt; void danb(const char *s, T L, T R) { cerr \u0026lt;\u0026lt; \u0026#34;\\e[1;32m[ \u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34; ] = [ \u0026#34;; for (int f = 0; L != R; ++L) cerr \u0026lt;\u0026lt; (f++ ? \u0026#34;, \u0026#34; : \u0026#34;\u0026#34;) \u0026lt;\u0026lt; *L; cerr \u0026lt;\u0026lt; \u0026#34; ]\\e[0m\\n\u0026#34;; } #else #define safe ((void)0) #define debug(...) ((void)0) #define orange(...) ((void)0) #endif // local #define all(v) begin(v),end(v)  using namespace std; using ld = long double; const int maxn = 100025; bool vis[maxn]; vector\u0026lt;int\u0026gt; g[maxn]; bool color[maxn]; int cnt[2]; bitset\u0026lt;maxn\u0026gt; dp; void dfs(int i, int f = -1) { ++cnt[color[i]]; vis[i] = true; for (int j: g[i]) if (!vis[j]) { color[j] = !color[i]; dfs(j, i); } else if (j != f) { // cycle = true;  cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; exit(0); } } signed main() { ios_base::sync_with_stdio(0), cin.tie(0); int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 0; i \u0026lt; m; i++) { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; --a, --b; g[a].push_back(b); g[b].push_back(a); } int sum = 0; vector\u0026lt;int\u0026gt; diff; for (int i = 0; i \u0026lt; n; i++) if (!vis[i]) { cnt[0] = cnt[1] = 0; dfs(i); sum += abs(cnt[0] - cnt[1]); diff.push_back(abs(cnt[0] - cnt[1])); } for (int i = 0; i \u0026lt; n; i++) if (g[i].size() \u0026gt; 1) { int c = 0; for (int j: g[i]) if (g[j].size() \u0026gt; 1) ++c; if (c \u0026gt; 2) { cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; exit(0); } } dp[0] = true; for (int x: diff) dp |= dp \u0026lt;\u0026lt; x; // dp[X] = we can make one side X  int ans = n; for (int i = 0; i \u0026lt; maxn; i++) if (dp[i]) { // |a-b| = |i - (sum-i)|  int d = abs(sum - i * 2); // a + b = n  assert (d % 2 == n % 2); ans = min(ans, (n + d) / 2); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }   四模 註：四模打完沒有開放judge讓我們練習的時間，所以code跟賽中沒有人AC的cards不保證正確。\np1 spotlight 題意 給定 $n$ 個（實心的）凸多邊形，每個多邊形有一個固定的移動速度 $(dx, dy)$，整個多邊形會沿著該方向不停的等速移動。\n對於第 $i$ 個多邊形，請輸出這個多邊形有碰到其他多邊形的總時間，若永遠都會碰到輸出 infinity，否則輸出的相對誤差或絕對誤差在 1e-6 以下都算正確。碰到多邊形的定義是兩者的交集非空，只有邊界或是頂點碰到也算。\n限制 $2 \\leq n \\leq 100$\n每個凸多邊形的點數 $\\leq 100$\n頂點座標的絕對值 $\\leq 10000$\n保證輸入給的頂點不會在凸多邊形邊上\nsubtask 1 (15) 保證輸入給的是平行座標軸的長方形\nsubtask 2 (11) 所有 $dx = dy = 0$\nsubtask 3 (17) 對於每個多邊形皆有 $dx = 0$ 或 $dy = 0$ （註：不太確定實際意思）\nsubtask 4 (57) 無額外限制\n作法  subtask 2 $dx=dy=0$\n多邊形不會動，表示答案只有0或是infinity，只要檢查多邊形兩兩之間有沒有碰到就可以了。\n判斷凸多邊形兩兩有沒有交集可以用下面兩個條件來判斷，只要其中一個條件成立就一定有相交，而都不成立就表示沒有相交。\n1. 兩個多邊形的邊是否有相交\n2. 是否有一個多邊形的頂點坐落在另一個多邊形的裡面\n雖然只判斷第2點會在賽中得到這個subtask的分數，但是注意只判其中一個條件都有反例。 滿分解\n不太確定其他subtask是拿來幹嘛的，完全沒有特別簡單的寫法。\n記第$i$個多邊形為$P_i$，他的速度是$\\vec{v_i} = (dx_i, dy_i)$\n考慮枚舉所有多邊形對$(i,j)$，$P_j$對$P_i$的相對速度是$\\vec{v_j}-\\vec{v_i}$。可以知道兩個多邊形可能完全不會碰到、永遠碰在一起，或是碰到一段時間$[s,t]$。先假設相對速度非零，考慮把座標旋轉、伸縮使得相對速度變成$(0,-1)$，也就是沿著Y軸方向下落。任何一條通過兩個多邊形的鉛直線和兩個多邊形的交集分別會是一段線段，可以推出他們在這個X座標互相碰到與離開的時間。取遍所有這類鉛直線，再把有碰到的時間區間聯集起來就是這兩個多邊形互相碰觸的時間區間，但我們不可能算那麼多條線，不過透過觀察可以發現，只要取遍所有頂點的X座標，再計算在那些X座標的碰觸時間的最小值與最大值，所得到正好是我們要的時間區間。\n枚舉所有多邊形對並計算兩兩之間有碰到的時間，可以用爬行法作到$\\mathcal{O}(n\\sum |P_i|)$，其中$|P_i|$是多邊形$P_i$的點數，不過筆者賽中是寫$\\mathcal{O}((\\sum |P_i|)^2)$有AC。  code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146  #pragma GCC optimize(\u0026#34;Ofast\u0026#34;) #include \u0026lt;bits/stdc++.h\u0026gt;#ifdef local #define safe cerr\u0026lt;\u0026lt;__PRETTY_FUNCTION__\u0026lt;\u0026lt;\u0026#34; line \u0026#34;\u0026lt;\u0026lt;__LINE__\u0026lt;\u0026lt;\u0026#34; safe\\n\u0026#34; #define pary(a...) danb(#a, a) #define debug(a...) qqbx(#a, a) template \u0026lt;typename ...T\u0026gt; void qqbx(const char *s, T ...a) { int cnt = sizeof...(T); ((std::cerr \u0026lt;\u0026lt; \u0026#34;\\033[1;32m(\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;) = (\u0026#34;) , ... , (std::cerr \u0026lt;\u0026lt; a \u0026lt;\u0026lt; (--cnt ? \u0026#34;, \u0026#34; : \u0026#34;)\\033[0m\\n\u0026#34;))); } template \u0026lt;typename T\u0026gt; void danb(const char *s, T L, T R) { std::cerr \u0026lt;\u0026lt; \u0026#34;\\033[1;32m[ \u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34; ] = [ \u0026#34;; for (int f = 0; L != R; ++L) std::cerr \u0026lt;\u0026lt; (f++ ? \u0026#34;, \u0026#34; : \u0026#34;\u0026#34;) \u0026lt;\u0026lt; *L; std::cerr \u0026lt;\u0026lt; \u0026#34; ]\\033[0m\\n\u0026#34;; } #else #define debug(...) ((void)0) #define safe ((void)0) #define pary(...) ((void)0) #endif // local #define all(v) begin(v),end(v) #define pb emplace_back  using namespace std; using ll = long long; using ld = long double; const int inf = 1e9; const ll INF = 1e18; const int maxn = 300; template \u0026lt;typename T, typename U\u0026gt; bool chmin(T \u0026amp;t, const U \u0026amp;u) { return t \u0026lt; u ? false : (t=u, true); } template \u0026lt;typename T, typename U\u0026gt; bool chmax(T \u0026amp;t, const U \u0026amp;u) { return t \u0026gt; u ? false : (t=u, true); } struct Vec { int x, y; void rot(Vec \u0026amp;v) { int nx = v.y * x - v.x * y; int ny = -(v.x * x + v.y * y); x = nx, y = ny; } friend Vec operator-(const Vec \u0026amp;lhs, const Vec \u0026amp;rhs) { return { lhs.x - rhs.x, lhs.y - rhs.y }; } friend istream \u0026amp; operator\u0026gt;\u0026gt;(istream \u0026amp;I, Vec \u0026amp;v) { return I \u0026gt;\u0026gt; v.x \u0026gt;\u0026gt; v.y; } ll norm() const { return 1LL * x * x + 1LL * y * y; } }; using Polygon = vector\u0026lt;Vec\u0026gt;; Vec v[maxn]; Polygon P[maxn]; ld intersection(Vec a, Vec b, int x, int init) { if (a.x \u0026gt; b.x) swap(a, b); if (x \u0026lt; a.x || x \u0026gt; b.x) return init; if (a.x == b.x) return abs(a.y - init) \u0026gt; abs(b.y - init) ? a.y : b.y; return (1LL * a.y * (b.x - x) + 1LL * b.y * (x - a.x)) / ld(b.x - a.x); } pair\u0026lt;ld,ld\u0026gt; calc(Polygon A, Polygon B, Vec v) { if (v.norm() != 0) { for (auto \u0026amp;p: A) p.rot(v); for (auto \u0026amp;p: B) p.rot(v); // fix A, and rotate s.t. B moving down with velocity (0, -1)  } vector\u0026lt;int\u0026gt; xs; for (auto p: A) xs.push_back(p.x); for (auto p: B) xs.push_back(p.x); sort(all(xs)), xs.erase(unique(all(xs)), xs.end()); pary(all(xs)); ld lt = inf, rt = -inf; for (int x: xs) { ld la = inf, ra = -inf; ld lb = inf, rb = -inf; for (int i = 0; i \u0026lt; A.size(); i++) { int j = i ? i-1 : A.size() - 1; chmin(la, intersection(A[i], A[j], x, inf)); chmax(ra, intersection(A[i], A[j], x, -inf)); } for (int i = 0; i \u0026lt; B.size(); i++) { int j = i ? i-1 : B.size() - 1; chmin(lb, intersection(B[i], B[j], x, inf)); chmax(rb, intersection(B[i], B[j], x, -inf)); } chmin(lt, lb - ra); chmax(rt, rb - la); } debug(lt, rt); if (lt \u0026gt; rt || rt \u0026lt; 0) return { inf, -inf }; if (v.norm() == 0) return { -inf, inf }; if (lt \u0026lt; 0) lt = 0; lt /= v.norm(), rt /= v.norm(); return { lt, rt }; } signed main() { ios_base::sync_with_stdio(0), cin.tie(0); int n; cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; v[i]; int sz; cin \u0026gt;\u0026gt; sz; P[i].resize(sz); for (auto \u0026amp;p: P[i]) cin \u0026gt;\u0026gt; p; } cout \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(10); for (int i = 0; i \u0026lt; n; i++) { vector\u0026lt;pair\u0026lt;ld,int\u0026gt;\u0026gt; evt; for (int j = 0; j \u0026lt; n; j++) { if (i != j) { auto [l, r] = calc(P[i], P[j], v[j] - v[i]); if (l \u0026lt; r) { evt.emplace_back(l, 1); evt.emplace_back(r, -1); } } } sort(all(evt)); int cnt = 0; ld ans = 0; for (int l = 0, r = 0; l \u0026lt; evt.size(); l = r) { for (r = l; r \u0026lt; evt.size(); r++) { if (evt[l].first != evt[r].first) break; cnt += evt[r].second; } if (r == evt.size()) continue; if (cnt) { ans += evt[r].first - evt[l].first; } } if (ans \u0026gt;= inf) cout \u0026lt;\u0026lt; \u0026#34;infinity\\n\u0026#34;; else cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } }   p2 line up 題意 現在有一家餐廳，因為防疫關係只能做現點現做的外帶生意，所有等候外帶的顧客必須要在櫃台前排成一排，並且餐廳最多只能容納 $k$ 名顧客排隊，而服務任何一位客人所需要的時間都是 $s$ 單位時間。你已經知道今天有 $n$ 名顧客會出現，第 $i$ 名顧客會在時刻 $t_i$ 時抵達餐廳，而如果成功服務第 $i$ 名顧客，將會帶給餐廳 $p_i$ 的利潤。如果一位顧客加入隊伍時，他是第 $k+1$ 名顧客，那麼他就會打消興致離開，特別注意若此時正好是服務完一位客人之後，那麼他們兩位不算同時出現在隊伍中。請你勸退一些顧客，使得剩下的顧客都能夠順利獲得餐點，請問此時餐廳的最佳收益是多少？\n限制 $1 \\leq k \\leq n \\leq 4000$\n$1 \\leq s \\leq 10^6$\n$1 \\leq t_i \\leq 10^9$\n$1 \\leq p_i \\leq 10^6$\nsubtask 1 (14) $n \\leq 20; s \\leq 1000; t_i \\leq 2000$\nsubtask 2 (9) $k = 1$\nsubtask 3 (24) $n \\leq 100; s \\leq 1000$\nsubtask 4 (53) 無額外限制\n作法 先來喇分XD\n subtask 1\n$2^n$枚舉要留下哪些顧客，並檢查是否符合題目的條件。可以檢查對題意的理解 subtask 2\n$k = 1$的意思是完全不會有隊伍，所有選的顧客不能有任何一個時刻在等待，也就是說所有有選的$i$，$[t_i,t_i+s)$不能相交。因為帶權所以可能不好greedy，但是可以很容易的dp。 滿分解\n註：以下做菜跟接待都代表服務客人的意思\n考慮最佳解的長相，一定會是一直重複「某位客人來了之後開始做菜，連續為好幾位顧客做菜之後先暫停」。所以我們會想要對於每位客人，枚舉從他來的時間開始接待幾位客人。\n對於一個固定的起始時間和接待人數，首先第一個人會花$s$的時間做菜，在這段時間可能會有一些人到達店裡，在其中又可以選一些人來排隊。隊伍裡面當然是留越多人越好，但是如果人數超過了$k$，很自然的可以貪心的一直把隊伍裡面價值最小的丟掉。在接待完第一個人之後，必須選一個隊伍裡面的客人作為下一位接待的客人，這時候也很自然的會貪心的選隊伍裡面價值最大的來接待，而在接待這個客人的期間又會有一些客人到達，之後不斷重複一樣的原則就能算出最佳利潤。因為會需要刪除隊伍中價值最大跟最小的，賽中筆者是直接用multiset維護隊伍中的客人，也可以用常數可能比較小的兩個heap。\n一輪連續的接待可以更新接待完這些客人之後才來的客人的dp值，因此我們狀態定為$dp_i =$ 在客人$i$來之前做完所有事情所獲得的最大收益，按照$t_i$由小到大就能好好dp。\n要注意題目特別強調的條件，也就是「若此時正好是服務完一位客人之後，那麼他們兩位不算同時出現在隊伍中」，賽中筆者原本一直WA，針對這個敘述修改維護multiset的過程後就AC了（雖然寫的有點醜）。  code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72  #pragma GCC optimize(\u0026#34;Ofast\u0026#34;) #include \u0026lt;bits/stdc++.h\u0026gt;#ifdef local #define safe cerr\u0026lt;\u0026lt;__PRETTY_FUNCTION__\u0026lt;\u0026lt;\u0026#34; line \u0026#34;\u0026lt;\u0026lt;__LINE__\u0026lt;\u0026lt;\u0026#34; safe\\n\u0026#34; #define pary(a...) danb(#a, a) #define debug(a...) qqbx(#a, a) template \u0026lt;typename ...T\u0026gt; void qqbx(const char *s, T ...a) { int cnt = sizeof...(T); ((std::cerr \u0026lt;\u0026lt; \u0026#34;\\033[1;32m(\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;) = (\u0026#34;) , ... , (std::cerr \u0026lt;\u0026lt; a \u0026lt;\u0026lt; (--cnt ? \u0026#34;, \u0026#34; : \u0026#34;)\\033[0m\\n\u0026#34;))); } template \u0026lt;typename T\u0026gt; void danb(const char *s, T L, T R) { std::cerr \u0026lt;\u0026lt; \u0026#34;\\033[1;32m[ \u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34; ] = [ \u0026#34;; for (int f = 0; L != R; ++L) std::cerr \u0026lt;\u0026lt; (f++ ? \u0026#34;, \u0026#34; : \u0026#34;\u0026#34;) \u0026lt;\u0026lt; *L; std::cerr \u0026lt;\u0026lt; \u0026#34; ]\\033[0m\\n\u0026#34;; } #else #define debug(...) ((void)0) #define safe ((void)0) #define pary(...) ((void)0) #endif // local #define all(v) begin(v),end(v) #define pb emplace_back #define get_pos(u,x) int(lower_bound(all(u),x)-begin(u))  using namespace std; using ll = int_fast64_t; using ld = long double; template \u0026lt;typename T\u0026gt; using min_heap = priority_queue\u0026lt;T, vector\u0026lt;T\u0026gt;, greater\u0026lt;T\u0026gt;\u0026gt;; const int mod = 1000000007; const int inf = 1e9; const ll INF = 1e18; const int maxn = 5025; signed main() { ios_base::sync_with_stdio(0), cin.tie(0); int n, k, s; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k \u0026gt;\u0026gt; s; vector\u0026lt;int\u0026gt; t(n), p(n); { vector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; customer(n); for (auto \u0026amp;[t, p]: customer) cin \u0026gt;\u0026gt; t \u0026gt;\u0026gt; p; sort(all(customer)); for (int i = 0; i \u0026lt; n; i++) tie(t[i], p[i]) = customer[i]; } vector\u0026lt;int\u0026gt; dp(n+1); for (int i = 0; i \u0026lt; n; i++) { dp[i+1] = max(dp[i+1], dp[i]); int profit = p[i]; multiset\u0026lt;int\u0026gt; ms; int j = i+1; for (int x = 1; x \u0026lt;= n; x++) { while (j \u0026lt; n \u0026amp;\u0026amp; t[j] \u0026lt; t[i] + x * s) { ms.insert(p[j++]); while (ms.size() \u0026gt; k-1) ms.erase(ms.begin()); } while (j \u0026lt; n \u0026amp;\u0026amp; t[j] == t[i] + x * s) { ms.insert(p[j++]); while (ms.size() \u0026gt; k) ms.erase(ms.begin()); } dp[j] = max(dp[j], dp[i] + profit); if (ms.empty()) break; profit += *prev(ms.end()); ms.erase(prev(ms.end())); } } cout \u0026lt;\u0026lt; dp[n] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }   p3 earthworm 給定一棵 $n$ 個節點的樹，考慮一種路徑分割（即將樹的邊集分成許多不相交的子集，且每個子集都是一條路徑），定義他的得分是所有路徑的長度的平方和。求所有路徑分割的得分總和，除以 $10^9 + 7$ 的餘數。\n限制 $2 \\leq n \\leq 5000$\nsubtask 1 (13) $n \\leq 12$\nsubtask 2 (19) $n \\leq 100$\nsubtask 3 (7) $n \\leq 5000$，且所有節點的度數不超過 2\nsubtask 4 (9) $n \\leq 5000$，且所有節點的度數不超過 3\nsubtask 5 (52) 無額外限制\n作法 考慮枚舉樹上所有路徑，並計算有幾種路徑分割包含這條路徑。\n從原本的樹上拔掉這條路徑的邊之後可能會剩下一些子樹，因此現在的問題就是如何計算一個樹有幾種路徑分割方法。一開始可能會想要用樹dp來計算，但其實每個頂點可以獨立計算，可以看成是每個頂點有一些相鄰的邊，並且邊可以任意兩兩配對或是不配對的方法數，也就是說一個頂點的貢獻只和他的degree有關。\n事實上一棵樹的路徑分割方法數就是$\\prod_{v\\in V} dp_{\\deg v}$其中$dp_n$是一張$n$個點的完全圖的匹配種類數。\n比較有效率求出$dp_n$的方法是利用遞迴式$dp_n = dp_{n-1} + (n-1)dp_{n-2}$（考慮編號最大的點沒有配/配給某個點），不過筆者賽中的想法是枚舉匹配了幾對再用排列組合計算，式子大概長的像：\n$$\ndp_n = 1 + \\binom{n}{2} + \\frac{\\binom{n}{2}\\binom{n-2}{2}}{2!} + \\frac{\\binom{n}{2}\\binom{n-2}{2}\\binom{n-4}{2}}{3!} + \\cdots\n$$\n 枚舉路徑、修改$\\deg$再重新計算種類最naive大概是$\\mathcal{O}(n^3)$，可以過subtask 2並確認式子有沒有推錯。 如果$dp_n$只有前幾項算對也會過subtask 3/4 把每個點當根dfs並沿途維護deg的改變對總方法數的影響可以作到$\\mathcal{O}(n^2)$並在賽中AC這題。 可以用枚舉LCA或是重心剖分等方式來得到更好的複雜度，似乎不是本題想考的。 賽中時限有點緊，可能需要預處理一些東西的反元素，尤其是用排列組合$\\mathcal{O}(n^2)$算$dp_n$的需要注意不要讓$\\log n$跑到$n^2$上，並且要盡量減少mod。  可能會有人想要樹dp直接維護一個子樹的答案，但其實有時候把樹dp的維度弄太複雜反而不好實做也不好想，這個作法是從「每個路徑對答案貢獻多少」出發的。\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107  #pragma GCC optimize(\u0026#34;Ofast\u0026#34;) #include \u0026lt;bits/stdc++.h\u0026gt;#ifdef local #define safe cerr\u0026lt;\u0026lt;__PRETTY_FUNCTION__\u0026lt;\u0026lt;\u0026#34; line \u0026#34;\u0026lt;\u0026lt;__LINE__\u0026lt;\u0026lt;\u0026#34; safe\\n\u0026#34; #define pary(a...) danb(#a, a) #define debug(a...) qqbx(#a, a) template \u0026lt;typename ...T\u0026gt; void qqbx(const char *s, T ...a) { int cnt = sizeof...(T); ((std::cerr \u0026lt;\u0026lt; \u0026#34;\\033[1;32m(\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;) = (\u0026#34;) , ... , (std::cerr \u0026lt;\u0026lt; a \u0026lt;\u0026lt; (--cnt ? \u0026#34;, \u0026#34; : \u0026#34;)\\033[0m\\n\u0026#34;))); } template \u0026lt;typename T\u0026gt; void danb(const char *s, T L, T R) { std::cerr \u0026lt;\u0026lt; \u0026#34;\\033[1;32m[ \u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34; ] = [ \u0026#34;; for (int f = 0; L != R; ++L) std::cerr \u0026lt;\u0026lt; (f++ ? \u0026#34;, \u0026#34; : \u0026#34;\u0026#34;) \u0026lt;\u0026lt; *L; std::cerr \u0026lt;\u0026lt; \u0026#34; ]\\033[0m\\n\u0026#34;; } #else #define debug(...) ((void)0) #define safe ((void)0) #define pary(...) ((void)0) #endif // local #define all(v) begin(v),end(v) #define pb emplace_back #define get_pos(u,x) int(lower_bound(all(u),x)-begin(u))  using namespace std; using ll = int_fast64_t; using ld = long double; template \u0026lt;typename T\u0026gt; using min_heap = priority_queue\u0026lt;T, vector\u0026lt;T\u0026gt;, greater\u0026lt;T\u0026gt;\u0026gt;; const int mod = 1000000007; const int inf = mod; const ll INF = 1e18; const int maxn = 5002; ll dp[maxn], invdp[maxn]; ll modpow(ll e, ll p) { ll r = 1; while (p) (p\u0026amp;1) \u0026amp;\u0026amp; (r=r*e%mod), e=e*e%mod, p\u0026gt;\u0026gt;=1; return r; } vector\u0026lt;int\u0026gt; g[maxn]; int deg[maxn]; ll ans = 0; void dfs(int i, int p, int dep, ll prod) { ans = (ans + 1LL * dep * dep * prod % mod * dp[deg[i]-1] % mod * invdp[deg[i]]) % mod; if (p != -1 \u0026amp;\u0026amp; g[i].size() \u0026gt;= 2) { prod = prod * dp[deg[i]-2] % mod * invdp[deg[i]] % mod; } for (int j: g[i]) { if (j != p) dfs(j, i, dep+1, prod); } } ll fac[maxn], ifac[maxn], inv[maxn]; signed main() { ios_base::sync_with_stdio(0), cin.tie(0); /* dp[0] = 1; dp[1] = 1; for (int i = 2; i \u0026lt; maxn; i++) dp[i] = (dp[i-1] + dp[i-2] * (i-1)) % mod; pary(dp, dp+10); */ inv[1] = 1; for (int i = 2; i \u0026lt; maxn; i++) inv[i] = inv[mod % i] * (mod - mod / i) % mod; fac[0] = ifac[0] = 1; for (int i = 1; i \u0026lt; maxn; i++) { fac[i] = fac[i-1] * i % mod; ifac[i] = ifac[i-1] * inv[i] % mod; } for (int i = 0; i \u0026lt; maxn; i++) { dp[i] = 1; ll prod = 1; for (int j = 0; j * 2 + 2 \\leq i; j++) { ll C = fac[i - j*2] * ifac[2] % mod * ifac[i - j*2 - 2] % mod; prod = prod * C % mod; dp[i] = (dp[i] + prod * ifac[j+1]) % mod; } } pary(dp, dp+10); for (int i = 0; i \u0026lt; maxn; i++) invdp[i] = modpow(dp[i], mod-2); int n; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt; n; i++) { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; g[a].pb(b); g[b].pb(a); ++deg[a], ++deg[b]; } ll prod = 1; for (int i = 0; i \u0026lt; n; i++) prod = prod * dp[deg[i]] % mod; for (int i = 0; i \u0026lt; n; i++) { debug(i); dfs(i, -1, 0, prod * dp[deg[i]-1] % mod * invdp[deg[i]] % mod); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }   p4 cards 題意 有 $m$ 張卡片，每張卡片上面會寫著一條形如「$x_i \u0026lt; x_j$」、「$x_i = x_j$」或是「$x_i \u0026gt; x_j$」的敘述，其中 $i$, $j$ 是不大於 $n$ 的正整數。現在要執行 $m - 1$ 次的合併操作，每次會指定兩堆不同的卡片合併成為一堆，在每次的合併操作完，對於兩堆合併而成的那一堆，請輸出是否有一些正整數代進 $x_1, x_2,\\cdots, x_n$ 可以符合該堆所有卡片的敘述。\n限制 $1 \\leq n \\leq 10^5$\n$1 \\leq m \\leq 5 \\times 10^5$\nsubtask 1 (12) $m \\leq 10^5, n \\leq 50$\nsubtask 2 (31) $m \\leq 10^5, n \\leq 1000$\nsubtask 3 (57) 無額外限制\n作法 註：作法 by ericxiao\n先考慮暴力做，就是每次合併完之後判斷這些敘述是否有可能同時達成。要怎麼判斷一堆敘述是否有可能同時達成呢？我們可以把每一個變數($x_1,x_2,\u0026hellip;$)想成一個節點，並把敘述當成他們之間的邊。先把「$x_i = x_j$」的情形處理掉好了，我們把所有相等敘述的兩個變數之間連邊，就可以透過DFS或是DSU，讓我們在之後的敘述遇到某個變數時，就用與它相等的編號最小的變數代替。那接下來就只需要處理「$x_i \u0026gt; x_j$」的敘述了(我們可以把小於敘述的兩邊倒過來)。我們這次一樣把變數當作節點，而對於敘述「$x_i \u0026gt; x_j$」，我們就從$x_i$往$x_j$連一條有向邊。可以發現這些敘述可以同時達成若且唯若這張圖上沒有環。這樣做一次的複雜度是$O(|S|)$，其中$S$代表前要判斷合法性的敘述的集合。所以最糟的清況總複雜度會是$O(m^2)$。雖然稍微優化一下可能可以過subtask 1，但還是有點慢。\n我認為如果可以的話，有時候把題目轉換成更具體的形式後有機會變得比較容易思考。這題的話可以把合併的過程想像成一顆有根的二元樹，其中的$m$個葉子各代表$m$個敘述的其中之一，而其它節點就代表在合併過程中所出現的敘述的集合，並且若$u$的子節點為$v,w$，表示$u$所代表的集合是$v$代表的集合與$w$代表的集合合併的結果。如此一來，題目便是要求你回答這個樹上的每個非葉節點所代表的集合中的全部敘述是否可能同時達成(以下簡稱這樣的節點是好的，反之則是壞的)。應該可以不難地看出若一個節點是壞的，它所有祖先也都是壞的。\n再回頭看看第一段的做法，一個顯然會讓該作法的時間複雜度退化到$O(m^2)$的狀況就是合併的過程中不斷地把一個個敘述加入一個大集合中；也就是說，代表合併過程的二元樹是一條長長的鏈上面接一堆葉節點。如果我們要讓複雜度變好，一定要想辦法解決這種情形。而頗為自然地，可以發現那條鏈上的節點如果有好有壞的話，一定存在一個分界點，使得它和它的子節點都是好的，而它的祖先都是壞的；所以只要找到那個分界點(或是發現其不存在)就可以知道全部節點的答案。這樣的情形不免讓人想要二分搜。這樣的複雜度是多少呢？每次確認一個節點是好是壞就先DFS找到它底下的所有葉節點，得到所有敘述後再直接用原本的作法，所以複雜度是$O(m)$，而總複雜度就是頗好的$O(m\\log m)$。\n那如果合併的過程只是一般的二元樹呢？一個很單純的想法就是我們一次做完一條鏈，只要所有節點都包含於至少一條鏈中就做完整棵樹了。等等，鏈\u0026hellip;樹\u0026hellip;，樹鏈剖分？真是個自然的想法。所以我們就試著對那棵二元樹做樹鏈剖分，然後每一條重鏈也都會符合「存在一個分界點，使得它和它的子節點都是好的，而它的祖先都是壞的」，我們就一樣用二分搜的方式確定該條鏈上的節點是好是壞。\n接著便是估複雜度的時候了！對於一條重鏈，我們所需要花的時間上面分析過，其實是$O(B_i\\log B_i)$，其中$B_i$代表第$i$條重鏈頂的子樹大小。所以總複雜度就是$O((\\sum B_i) \\log M)$。那$(\\sum B_i)$是多少呢？所有重鏈頂的子樹大小的和其是就是根的子樹大小加上所有「輕小孩」的子樹大小，所以其實是$O(m\\log m)$，那總複雜度就是$O(m \\log^2 m)$囉。雖然沒有到真的很快，但也比原本快上不少了。\n這只是個人大略的想法，一些其他問題，包括「一定要把樹建出來嗎？」、「要怎麼在重鏈上二分搜？」就希望大家可以想想看了？\ncode by Omelet\n過了好一陣子才把 code 補上，於是也講一下跟上面類似但不完全一樣的觀點。\n啟發式合併是小點合併到大點，而我們希望一次合併並計算答案的複雜度跟小點有關，才會得到好的複雜度。因為只會越合併越差，那麼我們乾脆在合併的時候先不要計算答案，而是先把合併的順序記下來，一直到一個點要當小點的時候再一次用二分搜計算答案。仔細想想會發現這樣跟輕重鍊剖分要做的事情差不多，下面的 code 是用這樣的想法生出來的，希望複雜度是對的（還沒測過）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176  // An AC a day keeps the doctor away. #pragma GCC optimize(\u0026#34;Ofast\u0026#34;) #include \u0026lt;bits/stdc++.h\u0026gt;#ifdef local #define safe std::cerr\u0026lt;\u0026lt;__PRETTY_FUNCTION__\u0026lt;\u0026lt;\u0026#34; line \u0026#34;\u0026lt;\u0026lt;__LINE__\u0026lt;\u0026lt;\u0026#34; safe\\n\u0026#34; #define debug(args...) qqbx(#args, args) #define orange(args...) danb(#args, args) using std::cerr; template \u0026lt;typename ...T\u0026gt; void qqbx(const char *s, T ...args) { int cnt = sizeof...(T); ((cerr \u0026lt;\u0026lt; \u0026#34;\\e[1;32m(\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;) = (\u0026#34;), ..., (cerr \u0026lt;\u0026lt; args \u0026lt;\u0026lt; (--cnt ? \u0026#34;, \u0026#34; : \u0026#34;)\\e[0m\\n\u0026#34;))); } template \u0026lt;typename T\u0026gt; void danb(const char *s, T L, T R) { cerr \u0026lt;\u0026lt; \u0026#34;\\e[1;32m[ \u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34; ] = [ \u0026#34;; for (int f = 0; L != R; ++L) cerr \u0026lt;\u0026lt; (f++ ? \u0026#34;, \u0026#34; : \u0026#34;\u0026#34;) \u0026lt;\u0026lt; *L; cerr \u0026lt;\u0026lt; \u0026#34; ]\\e[0m\\n\u0026#34;; } #else #define safe ((void)0) #define debug(...) ((void)0) #define orange(...) ((void)0) #endif // local #define all(v) begin(v),end(v)  using namespace std; const int maxn = 100025, maxm = 500025; struct Edge { char c; int a, b; Edge () = default; Edge (char c, int a, int b) : c(c), a(a), b(b) {} }; namespace impl { vector\u0026lt;int\u0026gt; uG[maxn]; // undirected vector\u0026lt;int\u0026gt; dG[maxn]; // directed bool vis[maxn]; int ccid[maxn]; void uDfs(int i) { vis[i] = true; for (int j: uG[i]) { if (!vis[j]) { ccid[j] = ccid[i]; uDfs(j); } } } } bool noCycle(const vector\u0026lt;Edge\u0026gt; \u0026amp;es) { using namespace impl; for (auto [c, a, b]: es) for (int x: {a, b}) uG[x].clear(), vis[x] = false; for (auto [c, a, b]: es) if (c == \u0026#39;=\u0026#39;) uG[a].push_back(b), uG[b].push_back(a); int ccid_counter = 0; for (auto [c, a, b]: es) for (int x: {a, b}) if (!vis[x]) { ccid[x] = ccid_counter++; uDfs(x); } vector\u0026lt;int\u0026gt; indeg(ccid_counter); for (int i = 0; i \u0026lt; ccid_counter; i++) dG[i].clear(); debug(\u0026#34;HERE\u0026#34;); for (auto [c, a, b]: es) if (c == \u0026#39;\u0026gt;\u0026#39;) { a = ccid[a]; b = ccid[b]; if (a == b) return false; dG[a].push_back(b), ++indeg[b]; } queue\u0026lt;int\u0026gt; que; for (int i = 0; i \u0026lt; ccid_counter; i++) if (indeg[i] == 0) que.push(i); while (!que.empty()) { int i = que.front(); que.pop(); for (int j: dG[i]) if (--indeg[j] == 0) que.push(j); } for (int i = 0; i \u0026lt; ccid_counter; i++) if (indeg[i] != 0) return false; return true; } namespace dsu { int pa[maxm], sz[maxm]; vector\u0026lt;Edge\u0026gt; edges[maxm]; struct Op { int qid; Edge e; Op (int qid) : qid(qid), e() {} Op (Edge e) : qid(-1), e(e) {} }; vector\u0026lt;Op\u0026gt; ops[maxm]; int ans[maxm]; void init(int n) { for (int i = 0; i \u0026lt; n; i++) pa[i] = i, sz[i] = 1; } int anc(int x) { return x==pa[x] ? x : pa[x]=anc(pa[x]); } void doOps(int x) { debug(\u0026#34;doOps\u0026#34;, x, ops[x].size()); const auto ok = [x](int p) -\u0026gt; bool { vector\u0026lt;Edge\u0026gt; es = edges[x]; for (int i = 0; i \u0026lt; p; i++) if (ops[x][i].qid == -1) es.emplace_back(ops[x][i].e); return noCycle(es); }; int p = 0; for (int s = 1\u0026lt;\u0026lt;20; s; s \u0026gt;\u0026gt;= 1) if (p + s \u0026lt;= ops[x].size() \u0026amp;\u0026amp; ok(p + s)) p += s; for (int i = 0; i \u0026lt; p; i++) if (ops[x][i].qid != -1) ans[ops[x][i].qid] = true; for (auto [qid, e]: ops[x]) if (qid == -1) edges[x].emplace_back(e); } void join(int a, int b, int qid) { a = anc(a), b = anc(b); if (a == b) { ops[a].emplace_back(qid); return; } if (sz[a] \u0026lt; sz[b]) swap(a, b); doOps(b); sz[a] += sz[b]; pa[b] = a; for (const Edge \u0026amp;e: edges[b]) ops[a].emplace_back(e); ops[a].emplace_back(qid); edges[b].clear(); ops[b].clear(); } } signed main() { ios_base::sync_with_stdio(0), cin.tie(0); int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; dsu::init(m); for (int i = 0; i \u0026lt; m; i++) { int a, b; char c; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; c \u0026gt;\u0026gt; b; --a, --b; if (c == \u0026#39;\u0026lt;\u0026#39;) { c = \u0026#39;\u0026gt;\u0026#39;; swap(a, b); } dsu::edges[i].emplace_back(c, a, b); } for (int i = 1; i \u0026lt; m; i++) { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; --a, --b; dsu::join(a, b, i); } dsu::doOps(dsu::anc(0)); for (int i = 1; i \u0026lt; m; i++) cout \u0026lt;\u0026lt; (dsu::ans[i] ? \u0026#34;Yes\\n\u0026#34; : \u0026#34;No\\n\u0026#34;); }   ","permalink":"https://omeletwithoutegg.github.io/2021/09/22/toi-2021-sols/","tags":["experience","TOI","geometry","data-structure","dfs","dp","greedy","tree"],"title":"TOI 2021 Solutions"},{"contents":"這篇是想放一些神奇的C++語法錯誤\n也可能會放基礎的(X\n然後可能會是動態更新\nlambda capture (Update: 2021/1/21)\n這似乎是因為capture到值的時候還沒成功建構func這個變數，所以會出問題\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  #include \u0026lt;iostream\u0026gt;#include \u0026lt;functional\u0026gt; using namespace std; signed main() { function\u0026lt;void(void)\u0026gt; func = [=]() { int x; cin \u0026gt;\u0026gt; x; cout \u0026lt;\u0026lt; \u0026#34;ok \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; if(x) func(); }; func(); }   const reference \u0026amp; implicit conversion (Update: 2021/1/21)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  #include \u0026lt;iostream\u0026gt; using namespace std; struct Data { int x; Data(int val = 0) : x(val) {} int calc() { return x * 2 + 3; } }; istream \u0026amp; operator\u0026gt;\u0026gt;(istream \u0026amp;I, const Data \u0026amp;data) { return I \u0026gt;\u0026gt; data.x; } int main() { Data data; cin \u0026gt;\u0026gt; data; cout \u0026lt;\u0026lt; data.calc() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }   vector\u0026lt;bool\u0026gt; access with auto deduce type (Update: 2021/1/21)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  #include \u0026lt;iostream\u0026gt;#include \u0026lt;vector\u0026gt; using namespace std; int main() { const int n = 20, m = 20; // n * m grid  auto check = [\u0026amp;](int x, int y) { cout \u0026lt;\u0026lt; x*m+y \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; vector\u0026lt;bool\u0026gt; ok(n * m); // do some calc  return ok[x * m + y]; }; cout \u0026lt;\u0026lt; check(0, 0) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }   abs outside of std (Update: 2021/8/15)\nstd::abs 有多型，會自己偵測吃進去的是不是 long long，但是 std 外面的 abs 不會，要用 llabs。\n1 2 3 4 5 6 7 8 9 10  #include \u0026lt;bits/stdc++.h\u0026gt; using ll = long long; signed main() { ll n = 5298309920314; std::cout \u0026lt;\u0026lt; abs(n) \u0026lt;\u0026lt; std::endl; // overflow!  std::cout \u0026lt;\u0026lt; llabs(n) \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; std::abs(n) \u0026lt;\u0026lt; std::endl; }   Array in Temporary Object (Update: 2021/9/19)\n如果要在 struct 裡面使用指標或是原生陣列的話，要注意如果你保留一個臨時物件的這種成員，可能會讓這個指標在臨時物件被銷毀之後變得指向一塊不合法的記憶體。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  #include \u0026lt;iostream\u0026gt;#include \u0026lt;map\u0026gt; using namespace std; struct F { int a[2]; F() : a{0, 1} {} }; void print(int a[2]) { for (int i = 0; i \u0026lt; 2; i++) cerr \u0026lt;\u0026lt; a[i]; cerr \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } map\u0026lt;int,F\u0026gt; mp; F GET(int i) { return mp[i]; } void safe() { cerr \u0026lt;\u0026lt; \u0026#34;--- safe BEGIN ---\\n\u0026#34;; auto B = GET(0); auto a = B.a; print(a); cerr \u0026lt;\u0026lt; \u0026#34;--- safe END -----\\n\u0026#34;; } void notsafe() { cerr \u0026lt;\u0026lt; \u0026#34;--- notsafe BEGIN ---\\n\u0026#34;; auto a = GET(0).a; print(a); cerr \u0026lt;\u0026lt; \u0026#34;--- notsafe END -----\\n\u0026#34;; } signed main() { F A; mp[0] = A; print(A.a); safe(); notsafe(); }   ","permalink":"https://omeletwithoutegg.github.io/2021/09/19/cppbugs/","tags":["cpp","experience"],"title":"Cppbugs"},{"contents":"https://codeforces.com/problemset/gymProblem/101193/J\n這題是上禮拜團練沒人寫的某一題，因為我一直覺得自己的想法是對的所以花了好久來寫這題。\n網路上也找不太到題解:P\nCherry orchard Description 左下角和右上角分別是 $(0,0)$ 和 $(1,1)$ 的正方形裡面有 $n$ 個點\n現在隨機在正方形的兩條不同的邊各選一個點，並畫出一條直線把這 $n$ 個點分成兩部份。\n請問兩部份中點數的 min 的期望值是多少？\n$n \\leq 50$\nSolution 有一個比較聰明的解與一個很複雜的解。先來講我一開始想到的比較複雜的解。\n考慮枚舉所有點對，可以得到所有可能的分法（把點分成兩部份的方法），對於每種分法想辦法計算選到這種分法的機率。\n先蓋好兩部份的凸包。枚舉隨機選到的其中一個點所在的邊 $E$ ，不失一般性可以當作他是正方形左邊那條邊。\n假設我們已經選好上面一個點 $P$ ，那可以「和 $P$ 連成直線，把 $n$ 個點切成這兩個凸包」的 $Q$ 會是另一條邊上的一個範圍。\n這個範圍和 $P$ 與兩個凸包的切線有關，可以枚舉兩個凸包的上下關係， $P$ 只會切到上面那個凸包的下凸包與下面那個凸包的上凸包。\n$E$ 上可以分成 $\\mathcal{O}(n)$ 個區間，每個區間內切到下凸包的點和切到上凸包的點是固定的。\n接下來是最後也是最難的部份：對於 $P=(0,y)$ 來說，假設他切到上面那個凸包的 $A$、下面那個凸包的 $B$，那 $\\overrightarrow{PA}$ 和 $\\overrightarrow{PB}$ 中間的區域就是 $Q$ 可以在的區域，對於另外三條邊來說是一段區間，而這樣的區間左右界會是只跟 $y$ 有關的一個函數。\n雖然他題敘沒有講清楚選中點的機率分佈是不是連續均勻分佈，但大概可以假設是，因此如果 $P=(0,y)$ 對應到的區間長度是 $f(y)$ ，最後的答案就是 $\\int _ 0 ^ 1 f(y)$。\n仔細計算之後可以發現：\n對於對邊來說，區間左右界都是被截斷的線性函數，因此很好積分，只是要討論一下大小。\n對於鄰邊來說，區間左右界都是被截斷的 $H+\\frac{A}{x-K}$ ，考慮被截斷的範圍不可能包含 $K$ 因此也是可以簡單的積分成 $\\log$ 之類的東西。\n因為我不知道怎麼處理截斷（跟 $0,1$ 取 $\\min,\\max$）所以把所有討論都寫出來了，長到不行Orz\n另外我有些地方現在看起來都是在讓code更醜，例如把所有座標乘 1000 倍再做事或是硬要用 complex 算計幾。\n現在來講聰明的解！我是從 binsjl 的 submission 大概理解的，所以也可能有錯\n先選定一個邊 $E$，一樣可以假設他是正方形左邊那條邊，那麼我們可以算出「所有點對形成的直線」以及「右上右下兩個點與所有點形成的直線」和 $E$ 交點，把 $E$ 分成 $\\mathcal{O}(n^2)$ 個區間。\n對於一個區間來說，隨便選定裡面一個點當作原點 $O$，把給定的 $n$ 個點極角排序順序都是一樣的。\n真的隨便選定一個點當原點極角排序之後，可以得出在這個區間內如果選定了 $P=(0,y)$，對應的另一條邊的區間長度的函數長怎樣，一樣跑去積分就可以了，似乎邊界條件還自動被解決了，一整個短到驚訝(?)\nAC code 因為是比較複雜的那個解，所以醜的不像話。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351  // An AC a day keeps the doctor away. #pragma GCC optimize(\u0026#34;Ofast\u0026#34;) #include \u0026lt;bits/stdc++.h\u0026gt;#ifdef local #define safe std::cerr\u0026lt;\u0026lt;__PRETTY_FUNCTION__\u0026lt;\u0026lt;\u0026#34; line \u0026#34;\u0026lt;\u0026lt;__LINE__\u0026lt;\u0026lt;\u0026#34; safe\\n\u0026#34; #define debug(args...) qqbx(#args, args) #define orange(args...) danb(#args, args) using std::cerr; template \u0026lt;typename ...T\u0026gt; void qqbx(const char *s, T ...args) { int cnt = sizeof...(T); ((cerr \u0026lt;\u0026lt; \u0026#34;\\e[1;32m(\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;) = (\u0026#34;), ..., (cerr \u0026lt;\u0026lt; args \u0026lt;\u0026lt; (--cnt ? \u0026#34;, \u0026#34; : \u0026#34;)\\e[0m\\n\u0026#34;))); } template \u0026lt;typename T\u0026gt; void danb(const char *s, T L, T R) { cerr \u0026lt;\u0026lt; \u0026#34;\\e[1;32m[ \u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34; ] = [ \u0026#34;; for (int f = 0; L != R; ++L) cerr \u0026lt;\u0026lt; (f++ ? \u0026#34;, \u0026#34; : \u0026#34;\u0026#34;) \u0026lt;\u0026lt; *L; cerr \u0026lt;\u0026lt; \u0026#34; ]\\e[0m\\n\u0026#34;; } #else #define safe ((void)0) #define debug(...) ((void)0) #define orange(...) ((void)0) #endif // local #define all(v) begin(v),end(v)  using namespace std; using ld = long double; using Point = complex\u0026lt;int\u0026gt;; using Pointf = complex\u0026lt;ld\u0026gt;; const ld eps = 1e-9; const int C = 1000; const long long INF = 1e18; template \u0026lt;typename T\u0026gt; vector\u0026lt;T\u0026gt; join(const vector\u0026lt;T\u0026gt; \u0026amp;A, const vector\u0026lt;T\u0026gt; \u0026amp;B) { vector\u0026lt;T\u0026gt; result(A.size() + B.size()); merge(A.begin(), A.end(), B.begin(), B.end(), result.begin()); return result; } template \u0026lt;typename T\u0026gt; T dot(complex\u0026lt;T\u0026gt; a, complex\u0026lt;T\u0026gt; b) { return real(conj(a) * b); } template \u0026lt;typename T\u0026gt; T cross(complex\u0026lt;T\u0026gt; a, complex\u0026lt;T\u0026gt; b) { return imag(conj(a) * b); } ld solve(vector\u0026lt;Point\u0026gt; p); mt19937 rng(2103); ld naive(vector\u0026lt;Point\u0026gt; _p) { vector\u0026lt;Pointf\u0026gt; p; for (auto pt: _p) p.emplace_back(real(pt), imag(pt)); struct Line { Pointf st, dir; Line (Pointf A, Pointf B) : st(A), dir(B - A) {} Pointf random() const { ld x = uniform_real_distribution\u0026lt;ld\u0026gt;(0, 1)(rng); return st + dir * x; } }; static Line lines[] = { Line(Pointf(0, 0), Pointf(0, C)), Line(Pointf(0, C), Pointf(C, C)), Line(Pointf(C, C), Pointf(C, 0)), Line(Pointf(C, 0), Pointf(0, 0)) }; const int EX = 1000000; int ans = 0; for (int i = 0; i \u0026lt; EX; i++) { int a, b; do { a = uniform_int_distribution\u0026lt;int\u0026gt;(0, 3)(rng); b = uniform_int_distribution\u0026lt;int\u0026gt;(0, 3)(rng); } while (a == b); Pointf A = lines[a].random(); Pointf B = lines[b].random(); int ac = 0, cc = 0; for (auto pt: p) { ld C = cross(pt - A, B - A); if (C \u0026lt; 0) ++ac; else if (C \u0026gt; 0) ++cc; } ans += min(ac, cc); } return ans / ld(EX); } signed main() { ios_base::sync_with_stdio(0), cin.tie(0); int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;Point\u0026gt; p(n); for (int i = 0; i \u0026lt; n; i++) { ld x, y; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; p[i] = Point(round(x * C), round(y * C)); } debug(naive(p)); Point center(500, 500); ld ans = 0; for (int dir = 0; dir \u0026lt; 4; dir++) { ans += solve(p); for (auto \u0026amp;pt: p) pt = (pt - center) * Point(0, 1) + center; } ans /= 12; cout \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(10) \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } ld solve(vector\u0026lt;Point\u0026gt; p) { int n = p.size(); sort(p.begin(), p.end(), [](Point \u0026amp;a, Point \u0026amp;b) { return make_pair(real(a), imag(a)) \u0026lt; make_pair(real(b), imag(b)); }); vector\u0026lt;pair\u0026lt;vector\u0026lt;int\u0026gt;, vector\u0026lt;int\u0026gt;\u0026gt;\u0026gt; part; for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; i; j++) { Point N = p[j] - p[i]; vector\u0026lt;int\u0026gt; online[2], halfplane[2]; bool ok = true; for (int k = 0; k \u0026lt; n; k++) { Point prod = conj(N) * p[k]; if (prod.imag() \u0026lt; cross(N, p[i])) { halfplane[0].push_back(k); } else if (prod.imag() \u0026gt; cross(N, p[i])) { halfplane[1].push_back(k); } else if (prod.real() \u0026lt;= dot(N, p[i])) { online[0].push_back(k); } else if (prod.real() \u0026gt;= dot(N, p[j])) { online[1].push_back(k); } else { ok = false; break; } } if (!ok) continue; part.emplace_back(join(online[0], halfplane[0]), join(online[1], halfplane[1])); part.emplace_back(join(online[0], halfplane[1]), join(online[1], halfplane[0])); } } for (auto \u0026amp;[f, s]: part) { if (f \u0026gt; s) swap(f, s); } sort(part.begin(), part.end()); part.erase(unique(part.begin(), part.end()), part.end()); safe; const auto buildConvexHull = [](const vector\u0026lt;Point\u0026gt; \u0026amp;d) { if (d.size() == 1) return d; vector\u0026lt;Point\u0026gt; s(d.size() * 2); int o = 0; for(int i = 0; i \u0026lt; int(d.size()); i++) { while(o\u0026gt;=2 \u0026amp;\u0026amp; cross(d[i]-s[o-2],s[o-1]-s[o-2]) \u0026lt;= 0) o--; s[o++] = d[i]; } for(int i=int(d.size())-2, t = o+1;i\u0026gt;=0;i--){ while(o\u0026gt;=t \u0026amp;\u0026amp; cross(d[i]-s[o-2],s[o-1]-s[o-2]) \u0026lt;= 0) o--; s[o++] = d[i]; } s.resize(o-1); return s; }; const auto calc = [](vector\u0026lt;Point\u0026gt; L, vector\u0026lt;Point\u0026gt; R) { const auto getUpperHull = [](vector\u0026lt;Point\u0026gt; \u0026amp; P) { assert (!P.empty()); auto it = min_element(P.begin(), P.end(), [](Point a, Point b){ return real(a) != real(b) ? real(a) \u0026lt; real(b) : imag(a) \u0026gt; imag(b); }); rotate(P.begin(), it, P.end()); auto jt = max_element(P.begin(), P.end(), [](Point a, Point b){ return real(a) != real(b) ? real(a) \u0026lt; real(b) : imag(a) \u0026lt; imag(b); }); // debug(P.size(), jt - P.begin());  P.erase(next(jt), P.end()); }; const auto getLowerHull = [](vector\u0026lt;Point\u0026gt; \u0026amp; P) { assert (!P.empty()); reverse(P.begin(), P.end()); auto it = min_element(P.begin(), P.end(), [](Point a, Point b){ return real(a) != real(b) ? real(a) \u0026lt; real(b) : imag(a) \u0026lt; imag(b); }); rotate(P.begin(), it, P.end()); auto jt = max_element(P.begin(), P.end(), [](Point a, Point b){ return real(a) != real(b) ? real(a) \u0026lt; real(b) : imag(a) \u0026gt; imag(b); }); // debug(P.size(), jt - P.begin());  P.erase(next(jt), P.end()); reverse(P.begin(), P.end()); }; const auto interpolate = [](Point a, Point b, int x) -\u0026gt; ld { // real(a + (b-a)t) == x  // t = (x - real(a)) / real(b-a)  // imag(a + (b-a)t) = imag(a) + imag(b-a) * t  ld t = (x - real(a)) / ld(real(b - a)); return imag(a) + imag(b-a) * t; // return (imag(a) * (real(b) - x) + imag(b) * (x - real(a))) / ld(real(b) - real(a));  }; const auto intergral = [\u0026amp;interpolate](ld l, ld r, Point a, Point b) -\u0026gt; ld { l = clamp\u0026lt;ld\u0026gt;(l, 0, C); r = clamp\u0026lt;ld\u0026gt;(r, 0, C); if (l \u0026gt;= r) return 0; ld res1 = 0, res2 = 0; // linear  do { ld tl = l, tr = r; ld A1 = 1 - C / ld(real(a)), B1 = C * imag(a) / ld(real(a)); ld A2 = 1 - C / ld(real(b)), B2 = C * imag(b) / ld(real(b)); if (real(a) == real(b)) { if (B1 \u0026gt;= B2) { break; } } else if (A1 \u0026lt; A2) { // (A2 - A1)y \u0026gt; B1 - B2  tl = max(tl, (B1 - B2) / (A2 - A1)); } else if (A1 \u0026gt; A2) { // (A1 - A2)y \u0026lt; B2 - B1  tr = min(tr, (B2 - B1) / (A1 - A2)); } else { exit(3); } { // 0 \u0026lt; A1y + B1 \u0026lt; A2y + B2 \u0026lt; C  // -B1 / A1 \u0026gt; y  ld R = min(tr, -B1 / A1); // y \u0026gt; (C - B2) / A2  ld L = max(tl, (C - B2) / A2); // (A2 - A1) y + (B2 - B1)  if (L \u0026lt; R) res1 += (A2 - A1) * (R*R - L*L) / 2 + (B2 - B1) * (R - L); } { // A1y + B1 \u0026lt; 0 \u0026lt; A2y + B2 \u0026lt; C  // y \u0026gt; -B1 / A1  // -B2 \u0026lt; A2y -\u0026gt; y \u0026lt; -B2 / A2  // y \u0026gt; (C - B2) / A2  ld L = max({ tl, -B1 / A1, (C - B2) / A2 }); ld R = min(tr, - B2 / A2); if (L \u0026lt; R) res1 += A2 * (R*R - L*L) / 2 + B2 * (R - L); } { // 0 \u0026lt; A1y + B1 \u0026lt; C \u0026lt; A2y + B2  // y \u0026lt; -B1 / A1  // y \u0026gt; (C - B1) / A1  // y \u0026lt; (C - B2) / A2  ld L = max(tl, (C - B1) / A1); ld R = min({ tr, -B1 / A1, (C - B2) / A2 }); if (L \u0026lt; R) res1 += -A1 * (R*R - L*L) / 2 + (C-B1) * (R - L); } { // A1y + B1 \u0026lt; 0 \u0026lt; C \u0026lt; A2y + B2  // y \u0026gt; -B1 / A1  // y \u0026lt; (C - B2) / A2  ld L = max(tl, -B1 / A1); ld R = min(tr, (C - B2) / A2); if (L \u0026lt; R) res1 += C * (R - L); } } while (false); // non-linear  do { // H + A / (X - K)  ld L1 = real(a) * imag(a) / ld(C - real(a)) + imag(a); ld L2 = real(b) * imag(b) / ld(C - real(b)) + imag(b); ld tl = l, tr = r; if (real(a) == real(b)) { if (imag(a) \u0026gt;= imag(b)) break; } else if (real(a) \u0026lt; real(b)) { tl = max(tl, interpolate(a, b, 0)); } else if (real(a) \u0026gt; real(b)) { tr = min(tr, interpolate(a, b, 0)); } ld H1 = real(a), A1 = real(a) * imag(a), K1 = imag(a); ld H2 = real(b), A2 = real(b) * imag(b), K2 = imag(b); // y \u0026lt;= L1 \u0026amp;\u0026amp; y \u0026lt;= L2 -\u0026gt; C - C  { // y \u0026gt; L1 \u0026amp;\u0026amp; y \u0026gt; L2  ld L = max({ tl, L1, L2 }); ld R = tr; // H1 + A1 / (X - K1) \u0026lt; H2 + A2 / (X - K2)  // H1 (X-K1)(X-K2) + A1(X-K2) \u0026lt; H2(X-K1)(X-K2) + A2(X-K1)  if (L \u0026lt; R) res2 += (H2 - H1) * (R - L) + A2 * (log(R - K2) - log(L - K2)) - A1 * (log(R - K1) - log(L - K1)); } { // C - (H1 + A1 / (X - K1))  // y \u0026gt; L1 \u0026amp;\u0026amp; y \u0026lt; L2  ld L = max(tl, L1); ld R = min(tr, L2); if (L \u0026lt; R) res2 += (C - H1) * (R - L) - A1 * (log(R - K1) - log(L - K1)); } { ld L = max(tl, L2); ld R = min(tr, L1); assert (L \u0026gt;= R); } } while (false); ld res = res1 + res2 * 2; return res / (C * C); }; getUpperHull(L); getLowerHull(R); // orange(all(L));  // orange(all(R));  int n = L.size(), m = R.size(); vector\u0026lt;pair\u0026lt;ld,bool\u0026gt;\u0026gt; evt; for (int i = 0; i+1 \u0026lt; n; i++) { ld y = interpolate(L[i], L[i+1], 0); if (i) assert (y \u0026gt;= evt.back().first); evt.emplace_back(y, 0); } for (int i = 0; i+1 \u0026lt; m; i++) { ld y = interpolate(R[i], R[i+1], 0); if (i) assert (y \u0026gt;= evt.back().first); evt.emplace_back(y, 1); } sort(evt.begin(), evt.end()); int it = 0, jt = 0; ld last = -INF, res = 0; for (auto [y, type]: evt) { res += intergral(last, y, L[it], R[jt]); last = y; if (type == 0) { ++it; } else { ++jt; } } res += intergral(last, INF, L[it], R[jt]); return res; }; ld res = 0; for (const auto \u0026amp;[f, s]: part) { vector\u0026lt;Point\u0026gt; L, R; for (int id: f) L.push_back(p[id]); for (int id: s) R.push_back(p[id]); L = buildConvexHull(L); R = buildConvexHull(R); res += (calc(L, R) + calc(R, L)) * min(f.size(), s.size()); } return res; }   ","permalink":"https://omeletwithoutegg.github.io/2021/09/12/bsuir-cherry-orchard/","tags":["math","geometry"],"title":"BSUIR Cherry Orchard"},{"contents":"CKCOS 10th 身為一個特殊班的學生，在畢業的時候還是會想打一些心得給未來的學弟參考吧。主要是希望對科學班有興趣的人可以了解科學班的一些權益與義務，在做這些決定的時候有更多資訊可以評估，也可以做好一些心理準備。\n考進之前 在國小的時候，家長就有帶我去補一些比較超前的課，最主要的是陳立數學，一直上到國二（吧），一開始學的比較接近小學或國中的競賽數學，後來則是變成先修高中數學，大概把高中數學都講過一遍了。\n另外還有補過一些物理跟化學，國三的時候因為要會考，跑去補了社會、國文、英文\n想要去考的原因主要是被家長說服說可以證明自己的實力，沒有上也可以當成是練習，最後蠻意外的過了。\nT分數其實不太記得了，只記得化學跟生物應該都蠻低的，有點靠數學撐起來的感覺。\n我猜赫哲應該比我更清楚所以不要問我怎麼準備。\n考上之後 在可以進入科學班之後，我有選擇是否要去建中科學班，因為畢竟是男校，也有考慮過要不要去師大附中之類的。不過大家都建議既然考上就去，我也就直接進入這趟不歸路了。\n在錄取之後其實就可以不用讀會考了，但那時候我因為想留在班上所以就每天很隨意的寫複習考，後來會考也考了勉強可以進建中的成績。老實說覺得有點浪費時間，如果有考上的學弟記得把這段時間繼續拿來提昇自己，像是讀一些英文小說或是去看一些科普影片，又或者是直接去讀一些自己喜歡的領域的書，大概都比準備會考好。\n科學班的特色 競賽 我想擺在第一個講是因為我對這個比較熟悉。\n 讀書會\n建中的很多科競賽都有讀書會在支撐，例如數讀、物讀、資讀等等，真的建議 027 的學弟要好好利用這些資源，在暑假就可以開始聽這些精彩的分享。當然，學成之後也可以為之後的學弟帶來更精彩的分享，傳承薪火。 能力競賽\n沒記錯的話科學班的學生好像要至少參加一科校內能力競賽，不過物化生只能選一科參加，通常校內會有初試、複試，接著就是北市能競，最後是全國能競。一年級的時候數學能競有到校內複試，但最後沒有變成校隊，也沒有當上資訊校隊，無緣市賽、全國賽、入營考；二年級成功變成資訊校隊，跑去撈了市賽跟全國賽的禮券回家。 公假\n建中的老師大部分都對公假是很寬容的，一二年級能競期間班上幾乎都空的很誇張，直到能競一一結束才陸續回流。要小心的是記得最好跟任課老師還是說一聲，以免無聲無息的被當掉，而且不要請超過兩個月之類的超長假…真的會得奧林匹亞回歸症候群。 APMOC\n一年級的時候被老師推薦來參加這個營隊，似乎是特殊班可以推薦一名，但我直到結束之後才知道這個營隊主要是來考試獲得數奧選訓營的資格的XD 我甚至在宿舍打 code 跟打 osu，超放鬆（？）有點對不起數學老師就是了。現在數奧的制度似乎不一樣了，不過如果有這種機會還是要好好注意一下…  所謂超前進度 高一高二上完高中三年課程是科學班標榜的特色之一，但在高三大部分的人並沒有變得比較輕鬆。高三可以去大學修自己有興趣的課，而且必須至少修一堂，但如果不是已經有大學念的人，可能就會因為升學壓力而沒辦法好好選自己想要的課，有些有想法的人可能還會在選課時被質疑。\n專題 高一高二的時候我們必須分組完成一個專題，這個專題會在成果發表時上台發表，為此我們會在高一下學期就分組並各自尋找指導教授。高三時，必須完成個別科學研究的報告書，而且是個人完成，因此高三可以說是蠟燭 $N$ 頭燒的情況。我個人的專題真的做得超糟糕，只能說讓我認識到根本不會做科學研究，各位還沒進科班的學弟對於這件義務真的要謹慎思考(X)\n畢業學分 科學班的選修學分基本上是多到滿出來，相對的分配給必修學分的時間就比較少。\n我在高中有被當掉幾次國文跟一次歷史、一次體育，建議很常公假的人要記得去管畢業必修學分，不然三年級還要努力當學分精算師。\n資格考 據說沒考過資格考會被退班，但其實能考進科學班而且有很大概的在聽課大概就可以通過資格考的數理科目了，很不幸的是我沒有通過英文科的標準，明明標準超低但我還是低了個兩三分。幸運的在高二我是IOI代表選手，因此可以免試掉資格考。\n比較非學術的活動 聯誼…？ 沒有。至少我沒有參加過，可能太邊緣吧？班上有一些跟景美、北一、中山的line群組，但基本上就是加了一個禮拜之後就冷掉，我猜想要有好關係還是要靠自己嘍。\n迎新 校內會有一個數資與科班聯合的迎新，另外還有多校聯合舉辦的數資聯合迎新，可以認識外校同學或是學長姐。\n突然有點懷念數資聯合迎新在台大水樂園玩 RPG 的時候呢（？）\n科學營 不知道什麼時候開始的傳統，似乎會去找北一的同學一起舉辦一個跟科學有關的營隊，我猜趁這個機會認識人是好機會。\n社團 這件事又可以扯很長了，在這邊沒辦法提，總之在資訊社的回憶很多很美好，而且也很好笑。參加各種社團大概是有效與異性接觸的管道(?)\n語癖與班上同學 升高中之後換了很多語癖，例如郭、嘍、顯然、電…等等，大部分都是從參加競賽或是同學參加競賽時與其他人碰撞所產生的有趣的火花。和這些強者在同一個班上沒有帶給我很多壓力（第一次段考就習慣後段了），不過我們這一屆來說班上很多同學都很有個性，例如會在班上運球(?!)或是大吼大叫的，有點像還在國中一樣，在高一高二的時候有點小困擾，但他們的實力也都是毋庸置疑的，和這些強者能夠同班實在是很榮幸，尤其是我個人覺得走物奧的人特別有想法，很佩服他們。\n結語 高中三年選擇科學班，雖然有許多辛苦的事情，例如很難的數理考題、各種吵雜的班上環境、還有最困難的做專題，但我也享受到了許多科班的權益，例如大量的化學、物理實驗課（雖然我沒有喜歡做實驗），還有與同儕或是學長請教、討論的機會，以及我覺得最有價值的讀書會，在讀書會認識的不管是學長學弟還是同屆，都讓我成長許多。我相信世上沒有完美的選擇，但希望各位選擇與沒有選擇科學班的學弟都能不後悔。\n今天晚上是謝師宴，如果有什麼我想補充的會再更新。\n","permalink":"https://omeletwithoutegg.github.io/2021/08/13/ckcos-10th/","tags":["experience"],"title":"科學班三年之小小紀錄"},{"contents":"除錯模板的重要 這是一篇很短的廢文。\n當你發現你寫出的程式有 bug 的時候，就會是你花上很多時間的時候。\n尤其是在打 OI 的情況下，付出一點點時間讓 debug 變更簡單是有必要的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  // An AC a day keeps the doctor away. #pragma GCC optimize(\u0026#34;Ofast\u0026#34;) #include \u0026lt;bits/stdc++.h\u0026gt;#ifdef local #define safe std::cerr\u0026lt;\u0026lt;__PRETTY_FUNCTION__\u0026lt;\u0026lt;\u0026#34; line \u0026#34;\u0026lt;\u0026lt;__LINE__\u0026lt;\u0026lt;\u0026#34; safe\\n\u0026#34; #define debug(args...) qqbx(#args, args) #define orange(args...) danb(#args, args) using std::cerr; template \u0026lt;typename ...T\u0026gt; void qqbx(const char *s, T ...args) { int cnt = sizeof...(T); ((cerr \u0026lt;\u0026lt; \u0026#34;\\e[1;32m(\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;) = (\u0026#34;), ..., (cerr \u0026lt;\u0026lt; args \u0026lt;\u0026lt; (--cnt ? \u0026#34;, \u0026#34; : \u0026#34;)\\e[0m\\n\u0026#34;))); } template \u0026lt;typename T\u0026gt; void danb(const char *s, T L, T R) { cerr \u0026lt;\u0026lt; \u0026#34;\\e[1;32m[ \u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34; ] = [ \u0026#34;; for (int f = 0; L != R; ++L) cerr \u0026lt;\u0026lt; (f++ ? \u0026#34;, \u0026#34; : \u0026#34;\u0026#34;) \u0026lt;\u0026lt; *L; cerr \u0026lt;\u0026lt; \u0026#34; ]\\e[0m\\n\u0026#34;; } #else #define safe ((void)0) #define debug(...) ((void)0) #define orange(...) ((void)0) #endif // local #define all(v) begin(v),end(v)  using namespace std; signed main() { ios_base::sync_with_stdio(0), cin.tie(0); int a[] = {3, 6, 9}; vector\u0026lt;int\u0026gt; b; orange(all(a)); orange(all(b)); debug(1, 2, 3); }   利用 C++17 的 fold expression 可以讓 code 變得超級短。 \u0026quot;\\e[1;32m\u0026quot; 是代表綠色的代碼，可能在 windows 上不能用。當然，GDB 等等也是一個選擇，自己習慣最重要。\n 其實我只是想說，orange = output range 這個命名比 pary 好多了 XD\n昨天好幸福 嘻嘻\n ","permalink":"https://omeletwithoutegg.github.io/2021/08/08/debug-template/","tags":["template","experience"],"title":"Debug Template"},{"contents":"幫 pbds 上香 如題。\n先說結論：\n官網的 document 寫說 split 跟 join 時間是「poly-logarithm」，但是其實目前為止 GNU 的 pbds 預設的 split 是 $\\mathcal{O}(N)$ 的，請看這篇文章。\n不過有一些方法可以讓複雜度變回一次 split $\\Theta(\\log N)$，但是有一點麻煩。\n前言 Policy-Base Data Structure 簡稱 pbds ，是 GCC 提供的一系列資料結構的 template，而今天要談的是當中的 tree 型別。\n因為看到別人寫的 pbds 自訂 metadata_type 覺得很酷，因此想要來探索探索 pbds 一番。\n大概了解 node_update 怎麼運作之後，我試著去寫了 氣球博覽會，因為需要區間查詢，我使用了 tree::split(key, other) 和 tree::join(other)，沒想到全部吃 TLE，研究一番之後發現下面這樣的 code 就會執行不完了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  #include \u0026lt;bits/extc++.h\u0026gt;#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using BST = __gnu_pbds::tree\u0026lt;int, __gnu_pbds::null_type, less\u0026lt;int\u0026gt;, __gnu_pbds::rb_tree_tag, tree_order_statistics_node_update\u0026gt;; signed main() { ios_base::sync_with_stdio(0), cin.tie(0); BST A, B, C; int n = 100000; for (int i = 0; i \u0026lt; n; i++) { int x = rand(); A.insert(x); } long long ans = 0; for (int i = 0; i \u0026lt; n; i++) { int l = rand(); int r = rand(); if (l \u0026gt; r) swap(l, r); // query (l, r]  A.split(l, B); B.split(r, C); ans += B.size(); B.join(C); A.join(B); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }   真正累的地方 因為好奇所以把 /usr/include/c++/11.1.0/ext/pb_ds/ 翻出來看，真的有夠難看懂，到處 include 又有繼承關係，最後還是不知道為什麼會那麼慢QQ\n大概花了我一個小時以上吧？也可能是一個下午。\n後來想起來有一個工具可以分析每個函式的執行時間，google一下找到是 gprof ，搭配 gprof2dot 就找到兇手了。\n簡單來說，pbds 預設只有在一個 instance 維護一個 size ，而不是每一個節點維護一個，所以在 split 的時候無法好好維護兩棵樹的大小分別是多少，在目前的 library 當中是用 std::distance 計算 iterator 之間的距離以得知兩樹的大小，詳細可以看\next/pb_ds/detail/bin_search_tree_/split_join_fn_imps.hpp\n（bin_search_tree_set / bin_search_tree_map是沒有自平衡的二元樹，tree都是繼承自這個class）。\n醜醜的解決方案 其中一個解決的方式是在 metadata 裡面維護 size，並且 overload std::distance。\next/pb_ds/detail 裡面所有跟 tree 有關的標頭檔只有 split 之後維護 size 的地方用到一次，所以不用擔心複雜度多一個 $\\log$ 或是影響到樹的內部結構。\nsplay tree 使用 splay_tree_tag 的 tree 可以在均攤 $\\Theta(\\log N)$ split ，但是要注意複雜度均攤 $\\Theta(\\log N)$ 的前提是在拜訪任何節點後 splay 那個節點，因為我不知道怎麼把 splay 寫在 std::distance 裡面所以只好在 split 完之後用 find 來間接呼叫 splay。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60  #pragma GCC optimize(\u0026#34;Ofast\u0026#34;) #include \u0026lt;bits/extc++.h\u0026gt;#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using namespace __gnu_pbds; using BST = tree\u0026lt;int, null_type, less\u0026lt;int\u0026gt;, splay_tree_tag, tree_order_statistics_node_update\u0026gt;; using BST_Itr = BST::iterator; // overload std::distance for BST for efficiently split namespace std { template\u0026lt;\u0026gt; iterator_traits\u0026lt;BST_Itr\u0026gt;::difference_type distance(BST_Itr begin, BST_Itr end) { if (begin == end) return 0; auto it = begin.m_p_nd; // jump until root  while (it-\u0026gt;m_p_parent-\u0026gt;m_p_parent != it) it = it-\u0026gt;m_p_parent; // returns the size for the whole tree (only for split)  return it-\u0026gt;get_metadata(); } } void splayAfterSplit(BST \u0026amp;bst) { if (bst.empty()) return; bst.find(*bst.begin()); } signed main() { BST A, B, C; int n = 100000; for (int i = 0; i \u0026lt; n; i++) { int x = rand(); A.insert(x); } long long ans = 0; for (int i = 0; i \u0026lt; n; i++) { int l = rand(); int r = rand(); if (l \u0026gt; r) swap(l, r); // query (l, r]  A.split(l, B); B.split(r, C); splayAfterSplit(A); splayAfterSplit(B); splayAfterSplit(C); ans += B.size(); B.join(C); A.join(B); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }   rb_tree 而在 std::distance 複雜度是好的前提下，使用 rb_tree_tag 的 tree split 的複雜度應該就會是 $\\mathcal{O}(\\log^2 N)$ 了，但不知道是兩個 $\\log$ 就這麼慢還是有哪裡又有問題了，上面同樣1e5次的split+join開 Ofast 還是要跑大概五秒。\n鑑於兩個 $\\log$ 無法在氣球博覽會取得 AC ，我們有另外一種可以避免 split 而解決區間詢問的方式。\n只要在 metadata 維護這個子區間的最左端與最右端就能有與遞迴式線段樹類似的寫法了，一次詢問的複雜度應該是 $\\Theta(\\log N)$ 吧。醜醜又長長的 code 如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95  #pragma GCC optimize(\u0026#34;Ofast\u0026#34;) #include \u0026lt;bits/stdc++.h\u0026gt;#include \u0026lt;bits/extc++.h\u0026gt; using namespace std; const int maxn = 200025, inf = 1e9; struct info { int ans, mn, mx; pair\u0026lt;int,int\u0026gt; lmost, rmost; info () : ans(-inf), mn(-inf), mx(inf), lmost(), rmost() {} info (int c, int x) : ans(0), mn(x), mx(x), lmost(c, x), rmost(c, x) {} friend info operator+(const info \u0026amp;lhs, const info \u0026amp;rhs) { if (lhs.ans \u0026lt; 0) return rhs; if (rhs.ans \u0026lt; 0) return lhs; info res; res.ans = max({ lhs.ans, rhs.ans, rhs.mn - lhs.mx }); res.mn = min(lhs.mn, rhs.mn); res.mx = max(lhs.mx, rhs.mx); res.lmost = lhs.lmost; res.rmost = rhs.rmost; return res; } }; template\u0026lt;class Node_CItr, class Node_Itr, class Cmp_Fn, class _Alloc\u0026gt; struct my_node_update { private: using Key = pair\u0026lt;int,int\u0026gt;; info query(Node_CItr it, Key L, Key R) { if (it == node_end()) return info(); if (L \u0026lt;= it.get_metadata().lmost \u0026amp;\u0026amp; it.get_metadata().rmost \u0026lt; R) return it.get_metadata(); Key key = **it; if (key \u0026gt;= R) return query(it.get_l_child(), L, R); if (key \u0026lt; L) return query(it.get_r_child(), L, R); return query(it.get_l_child(), L, R) + info((*it) -\u0026gt; first, (*it)-\u0026gt;second) + query(it.get_r_child(), L, R); } public: typedef info metadata_type; void operator()(Node_Itr it, Node_CItr end_it) { info res((*it) -\u0026gt; first, (*it) -\u0026gt; second); Node_Itr lc = it.get_l_child(); Node_Itr rc = it.get_r_child(); if (lc != end_it) res = lc.get_metadata() + res; if (rc != end_it) res = res + rc.get_metadata(); const_cast\u0026lt;metadata_type\u0026amp;\u0026gt;(it.get_metadata()) = res; } info query(Key L, Key R) { return query(node_begin(), L, R); } virtual Node_CItr node_begin() const = 0; virtual Node_CItr node_end() const = 0; }; using BST = __gnu_pbds::tree\u0026lt;pair\u0026lt;int,int\u0026gt;, __gnu_pbds::null_type, less\u0026lt;\u0026gt;, __gnu_pbds::rb_tree_tag, my_node_update\u0026gt;; BST tr; int a[maxn]; signed main(){ ios_base::sync_with_stdio(0),cin.tie(0); int n, q, C; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q \u0026gt;\u0026gt; C; for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; for (int i = 0; i \u0026lt; n; i++) tr.insert({ a[i], i }); for(int i = 0; i \u0026lt; q; i++){ int t; cin \u0026gt;\u0026gt; t; if (t == 0) { int x, k; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; k; tr.erase({ a[x], x }); a[x] = k; tr.insert({ a[x], x }); } else { int l, r, k; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r \u0026gt;\u0026gt; k; auto res = tr.query({ k, l }, { k, r }); if (res.ans \u0026lt; 0) cout \u0026lt;\u0026lt; r - l \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; else cout \u0026lt;\u0026lt; max({ res.ans, r - res.mx, res.mn - l + 1 }) - 1 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } }   其實這樣的 code length 還有要記得的東西已經長到可以提出「這跟自己寫平衡樹不是差不多嗎？」的疑問了，實在蠻可惜的，號稱 high-performance ，然後寫這麼多東西還是比一大堆人寫的 treap 慢（也可能只是我笨笨才會 code 這麼長 QQ）。\n我覺得如果 pbds 沒有這幾個函數或是複雜度很爛倒不是什麼大問題，畢竟 STL 肥也不是一天兩天的事情了，在競賽自己寫資結也不是不行，但是官網上的說明應該要改掉QQ\nAppendix: metadata 為了怕大家聽不懂覺得心癢癢，來講怎麼什麼是 metadata 還有怎麼自己維護 metadata。\n如果想自己研究可以看 document。\nmetadata 是我們可以自訂的在每個節點儲存的有關它整個子樹的資訊，方便說明會用以下的問題作為舉例。\n 有 $N$ 個操作，每個操作可能是把一個整數加進集合裡面，或是詢問數字大小介於 $[l, r)$ 之內的數字總和。保證不會有已經在集合裡面的數字被加進去（i.e.數字全部相異）\n 我們將會使用下面這樣的 tree。\n1 2  using namespace __gnu_pbds; using BST = tree\u0026lt;int, null_type, less\u0026lt;int\u0026gt;, rb_tree_tag, my_node_update\u0026gt;;   my_node_update 是一個我們自行撰寫的型別：\n1 2 3 4 5 6 7 8 9 10 11 12  template\u0026lt;class Node_CItr, class Node_Itr, class Cmp_Fn, class _Alloc\u0026gt; struct my_node_update { typedef long long metadata_type; void operator()(Node_Itr it, Node_CItr end_it) { // ...  } long long query(int x) { // ...  } virtual Node_CItr node_begin() const = 0; virtual Node_CItr node_end() const = 0; };   其中，metadata_type 是每個節點維護的資訊的型別，Node_CItr 和 Node_Itr 分別是 const 的節點迭代器與節點迭代器，值得注意的是這種迭代器是指向迭代器的迭代器，也就是說 *it 的型別會是 tree::iterator 之類的，兩種迭代器有所不同（it與tree::begin()型別是不同的！）。\nvoid operator()(Node_Itr it, Node_CItr end_it) 方法有點類似 pull 的角色，當這個函式被呼叫，保證 it 的左小孩與右小孩的 metadata 都已經是正確的了，而你必須重新計算 it 的 metadata。it.get_l_child() 和 it.get_r_child() 分別是 it 的左小孩與右小孩，而如果左(右)小孩不存在則會設成與 end_it 相同。\n我們可以這樣寫：\n1 2 3 4 5 6 7 8 9 10  void operator()(Node_Itr it, Node_CItr end_it) { long long res = **it; Node_CItr lc = it.get_l_child(); Node_CItr rc = it.get_r_child(); if (lc != end_it) res = lc.get_metadata() + res; if (rc != end_it) res = res + rc.get_metadata(); const_cast\u0026lt;metadata_type\u0026amp;\u0026gt;(it.get_metadata()) = res; }   node_begin() 會回傳一個代表根的節點迭代器，而 node_end() 則是回傳一個代表空節點的節點迭代器（任何葉子節點的小孩都會是 node_end()）。\n我們希望 query(x) 回傳所有 $ \u0026lt; x$ 的數字總和，因此可以撰寫 my_node_update::query 如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  long long query(int x) { long long result = 0; Node_CItr it = node_begin(); while (it != node_end()) { int key = **it; if (key \u0026lt; x) { result += it.get_l_child().get_metadata(); result += key; it = it.get_r_child(); } else { it = it.get_l_child(); } } return result; }   所有 my_node_update 的 public 方法都可以在使用 my_node_update 的 tree 直接使用，因此我們可以直接像下面這樣使用我們定義完的 BST 型別。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  signed main() { ios_base::sync_with_stdio(0), cin.tie(0); int N; cin \u0026gt;\u0026gt; N; BST bst; for (int i = 0; i \u0026lt; N; i++) { string type; cin \u0026gt;\u0026gt; type; if (type == \u0026#34;QUERY\u0026#34;) { int l, r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; cout \u0026lt;\u0026lt; bst.query(r) - bst.query(l) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } else if (type == \u0026#34;ADD\u0026#34;) { int x; cin \u0026gt;\u0026gt; x; bst.insert(x); } } }   參考資料/延伸閱讀 https://zouzhitao.github.io/posts/pbds/\nhttps://gcc.gnu.org/bugzilla/show_bug.cgi?id=81806\nhttps://www.luogu.com.cn/blog/Chanis/gnu-pbds\nhttps://github.com/baluteshih/baluext/blob/main/baluext.h\n有任何筆誤請通知 m(_ _)m\n","permalink":"https://omeletwithoutegg.github.io/2021/07/23/pbds-split-join-is-slow/","tags":["binary-tree","data-structure","cpp","splay-tree"],"title":"PBDS Split Join Is Slow"},{"contents":"IOI 2021 只是想打一下IOI的心得而已\n可能還是流水帳請多多包含(?)\nBefore 其實到二模都還很擔心會不會當上國手，還有擔心自己的實力到底有沒有變強\n因為一模是因為靠奇怪互動線性遞迴的題目才上去，啊二模唯一寫出來的題目也是IOI根本不考的東西\n另外很好笑的是我這學期比前兩個學期還努力追學分，因為之前太混了XD這學期剛好要全部過才夠畢業的學分竟然夠了\n謝謝所有即使我交作業很混還是讓我過的老師!\n四模拿了一個不錯看的分數，如果我在國手線下150分甚至可以抵回來(?)因為這件事我大概可以claim二階很好追分(並沒有)\n因為疫情的關係國培燒雞，我超期待的說，還想說今年想再寫一次國培紀錄QQ\n唯一比較算是訓練的東西是tmt(卡恩)和我們google meet討論一些題目\n第一次meet的時候是先丟題目討論，然後也講了去年的模考題，像是expected LCS那題好像就是暴力DP(雖然我不知道複雜度是什麼)\nZCK真的超級積極，丟了好多POI或是JOI、CSAcademy的題目，好多題目我都是第一次見\n基本上沒有什麼想法，不過就算只是聽解也蠻困難的，有一些證明因為卡恩也是當場想所以有點久，我也沒注意聽就做自己的事了XD\n第二次meet主要討論IOI2019，有事前看過題目之後感覺就好一點了(?)不過因為一直想要把line得多一點分所以也沒有太專心(X\n感謝卡恩與zisk讓我腦袋有在動(?)\nDay0 看到好久沒看到的ZCK與wiwi還有(隔著口罩)呼吸到新鮮空氣心情還不錯\n晚上是練習賽\n題目都跟去年一樣\n唯一不一樣的是一題BFS\n結果還不能破台，好好笑\n不過差點在賽中因為唬爛弄出正解(?)\n結束之後問了一下ZCK解，果然他會只是剛好在兩小時的最後才想到(?)\nDay1 day1前一天打了一場div.2寫完ABCD看完F猜他的式子很漂亮就亂推AC了 然後E寫好久總算寫完\n這讓我感覺狀態還不錯，對我來說可能寫水題也是一個穩定心情的方法(?)\n我們三個人還有監考人員占用一整個會議室，間隔開來坐\n原本是用acer的筆電但是後來變成msi的樣子，因為好像跑比較快\n開賽的時候先打了模板\nZCK帶來的鍵盤的聲音來讓人滿是壓力XD\n然後看紙本題目想\n然後\u0026hellip;就沒有然後了\nparks看起來有點困難先放著了一下\ncandies看起來就很經典題，而keys也是沒有什麼想法\n一直畫圖交替想兩題，大概花了一小時還是沒有什麼想法\n三個人維持了安靜好久，然後ZCK開始動鍵盤的時候有夠可怕\n只好姑且先去撈分，撈了keys的基本分跟candies的一點分數\n仔細看了parks發現可以弄成類似2SAT的東西不過實作異常麻煩，而且我也忘記tarjan怎麼寫甚至跑去寫kosaraju(?)\n不過花了好久拿到了70分，我覺得還算值得\n接下來就繼續把candies的分數撈一撈，有一個subtask似乎是我唬爛得到的分數賽後才發現，唬爛就是爽\n最後一直在想candies $l=0, r=n-1$ 的subtask就結束了\n結束之後有點怕自己又是銅牌命，趕快問分數，結果大家都一樣好好笑，而且都是銀牌左右的分數，看來 day1 實在蠻難的\nDay2 day1/2中間似乎吃了雙豚還是山嵐\nday2前一天因為睡不著跑去看了IOI2014之類的，然後發現做不出來趕快看解以免影響比賽，好好笑\n心中不想太多的雜事，很快就開賽了\n打完模板開始讀題目，然後就遇到很欠嘴砲的水題(?)大概在25分鐘內就AC了，有點帶給我小小信心(X\n剩下兩題開始讀\nregisters實在有點長，當然只能先去看dungeons\n因為想說贏了好像強度就會加倍，所以原本想說只會贏log次，寫到一半突然覺得怪怪\n後來發現應該是「贏了輸過的人的話那麼強度會加倍」，然後就不知道怎麼做了\n跑去讀registers題敘發現實在超級長，結果是要實作取min跟排序，感覺就是跟19的vision或是12的odometer這種題一樣噁心\n想一想覺得應該可以做很多平行化，而且去年的國培蔡孟宗甚至還講過平行化的bitonic sort，結果今年沒國培，好慘\n先做了取min的subtask，實作比較的方式我是先做減法，然後就可以有絕對值，就有min了\n平行化大概需要170個操作左右，和最後一個subtask要求150只差一點但是怎麼都壓不過，傷心\n後來看著dungeons一直想他怎麼樣會加倍，突然就想到2的冪次分層\n也就是說如果現在的強度 $z\\in[2^i,2^{i+1})$ 就說現在在第 $i$ 層，那一定會輸 $2^{i+1}$ 以上的人、贏 $2^i$ 以下的人，而一旦贏了中間的人就會跳到下一層!\n啊待在某一層的時候一定是一直輸大的、贏小的直到贏了一個大的，因為是一張functional graph所以可以用倍增法\n總之整理了一下寫寫倍增法就有了時間 $(n+q)\\log^2C$ 空間 $n\\log^2C$ 的解，不過 $n=400000$ 開不下，開 $n=50000$ 丟上去六十幾分覺得還不錯\n後來測了一下發現記憶體少一點就可以開得下了，所以嘗試壓常(?)原本想說用分根號、立方根的，後來發現可以開到 $10n\\log C$ 的記憶體就想說可以一次跳 $(10^7)^{\\frac{1}{10}}$ 倍，然後一直亂改改就 AC 了??\n這應該是第一次在賽中遇到二的冪次分層，實在覺得出出這些題目的人都很厲害\n比賽最後在努力修改 registers 的情況下結束，可惜沒有再撈到分數\n比賽結束的時候聽到ZCK跟balbit分數都沒有很好，覺得很可惜，而且看到scoreboard大家的名次都在30~40名內，真的覺得有夠可惜qwq\n原本想說自己會銀牌，沒想到看scoreboard竟然有30名內，還真的是很開心\n真的是很有趣，因為聽說我的dungeons的空間是壓常而不是預期複雜度，因為壓常而得金實在是沒有想到XD\n不過就很好奇到底怎麼不用倍增法或是HLD在functional graph上面做類似二分搜的事情了OAO，我只能理解可以用HLD讓空間是 $\\mathcal{O}(n)$ 但是HLD可是超出IOI syllabus的(?)\n晚上買了sukiya，好感動。\nAfter 對於一開始的擔心，我覺得可能是有道理的，我們幾個人的實力和一年前比起來一定都有成長，但題目和其他選手也都比去年的他們厲害，我想能得到金牌無非還是一種好運吧！一個人的實力是一個浮動的區間，剛好想到怎麼壓常也是一種緣分吧\n在二階左右的時候常用的筆電被我不小心摔壞了螢幕，現在先用暫時用的筆電，還好我的部落格好好放在github上可以好好修改(?)\n我覺得IOI有點是給我一個理由耍廢不做事有點心虛\n最近又有好多事情要做，例如趕完APCS camp的投影片XD 不過這樣也好，人生不找點事情做會無聊死，忙著不去胡思亂想還好多了。\n最近和ot他們第一次團練ICPC，感覺我有夠菜，希望能好好融入他們\n本來想這篇心得要不要打得像是 baluteshih 那篇心得一樣長，不過我好像不擅長鋪陳也不擅長回想所以就作罷了吧\n好久沒有更新部落格了，大概慢慢就不太更新了吧\n","permalink":"https://omeletwithoutegg.github.io/2021/07/01/IOI2021/","tags":["IOI","experience"],"title":"IOI2021"},{"contents":"這裡是放各種友情連結(X)\n其他人的 blog  https://www.wiwiho.me/ https://www.jikuai.codes/ https://fhvirus.github.io/ https://casperwang.pages.dev/ https://erdone.github.io/ https://emanlaicepsa.github.io/ https://simba-fs.github.io/ https://blog.tommydong.live/  年久失修（？）的 blog 其實我猜我的 blog 很快也要年久失修ㄌ\n https://brian.su/ https://codingsimplifylife.blogspot.com/ http://sunmoon-template.blogspot.com/ http://cbdcoding.blogspot.com/ https://oi.ototot.tw/ https://tmt514.github.io/blog http://baluteshih.blogspot.com/  for 競程的工具  OI checklist CF, TIOJ, AtCoder USACO Guide Draw Graph Library Checker vim、vim-plug  蹭熱度蹭起來啦。雖然不知道這樣算不算蹭。\n","permalink":"https://omeletwithoutegg.github.io/resources/","tags":[],"title":"Resources"},{"contents":"本篇將會介紹快速求線性遞迴數列某項的方法，以及Berlekamp-Massey演算法和一些在矩陣上的應用。\n主要是一個整理資料還有學習筆記的功能，還有老實說這東西算是偏門又毒瘤，追求實用的人不要看XD。\nFast Linear Recurrence 首先先來介紹如何快速求線性遞迴。\n定義  已知序列 $ \\langle a_n \\rangle $ 滿足遞迴關係 $ \\displaystyle \\forall i \\geq k, a_i = \\sum _ {j=0} ^ {k-1} s _ j a _ {i-1-j} $ ，並且已經給定 $s$ 跟 $a_0, a_1, \\dots, a _ {k-1}$\n現在想要求 $ a_n $ 的值，其中 $ 1 \\leq k \\leq 5000, 0 \\leq n \\leq 10^9 $\n 許多人大概會很快想到矩陣快速冪，複雜度是 $ \\mathcal{O}(k^3 \\log n) $。但我們要更快！\n通靈 定義一個函數 $G$，對於形式冪級數 $f(x) = \\sum c_i x^i, G(f) = \\sum c_i a_i$ 。\n顯然$G(f \\pm g) = G(f) \\pm G(g)$。\n根據 $s$ 構造一個多項式 $S$\n$$\nS(x) = x^k - \\sum _ {i=0} ^ {k-1} s_i x^{k-1-i}\n$$\n可以發現 $G(S) = 0$，因為代進去正好是 $a_i - \\sum\\limits _ {j=0} ^ {k-1} s _ j a _ {i-1-j} = 0 $。\n而且，平移之後也會滿足遞迴關係，所以 $G(Sx) = G(Sx^2) = \\dots = 0$。\n由上面兩條可以得知，對於任何多項式$f$都有$G(Sf) = 0$。\n我們想求的第$n$項，正好就是$G(x^n)$，不妨取 $\\displaystyle f = \\lfloor \\frac{x^n}{S} \\rfloor$，則$G(x^n) = G(x^n - Sf) = G(x^n \\mod S)$。\n上述$\\lfloor \\frac{x^n}{S} \\rfloor$ 和 $x^n \\mod S$ 分別是多項式帶餘除法的商和餘數。\n結論 證明也很快。\n總而言之，只要求得$x^n \\mod S$（注意這個東西的degree是$\\mathcal{O}(k)$），再帶進$G$就能得到 $a_n$！\n可以對$n$做類似快速冪的事情，每次算$x^{n/2} \\cdot x^{n/2} \\mod S$之類的，如果是mod質數的話，甚至可以利用FFT或是NTT來快速多項式帶餘除法作到總複雜度 $\\mathcal{O}(k\\log k \\log n)$，不過超出今天的篇幅所以這邊只放$\\mathcal{O}(k^2 \\log n)$的寫法。\n老實說$\\mathcal{O}(k^2)$的$\\mod S$比想像中好寫，只要從大到小不斷把$x^k$換成$ \\sum\\limits _ {i=0} ^{k-1} s_i x^{k-1-i}$ 就好\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  template \u0026lt;typename T\u0026gt; T fastLinearRecurrence(vector\u0026lt;T\u0026gt; a, vector\u0026lt;T\u0026gt; s, int n) { if (n \u0026lt; (int)a.size()) return a[n]; if (s.empty()) return 0; // a 是前 k 項， s是遞迴關係，  // a[i] = \\sum s[j] * a[i-j-1]  vector\u0026lt;T\u0026gt; r = {1}; // 1  vector\u0026lt;T\u0026gt; e = {0, 1}; // x;  auto mul = [\u0026amp;s](vector\u0026lt;T\u0026gt; a, vector\u0026lt;T\u0026gt; b) { // return a * b % (x^k - s)  vector\u0026lt;T\u0026gt; c(a.size() + b.size() - 1); for (size_t i = 0; i \u0026lt; a.size(); i++) for (size_t j = 0; j \u0026lt; b.size(); j++) c[i+j] += a[i] * b[j]; for (size_t i = c.size()-1; i \u0026gt;= s.size(); i--) for (size_t j = 0; j \u0026lt; s.size(); j++) c[i-j-1] += c[i] * s[j]; c.resize(s.size()); return c; }; while (n) { if (n \u0026amp; 1) r = mul(r, e); e = mul(e, e); n \u0026gt;\u0026gt;= 1; } T sum = 0; for (size_t j = 0; j \u0026lt; r.size(); j++) sum += r[j] * a[j]; return sum; }   上面的T可以是double或是自定義的同餘算術型別。\n不過這其實有點不太實用。通常這種線性遞迴數列的遞迴式基本上長度都是超小的常數，而需要交給電腦推的遞迴式通常都是形如$v _ i = A^i v _ 0$的形式，也就是說有很多個狀態要一起考慮，沒辦法想成單一變數的線性遞迴形式，矩陣快速冪的通用性還是比較高。後面也許會提到這種東西要怎麼算得比矩陣快速冪還快，不過如果$A$不是稀疏的也只是少一個$\\log$而已。\nBerlekamp-Massey 演算法 這東西可神奇了，可以說是弱化版的OEIS。不過還有很多神奇的應用。\n以下簡稱Berlekamp-Massey演算法為BM演算法。\n定義  給定一個序列 $ a_0, a_1, \\dots, a _ {n-1} $ ，請找出一個階數最小的線性遞迴關係 $ \\langle s _ i \\rangle $ ，\n使得 $ \\forall i \\geq k, a_i = \\sum\\limits _ {j=0} ^ {k-1} s _ j a _ {i-1-j} $。其中 $k$ 即是此線性遞迴關係的階數。\n 當然，求出來的遞迴關係可能不是是唯一解，也不知道能不能對應到原本的遞迴式。\n不過可以證明，如果已知遞迴式的階數最多是 $k$ 的話，只要取前 $2k$ 項求解得到一個遞迴關係之後，任何更長的前綴都會吻合該關係，也就是說該關係是整個無限數列的最短遞迴式。\n證明請看2019 IOI中國國家隊論文\u0026hellip;\n步驟 BM演算法包含了一些迭代法跟greedy的思維。我們由短到長逐步考慮每個前綴 $[0 .. i]$ ，假如第 $i$ 個數字加進去之後和舊的遞迴關係不吻合，我們就修正該遞迴關係。一開始遞迴式 $s$ 初始化為空。\n修正的部份可以分成兩個case：\n 不是第一次修正。\n假設這次誤差叫做 $\\varepsilon$ 好了，也就是 $a_i - \\sum _ {j=0} ^ {k-1} s _ j a _ {i-1-j} = \\varepsilon$\n因為不是第一次修正，所以設之前有一次是在加入第 $i'$ 個數字後修正的，該次修正之前的遞迴式為$s'$，誤差為 $\\varepsilon'$。也就是說，$a _ {i'} - \\sum _ {j=0} ^{k'-1} s' _ j a _ {i'-1-j} = \\varepsilon'$\n可以發現，$\\frac{\\varepsilon}{\\varepsilon'} (a _ x - \\sum _ {j=0} ^ {k'-1} s' _ j a _ {x-1-j})$是一個僅在 $x = i'$ 是 $\\varepsilon$，其他位置是 $0$ 的序列。在 $s'$ 前面補 $0$ ，使得前面的項都不會被影響到，而第 $i$ 項恰好對到 $\\varepsilon$ 那一項，如此兩者相消就能讓第 $i$ 項的誤差變為 $0$ 。也就是說，如果當前的 $s$ 出錯了，我們就會把 $s$ 加上「之前某次的 $s'$ 乘上若干倍再平移」以修正該次的誤差。\n總之就是取前面算過的東西拿來消掉新加入的項的誤差啦。至於 $i'$ 的取法似乎是要讓要補的 $0$ 盡量少，最後的結果才會是最短的遞迴式。\n在下面的 code 中， bestPos維護的是最好的 $i'$ ； best 維護的是最好的 $s'$ ，取負號之後前面補 $1$ ，然後除以 $ \\varepsilon' $ 第一次修正\n表示 $i$ 是第一個非零元素，將 $s$ 修正為 $i+1$ 個 0 ，表示前 $i+1$ 項應該會是在給定的 $k$ 項之中。\nbest 更新成單項式 $1 / \\varepsilon$  總之code雖然很簡潔，但好難懂\u0026hellip;\n複雜度是 $\\mathcal{O}(n^2)$。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  template \u0026lt;typename T\u0026gt; vector\u0026lt;T\u0026gt; BerlekampMassey(vector\u0026lt;T\u0026gt; a) { auto scalarProduct = [](vector\u0026lt;T\u0026gt; v, T c) { for (T \u0026amp;x: v) x *= c; return v; }; vector\u0026lt;T\u0026gt; s, best; int bestPos = 0; for (size_t i = 0; i \u0026lt; a.size(); i++) { T error = a[i]; for (size_t j = 0; j \u0026lt; s.size(); j++) error -= s[j] * a[i-1-j]; if (error == 0) continue; if (s.empty()) { s.resize(i + 1); bestPos = i; best.push_back(1 / error); continue; } vector\u0026lt;T\u0026gt; fix = scalarProduct(best, error); fix.insert(fix.begin(), i - bestPos - 1, 0); if (fix.size() \u0026gt;= s.size()) { best = scalarProduct(s, - 1 / error); best.insert(best.begin(), 1 / error); bestPos = i; s.resize(fix.size()); } for (size_t j = 0; j \u0026lt; fix.size(); j++) s[j] += fix[j]; } return s; }   BM 演算法的應用！ 方便起見，接下來會用SLR簡稱「最短遞迴式」。\n終於來到我最想分享的部份。前面code可以直接當模板抄啦，就跟Dinic一樣神秘。\n但是重點在於怎麼活用BM演算法。BM演算法對於矩陣，尤其是稀疏矩陣的相性特別好。\n這裡大部分都是IOI 2019中國國家隊的論文來的www\n向量/矩陣的SLR 一些 $n$ 維向量 $ \\{ v_0, v_1, \\dots, v _ {n-1} \\} $ 的SLR怎麼求？答案是隨機生成一個向量 $u$ 跟他做內積，改求 $ \\{ u^T v_0, u^T v_1, \\dots, u^T v _ {t-1} \\} $ 的 SLR。可以證明乘上 $u$ 之後，SLR不變的機率至少是 $1 - \\frac{n}{p}$ （$p$ 是模的質數）。類似的，一些 $m \\times n$ 矩陣 $ \\{ A_0, A_1, \\dots, A _ {t-1} \\} $ 的 SLR 求法就是生成隨機向量 $u, v$ 拿去左邊右邊乘，改求 $ \\{ u^T A_0 v, u^T A_1 v, \\dots, u^T A _ {t-1} v \\} $的SLR。正確的機率似乎至少是 $1 - \\frac{n+m}{p}$ 。\n證明用到了一個我完全不會的 Schwartz-Zippel 引理。哪那麼衰XD\n稀疏線性方程組 求解 $Ax = b$ 即是想得到 $x = A^{-1}b$ 。考慮 $ \\{ A^0b, A^1b, A^2b \\dots, \\} $ 的SLR，可以得知\n$ A^kb = \\sum _ {i=0} ^ {k-1} s _ {k-1-i} A^ib $。兩邊同乘 $A^{-1}$ 並移項之後可以得出\n$$\nA^{-1}b = -\\frac{1}{s _ {k-1}}(A^{k-1}b - \\sum _ {i=1} ^ {k-1} s _ {k-1-i} A^{i-1}b)\n$$\n注意到 $s _ {k-1} \\neq 0$，否則他就不可能是最短。\n如果 $A$ 是稀疏的，裡面有 $e$ 個非零元素，那麼依序推出 $ A^0b, A^1b, \\dots, A^{2n-1}b$ 就只需要 $\\mathcal{O}(n(n+e))$。\nIOICAMP似乎有一題可以用這個搶topcoder\n稠密的轉移矩陣 在前面某一段有提到，轉移長度如果不是很小的常數的話，常常會寫成像是 $v_i = A^iv_0$ 的形式，其中 $A$ 是 $n$ 階方陣而 $v_i$ 是 $n$ 維向量，我們想求的是 $v_k$。\n直接利用矩陣快速冪的方法是 $n^3 \\log k$ 的。不過，我們只需要求出前 $2n$ 項的SLR，再利用前述的 fast linear recurrence 就能得到第 $k$ 項。（不過可能要稍微改寫一下求出$x^k \\mod f$之後帶進$G$的部份）可以依序求出 $v_0, v_1, \\dots, v _ {2n-1}$，複雜度 $\\mathcal{O}(n^3)$，後面的fast linear recurrence複雜度大概是 $\\mathcal{O}(n^2\\log k)$之類的。\n例題可以去試試TIOJ 1892 owo\n矩陣的最小多項式 一個 $n\\times n$ 方陣 $A$ 的最小多項式是 degree 最小的 $p$ 使得 $p(A) = 0$ 。By Cayley Hamilton theorem，特徵多項式正好也是一個多項式 $p$ 使得 $p(A) = 0$ ，所以最小多項式的 degree 至多是 $n$。\n如何求？最小多項式 $p(A) = \\sum c_i A^i$ ，可以發現只要求 $ \\{ A^0, A^1, A^2, \\dots \\} $ 的 SLR 就能得到最小多項式。又，最小多項式至多 $n$ 項，故取前 $2n$ 項計算即可得到答案。\n稀疏矩陣行列式 給定一個稀疏矩陣$A$想求$\\det(A)$。事實上只要求得特徵方程式的常數項就可以得到行列式。\n根據 wiki 上 Cayley Hamilton 定理的頁面，最小多項式是特徵多項式的因式，但他們可能不相等，不過他們的根集合是相同的，問題只是特徵多項式裡可能有重根。因此我們把$A$乘上一個隨機的對角矩陣$B$，可以證明$AB$沒有重根（特徵多項式與最小多項式相等）的機率至少是 $1 - \\frac{2n^2 - n}{p}$。似乎同樣又是Schwartz-Zippel。\n總之，求得 $AB$ 的特徵多項式 $p$ ，並設 $p$ 的領導係數是 $1$ （如果不是就除掉），那麼 $\\det(AB)$ 就是 $(-1)^{|A|} \\cdot p(0)$ 也就是 $p$ 的常數項差一個正負號。 $\\det(A) = \\det(AB) / \\det(B)$ 就完成了。\n這個是之前打BambooFoxCTF google and copy過別人的XD現在才來完整了解作法\nReference https://codeforces.com/blog/entry/61306\nhttps://www.cnblogs.com/zzqsblog/p/6877339.html\nhttps://github.com/enkerewpo/OI-Public-Library/blob/master/IOI%E4%B8%AD%E5%9B%BD%E5%9B%BD%E5%AE%B6%E5%80%99%E9%80%89%E9%98%9F%E8%AE%BA%E6%96%871999-2019/%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F2019%E8%AE%BA%E6%96%87%E9%9B%86.pdf\n註：我遞迴、遞推等等用詞都搞不太清楚，不過我猜不重要吧XD\n越來越毒的感覺了，該把路矯正回來喇ww\n不知道會有多少人仔細看？抓typo不要鞭太用力QQ\n","permalink":"https://omeletwithoutegg.github.io/2021/02/13/linear-recurrence/","tags":["template","math"],"title":"線性遞迴淺淺談"},{"contents":"IOIC 2021 去年就來過一次了，今年再次造訪這困難的營隊。\n其實幾乎沒有什麼特別不一樣的地方，不過我想說還是寫個短短的紀錄。\n吃的東西 IOIC有準備早餐、午餐跟晚餐讓我們不用擔心時間太可怕的問題（？）\n然後還有下午的點心，大致上都不錯吃，除了有魚刺的便當QQ\n可惜的是去年會在吃東西的時候放影片，今年可能是因為疫情怕我們吵雜起來，甚至還讓我們坐梅花座。\n上課 這次上課的主題和去年比較起來，好像少了常數優化、隨機、分塊之類的，但是多了flow跟game theory。\n老實說很多東西都是聽過但是不那麼熟QQ\n喵喵時間不知道選訓有沒有機會再聽到一次(X\n而且講義幾乎都是「參考」前幾年的（雖然本來就應該要這樣，滾動式稍微有更新就好）\n這次覺得比較有聽到的應該是burnside lemma跟flow還有賽局的東東。雖然賽局的題目好像都跟上課沒什麼關係QQ只要會mex跟xor和通靈（重要）就好。\n模擬賽 第一天趣味賽還可以，賽到一個隨機bubble sort的debug題\n接下來兩天天都爆炸，真的是實力檢討大會QQ\n第四天個人賽其實還不錯，但是就輸balbit，最後忙著猜pA來不及想I或是H QQ通靈難死\n第五天，放鬆打（？）反正好幾個人都在我們上面習慣了。\n這種長時間的比賽幾乎大家的開題都差不多，然後我很習慣用subtask來確認有沒有寫錯，只有整題的feedback超難@@\n最後差一點用題數贏，不過輸在就是輸在DP沒有想好QQ\n發獎品的時候拿到的是除蟲網（？）是不是要成為AY傳人了(#\n賽後補題 基本上快把全部的題目都補完了，剩下兩題吧（？）\n在IOIC的judge搶topcoder好好玩，尤其是在用毒瘤演算法的時候XD\n老實說上課幾乎都在刷題或是補題，我覺得這樣也許有點糟糕，不過我相信補題也是一種收穫。\n","permalink":"https://omeletwithoutegg.github.io/2021/02/06/IOICamp-2021/","tags":["experience","IOIC"],"title":"IOICAMP 2021"},{"contents":"jngen 最近在生107北市賽題目的測資想放到TIOJ上面，其中一題是關於找兩個凸包的兩條內公切線交點。\n因為不太知道測資怎麼生，又想到之前東東有提過jngen這個東西，因此就把他拿來生成我需要的凸包了。\n我覺得他的函式、方法都很乾淨，然後因為生測資仔細看了一下文件，就想說把他貼到部落格推廣一下（X\nUsage https://github.com/ifsmirnov/jngen\n要使用jngen，你只需要下載jngen.h並引用標頭檔。下載來的標頭檔可以放在 /usr/include 之類的地方，或是跟你的C++原始碼相同目錄當中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  #include \u0026#34;jngen.h\u0026#34;#include \u0026lt;iostream\u0026gt; using std::cout, std::endl; int main(int argc, char *argv[]) { registerGen(argc, argv); parseArgs(argc, argv); int n, m; getPositional(n, m); Tree t = Tree::bamboo(n).link(n - 1, Tree::star(m), 0); if (getOpt(\u0026#34;shuffled\u0026#34;, false)) { t.shuffle(); } cout \u0026lt;\u0026lt; t.printN().add1() \u0026lt;\u0026lt; endl; }   下面只會挑這次有用到的主題帶過一些函數，我這次完全沒用到字串、圖論、數學的函式庫。\nRandom jngen跟testlib一樣會使用你執行時傳入的參數做一些hash之類的當作偽隨機的種子，所以如果不是每次呼叫main都用不同參數呼叫，就得乾脆把一個種子在一個generator裡面重複利用。\n記得在main裡面呼叫registerGen(argc, argv)。\nrnd rnd是一個全域物件，可以呼叫rnd.next(l, r)之類的方法來取得隨機數字。這些方法大部分跟testlib相容。\n rnd.next(int n) 生成 $[0, n)$ 的隨機數字 rnd.next(int l, int r) 生成$[l, r]$的隨機數字 rnd.nextf() 生成$[0, 1)$的隨機浮點數 rnd.wnext(int n, int w)、rnd.wnext(int l, int r, int w) 在$w \u0026gt; 0$的時候會取$w$次隨機的結果取$\\max$，在$w \u0026lt; 0$的時候則是取$\\min$。 rnd.nextp(int n, [RandomPairTraits])、\nrnd.nextp(int l, int r, [RandomPairTraits]) 回傳一個pair，兩個數字都介在範圍之內。RandomPairTraits是可選參數，像是  opair: ordered pair，保證first \u0026lt;= second dpair: distinct pair，保證first != second odpair, dopair: 保證first \u0026lt; second    Option 跟testlib一樣，他也提供了command-line執行參數的parser。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  // ./main 10 -pi=3.14 20 -hw hello-world randomseedstring int main(int argc, char *argv[]) { parseArgs(argc, argv); int n, m; double pi; string hw; n = getOpt(0); // n = 10  pi = getOpt(\u0026#34;pi\u0026#34;); // pi = 3.14  n = getOpt(5, 100); // n = 100 as there is no option #5  pi = getOpt(\u0026#34;PI\u0026#34;, 3.1415); // pi = 3.1415 as there is no option \u0026#34;PI\u0026#34;  getPositional(n, m); // n = 10, m = 20  getNamed(hw, pi); // hw = \u0026#34;hello-world\u0026#34;, pi = 3.14  cout \u0026lt;\u0026lt; (int)getOpt(\u0026#34;none\u0026#34;, 10) \u0026lt;\u0026lt; endl; // 10 as there is no \u0026#34;none\u0026#34; option }   呃\u0026hellip;沒什麼好說的，一看就懂。如果出了什麼錯誤會報錯，例如找不到這個選項而且沒有預設值，或是轉型出問題。\nArray 這好嗎？這很好。\nArray是包裝過後的std::vector，重載了輸入輸出的運算子，讓我們不再需要重複撰寫 cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026quot; \\n\u0026quot;[i+1==n] 這種程式碼。並且，他在輸出的時候可以簡單的增加選項，例如印出陣列長度或是shuffle、sort、reverse、unique等等，都快變成python了。\n有頗多方法，首先是生成隨機Array的方法。\n Array::id(size_t n)和iota類似回傳依序包含0~n-1的Array。 Array::random(size_t n, Args ...args)回傳每個元素各自以rnd用args參數隨機生成的一個Array。 Array::randomUnique(size_t n, Args ...args) 和前者類似，但回傳元素完全不相異的Array。注意如果生成失敗會throw錯誤。 Array::randomf(size_t n, Func func, Args ...args)回傳每個元素各自以func用args參數生成的一個Array。  接著是型別為Array的變數或是暫時變數後面可以加的一些方法，有點像是形容詞之類的，作者叫output modifier（？）\n以下假設該變數叫a\n a.shuffle()、a.shuffled() 前者shuffle自己並回傳reference，後者回傳一個shuffle過的物件。 a.sort()、a.sorted()、 a.unique()、a.uniqued()、 a.reverse()、a.reversed() 可以類推。 a.inverse() 回傳一個排列的inverse。如果該陣列不是一個排列會throw錯誤。 a.choice()、a.choice(size_t count) 隨機取出一個或 count 個元素。 a.printN() 印出陣列大小。 a.add1() 把陣列內容+1，在0-base轉1-base有用。 a.endl() 原本每項之間是以空白分隔改為以換行分隔。  還有用+、+=可以串接Array，*、*=會重複原本的內容數次，跟python的list有點像。\n此外，一樣可以存取begin、end然後用想要的STL做事情。\n1 2 3 4 5  void gen(int n, int c) { auto p = Array::id(n).shuffled(); auto a = Array::random(n, c); cout \u0026lt;\u0026lt; p.printN() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }   Geometry rndg也是一個全域物件，提供生成幾何物件的方法。\n主要分成三大類函數：生成一個隨機點、生成一個隨機凸多邊形、生成$n$個三點不共線的點\n  rndg.point(long long C)、\nrndg.point(long long min, long long max)、\nrndg.point(long long x1, long long y1, long long x2, long long y2) 回傳範圍內隨機的一個整數點，型別是Point。\n  rndg.pointf 跟 rndg.point 類似但回傳浮點數型態的。\n  Point 型別可以做加減法、內外積（*跟%運算子）、純量積、字典序比大小、比較是否等於\n  rndg.convexPolygon(int n, long long C)、\nrndg.convexPolygon(int n, long long min, long long max)、\nrndg.convexPolygon(int n, long long x1, long long y1, long long x2, long long y2) 回傳每個點都在範圍內的整數點隨機多邊形。型別是Polygon。\n  Polygon基本上是繼承一個Point的Array，並且有shift(), shifted()方法可以平移整個多邊形，或是reflect(), reflected()方法對原點鏡射。\n  rndg.pointsInGeneralPosition(int n, long long C)、\nrndg.pointsInGeneralPosition(int n, long long min, long long max)、\nrndg.pointsInGeneralPosition(int n, long long x1, long long y1, long long x2, long long y2) 回傳$n$個點使得沒有任兩點相同且任三點不共線。複雜度$\\mathcal{O}(n^2\\log n)$。型別是TArray\u0026lt;Point\u0026gt;\n  Drawer 拿來畫svg檔案的。沒有一個全域物件，必須自己宣告Drawer d。\n d.point() 畫點。可以填Point物件，pair或是兩個int d.circle() 畫圓，最後一個參數是半徑。可以填Point物件，pair或是兩個int d.segment() 畫線段。可以填兩個Point、兩個pair或是四個int d.polygon() 畫多邊形。注意他只是連續的線段，所以順序要自己弄好。可以傳Polygon物件，vector\u0026lt;Point\u0026gt;，vector\u0026lt;pair\u0026gt;等等 d.dumpSvg(\u0026quot;image.svg\u0026quot;) 把這個畫布上面的東西存到image.svg裡面  感想 引用別人的模板真的讓自己的程式碼乾淨很多\n像是整理成這樣就感覺到一種先進感，也感覺終於稍微活用shell script。\n之前原本是用shell script管理整個生測資的流程，後來覺得既然要寫for迴圈為什麼不乾脆放在C++裡面，就搞得像是把C++當成腳本語言在寫。現在這樣分成好幾個資料夾並且用script管理他們的編譯、執行感覺就乾淨多多！\n本來是想說這根本完美懶人出題標頭檔吧？\n後來出到最後一題才發現有些應該要有東西還是得自己寫QQ\n像是隨機的二維陣列吧，或是zip兩個陣列之後變成pair的陣列吧，這些功能都沒有qwq\n（更新：隨機的二維陣列其實有很乾淨的寫法）\n1 2  // generates n*m 2d array Array2d a = Array2d::randomf(n, [\u0026amp;](){ return Array::random(m, maxc); });   寫這篇的時候又再查了怎麼生成凸包，發現stackoverflow有一個更正道的作法而不是jngen這樣用橢圓唬爛（？）不過都不知道他們生成的效果怎麼樣，反正我猜北市賽測資不會好到哪裡去啦XD\n這篇其實沒有很完整，畢竟他的feature很多，要把整篇document翻完等有空再說吧www而且作者似乎也停更ㄌQQ\n","permalink":"https://omeletwithoutegg.github.io/2021/01/24/jngen/","tags":["template","experience","cpp"],"title":"jngen"},{"contents":"BambooFox CTF 2021 這次是第二次參加BambooFox，不過事前都沒有做什麼練習wwww本來想說去OT之前推薦過的網站練習一些基礎，但是忘記是什麼網站了888\n依然是跟joy一隊，然後另一個隊友變成casper了\n今年似乎是大進步，不過我懷疑只是因為考很多演算法題orz\n來講一些有解的題目，很抱歉我不知道怎麼讓我的code折疊起來XD\nGamer\u0026rsquo;s Cipher 一開場先開了 P versus ♯P，雖然查到解法可是精度跟速度都壓不過去，所以只好放棄改開別題。\n然後第一個成功的題目就是Gamer\u0026rsquo;s Cipher這一題。\ncasper說看懂code就解完了（？）不過他沒辦法編譯所以也不知道怎麼辦。\n總之我也跑去下載code看，然後查了好一下子怎麼編譯Haskell（記得編譯要加-dynamic的flag），成功編譯之後努力看懂code。\n看起來像是用Nimber對字串加密，\n明文和密文的長度都是$n=51$，然後他的key必須要是$n$階的原根，所以我寫了一個腳本看哪些是合法的key。\n1 2 3 4 5 6 7 8  #!/bin/bash # search possible keys len=51 printf \u0026#34;len = %d\\n\u0026#34; $len for i in $(seq 0 255); do echo $i printf \u0026#34;%51s\\n%d\\n\u0026#34; \u0026#39;\u0026#39; $i | tr \u0026#34; \u0026#34; \u0026#34;a\u0026#34; | ./Main 2\u0026gt;/dev/null \u0026gt;/dev/null \u0026amp;\u0026amp; printf \u0026#34;i = %d\\n\\n\u0026#34; $i \u0026gt;\u0026gt; possible.txt done   但是關鍵的加密部份怎麼樣都不確定我看的對不對，所以我先把nimber的乘法表弄成一個文字檔存起來，再另外寫一個python跟Haskell的輸出比對\n整理一下之後發現，欸這個式子不就是傅立葉轉換嗎？！（而且還是用Nimber做DFT，酷爆）就想說可能要用多項式插值或是寫inverse FFT\n之後用python寫inverse DFT寫掉了，基本上只要把key的乘法反元素找出來帶進去傅立葉轉換的式子就好了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  #!/bin/bash # build multipication table # Main.hs: # main :: IO () # main = do # a \u0026lt;- readNim # b \u0026lt;- readNim # print (a * b) # cat /dev/null \u0026gt; multable.txt for i in $(seq 0 255); do echo $i for j in $(seq 0 255); do printf \u0026#34;%d\\n%d\\n\u0026#34; $i $j | ./Main \u0026gt;\u0026gt; multable.txt done done   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75  A = [[0 for j in range(256)] for i in range(256)] with open(\u0026#39;multable.txt\u0026#39;, \u0026#39;r\u0026#39;) as f: f.readline() for i in range(256): for j in range(256): A[i][j] = int(f.readline()) # print(A) def div(a, b): for i in range(256): if A[i][b] == a: return i return -1 def mul(a, b): return A[a][b] def add(a, b): return a ^ b def power(val, n): # binpow? res = 1 for i in range(n): res = mul(res, val) return res # print(\u0026#34;div(1, 65) = \u0026#34;, div(1, 65)) # print(\u0026#34;div(1, 51) = \u0026#34;, div(1, 51)) def encrypt(message, key): n = len(message) pows = lambda val: [power(val, i) for i in range(n)] keys = pows(key) coef = [mul(message[i], keys[i]) for i in range(n)][::-1] res = [0 for i in range(n)] for i in range(n): s = 0 pv = pows(keys[i]) for j in range(n): s = add(s, mul(coef[j], pv[j])) res[i] = add(keys[i], s) print(coef) # print(res) return res def decrypt(res, key): n = len(res) pows = lambda val: [power(val, i) for i in range(n)] keys = pows(key) # coef = [mul(message[i], keys[i]) for i in range(n)][::-1] coef = [0 for i in range(n)]; for i in range(n): pv = pows(keys[n-i if i \u0026gt; 0 else 0]) s = 0 for j in range(n): s = add(s, mul(add(res[j], keys[j]), pv[j])) coef[i] = s # print(coef) message = \u0026#39;\u0026#39; for i in range(n): message += chr(div(coef[n-1-i], keys[i])) print(message) # t = encrypt([i for i in range(51)], 65) # decrypt(t, 65) # exit() sec = [13,1,114,230,244,145,218,78,204,36,81,48,148,35,40,50,78,40,88,43,122,39,41,149,208,208,191,68,65,61,224,140,18,239,104,210,110,119,178,27,173,253,15,237,85,192,82,74,148,15,250] # res = encrypt([ord(c) for c in input()], int(input())) ks = [102, 122, 125, 132, 140, 147, 150, 154, 159, 166, 172, 176, 180, 187, 191, 195, 196, 200, 207, 213, 216, 225, 239, 242, 244, 251, 253, 65, 69, 83, 86, 96] for k in ks: decrypt(sec, k)   Better than ASM 這時候joy似乎在看交替看各題，casper在解verilog\n然後我發現calc.exe有給source code很佛 :D 雖然是放在網頁隱藏的元素上面，不過點進去html就看得到了。但是不太知道要幹嘛。\n只好交替看各題，看了reverse最後面這題給的檔案，把副檔名拿去google發現似乎是LLVM，而且跟wiki上面LLVM的中間語言，Intermediate Representation格式應該是吻合的。\n執行lli task.ll可以執行這個bitcode，但是他就只是個會問你答不出來的問題的小壞蛋\n畢竟我不會看這種很像組語的東西，所以就找一下有沒有轉換的工具，還真的在github上看到有llvm2c這個工具可以轉換成C語言，我還不star爆 XDD\n換成C語言之後發現超多goto，不過其實都只是if跟for迴圈產生的goto而已，沒有特別混淆的感覺。\n倒是變數用的超級多，大概是因為組語會把強制轉型跟那些暫時變數寫出來吧（例如算(i+1)%n就會int var3 = i+1; var3 % n或是複製一遍同樣的數字只是因為要轉unsigned）\n總之他做的是只是input -\u0026gt; validate -\u0026gt; win/fail，他的win會要用到input的字串然後做一些加密還是hash的動作，而validate只是檢查input的兩兩相鄰字元是否跟某個常數陣列相符，所以我枚舉第一個字元就能得知整個字串，接著call win看輸出就可以找到flag了。老實說我一開始還以為做錯了，因為要從幾十個亂碼裡面找出合理的輸出比想像中難，何況他的flag還是用Leetspeak寫出來的XD怎麼找到的我都不知道。\n下面是我最後化簡的code，全域的陣列大部份刪掉以便閱讀，可以看到main裡面還留了一些goto，基本上就只是在做for迴圈而已\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;string.h\u0026gt;// function declarations // extern unsigned int __isoc99_scanf(unsigned char* var0, ...); unsigned int check(unsigned char* var0); int main(void); // extern unsigned int printf(unsigned char* var0, ...); // extern unsigned long strlen(unsigned char* var0);  // global variable definitions unsigned char format[64] = { ... }; unsigned char flag[64] = { ... }; unsigned char what[64] = { ... }; unsigned char secret[64] = { ... }; unsigned char _str[49] = { ... }; unsigned char _str_1[25] = { ... }; unsigned char _str_2[7] = { ... }; unsigned char _str_3[5] = { ... }; unsigned char _str_4[81] = { ... }; unsigned int check(unsigned char* str){ unsigned int i; for(i = 0; i \u0026lt; strlen(what); i++) { int a = str[i], b = str[(i+1)%strlen(what)]; if((a ^ b) != ((int)(what[i]))) return 0; } return 1; } unsigned char str[64]; void solve(char c) { unsigned int i, n = strlen(what); str[0] = c; for(i = 0; i+1 \u0026lt; n; i++) { str[i+1] = str[i] ^ what[i]; } str[n] = 0; // printf(\u0026#34;%c\\n%c\\n\u0026#34;, str[n-2], str[n-1]);  // puts(str);  // printf(\u0026#34;%u\\n\u0026#34;, strlen(str)); } int answer(unsigned char var1[]) { unsigned int var2; unsigned int var3; unsigned long var4; long var5; int var6; long var7; long var8; int var9; long var10; // printf(\u0026amp;(_str[0]));  // printf(\u0026amp;(_str_1[0]));  // printf(\u0026amp;(_str_2[0]));  // puts(what);  // scanf(\u0026amp;(_str_3[0]), \u0026amp;(var1[0]));  var4 = strlen(\u0026amp;(var1[0])); // printf(\u0026#34;input = %s\\n\u0026#34;, var1);  // printf(\u0026#34;var4 = %d\\n\u0026#34;, (int)var4);  // printf(\u0026#34;strlen(what) = %d\\n\u0026#34;, (int)strlen(what));  if (var4 != strlen(\u0026amp;(what[0]))) { return 1; printf(\u0026amp;(_str_4[0])); return 1; } else { if (check(\u0026amp;(var1[0])) != 0) { // printf(\u0026#34;Here!\\n\u0026#34;);  var2 = 0; goto block4; // here is for loop  block4: var5 = ((long)var2); if (((unsigned long)var5) \u0026lt; strlen(\u0026amp;(var1[0]))) { var6 = ((int)(var1[(long)var2])); var7 = ((long)var2); (var1[(long)var2]) = ((unsigned char)(var6 ^ ((int)(secret[((unsigned long)var7) % strlen(\u0026amp;(secret[0]))])))); var2 = (((int)var2) + ((int)1)); goto block4; } else { printf(\u0026#34;output = %s\\n\\n\u0026#34;, var1); // printf(\u0026amp;(format[0]), \u0026amp;(var1[0]));  return 0; } } else { return 3; var3 = 0; goto block9; // here is for loop  block9: var8 = ((long)var3); if (((unsigned long)var8) \u0026lt; strlen(\u0026amp;(var1[0]))) { var9 = ((int)(flag[(long)var3])); var10 = ((long)var3); (var1[(long)var3]) = ((unsigned char)(var9 ^ ((int)(secret[((unsigned long)var10) % strlen(\u0026amp;(secret[0]))])))); var3 = (((int)var3) + ((int)1)); goto block9; } else { printf(\u0026amp;(format[0]), \u0026amp;(var1[0])); return 0; } } } } int main(void) { for(int i = 0; i \u0026lt; 128; i++) { solve(i); answer(str); } }   Calc.exe online 不久之後casper把verilog(flag checker)給做出來了\n我也弄出來說sin[0]會跑出s這個字串（不記得是google還是試出來的了）\n然後Google發現大概是webshell這個主題，接著又找到可以用('system')()之類的方法執行函數，我就照著找到的東西試試看('phpinfo')()，\n然後真的跑出東西了XD\n但是我很多字元弄不出來，後來查到可以用chr這個函數，就能成功湊出所有的字元啦！\n不過我不知道flag在哪裡，所以執行了('system')('find / -name \u0026quot;flag*')找到flag在哪裡，最後執行了('system')('cat /flag*')得到flag的內容\n下面是我最後拿來湊出字元的腳本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  good = [\u0026#39;abs\u0026#39;, \u0026#39;acos\u0026#39;, \u0026#39;acosh\u0026#39;, \u0026#39;asin\u0026#39;, \u0026#39;asinh\u0026#39;, \u0026#39;atan2\u0026#39;, \u0026#39;atan\u0026#39;, \u0026#39;atanh\u0026#39;, \u0026#39;base_convert\u0026#39;, \u0026#39;bindec\u0026#39;, \u0026#39;ceil\u0026#39;, \u0026#39;cos\u0026#39;, \u0026#39;cosh\u0026#39;, \u0026#39;decbin\u0026#39;, \u0026#39;dechex\u0026#39;, \u0026#39;decoct\u0026#39;, \u0026#39;deg2rad\u0026#39;, \u0026#39;exp\u0026#39;, \u0026#39;floor\u0026#39;, \u0026#39;fmod\u0026#39;, \u0026#39;getrandmax\u0026#39;, \u0026#39;hexdec\u0026#39;, \u0026#39;hypot\u0026#39;, \u0026#39;is_finite\u0026#39;, \u0026#39;is_infinite\u0026#39;, \u0026#39;is_nan\u0026#39;, \u0026#39;lcg_value\u0026#39;, \u0026#39;log10\u0026#39;, \u0026#39;log\u0026#39;, \u0026#39;max\u0026#39;, \u0026#39;min\u0026#39;, \u0026#39;mt_getrandmax\u0026#39;, \u0026#39;mt_rand\u0026#39;, \u0026#39;octdec\u0026#39;, \u0026#39;pi\u0026#39;, \u0026#39;pow\u0026#39;, \u0026#39;rad2deg\u0026#39;, \u0026#39;rand\u0026#39;, \u0026#39;round\u0026#39;, \u0026#39;sin\u0026#39;, \u0026#39;sinh\u0026#39;, \u0026#39;sqrt\u0026#39;, \u0026#39;srand\u0026#39;, \u0026#39;tan\u0026#39;, \u0026#39;tanh\u0026#39;, \u0026#39;ncr\u0026#39;, \u0026#39;npr\u0026#39;, \u0026#39;number_format\u0026#39;] mp = {} for s in good: for j in range(len(s)): if s[j] not in mp or len(mp[s[j]]) \u0026gt; len(s)+2+len(str(j)): mp[s[j]] = s + \u0026#39;[\u0026#39; + str(j) + \u0026#39;]\u0026#39; # print(mp) def solve(s): ret = \u0026#39;\u0026#39; first = True for c in s: if not first: ret += \u0026#39;.\u0026#39; first = False if c not in mp: ret += f\u0026#39;(({solve(\u0026#34;chr\u0026#34;)})({ord(c)}))\u0026#39; else: ret += mp[c] return ret # print(\u0026#39;(\u0026#39; + solve(\u0026#39;system\u0026#39;) + \u0026#39;)\u0026#39; + \u0026#39;(\u0026#39; + solve(\u0026#39;find / -name flag*\u0026#39;) + \u0026#39;)\u0026#39;) # call (\u0026#39;system\u0026#39;)(\u0026#39;ls\u0026#39;) print(\u0026#39;(\u0026#39; + solve(\u0026#39;system\u0026#39;) + \u0026#39;)\u0026#39; + \u0026#39;(\u0026#39; + solve(\u0026#39;cat /flag*\u0026#39;) + \u0026#39;)\u0026#39;) # call (\u0026#39;system\u0026#39;)(\u0026#39;ls\u0026#39;) # print(solve(\u0026#39;echo\u0026#39;)) # print(solve(\u0026#39;getallheaders\u0026#39;)) # print(solve(\u0026#39;system\u0026#39;)) # print(solve(\u0026#39;ls\u0026#39;))   P versus ♯P 接下來我基本上通宵都在弄這題。我覺得這題很有趣，題目是server會丟給你一個有障礙物的棋盤方格，簡單版本是問是否可以用1x2的骨牌蓋滿而困難版本是問有幾種方法。\n這個之前蕭梓宏好像講過，所以我知道他是可作的，就是平面圖的完美匹配個數。google之後找到CSDN有現成的code，先感謝owo\n不過可惜他是對998244353 mod，而且加邊的方式也有些不同，所以我稍微改了一下code，改成日月卦長的大數，不過速度真的很慢，超級慢QQ\n我猜是因為途中數字會變超大所以速度就燒雞。我找各種python的套件要高精度快速做矩陣行列式的都找不到可以用的QQ所以我最後決定用中國剩餘定理，選夠多的質數算XD\n這樣行列式還是算的頗慢，大概在12~13筆就會卡住了，於是就卡關跑去解Gamer\u0026rsquo;s Cipher和別題。\n晚上的時候想到這張圖是平面圖，因此矩陣是稀疏的，跑去github上面找了稀疏矩陣行列式，還真的有XD 真香 而且作法還是跟之前看過得中國IOI國家隊論文寫的一樣XDD\n所以就套上去，但是但是！這樣還是不夠快，時間已經到了隔天凌晨七點，我嘗試最後一次後就把檔案丟給隊友倒下去了。\n起床是十二點多，最後我是又找到另外一個github上面的 code 可以加速同餘下的乘法才終於成功把時間壓到範圍內，做出來真的成就感滿滿。\n我最後的code有點長，之後再考慮另外放好了\nRansomware The vault是web assembly，被casper解決掉。同時joy也催促（？）我解這題，雖然他已經剩下50分了QQ\n總之他給了.pyc檔跟一個flag.enc的檔案，把byte code用工具（decompyle之類的，不知道版本重不重要，不過以magic numbe來看這個.pyc似乎是3.8）轉回來.py之後就可以輕鬆知道他是把flag.png以官方網頁上面的文字當作金鑰用AES加密成flag.enc，\n用同一個套件解密後得到flag.png寫著the flag is after this image，我一頭霧水丟給joy他就直接找出真正的flagㄌ，似乎是兩張png黏在一起的梗。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  # decompyle3 version 3.3.2 # Python bytecode 3.8 (3413) # Decompiled from: Python 3.8.0 (default, Jan 17 2021, 16:18:58)  # [GCC 10.2.0] # Embedded file name: task.py # Compiled at: 2021-01-14 22:13:24 # Size of source mod 2**32: 420 bytes from Crypto.Cipher import AES # def func(key, iv, data, AES): # open(\u0026#39;flag.enc\u0026#39;, \u0026#39;wb\u0026#39;).write(AES.new(key, AES.MODE_CBC, iv).encrypt(lambda x: x + b\u0026#39;\\x00\u0026#39; * (16 - len(x) % 16)(data))) def decrpt(key, iv, AES): cipher = AES.new(key, AES.MODE_CBC, iv) raw = open(\u0026#39;flag.enc\u0026#39;, \u0026#39;rb\u0026#39;).read() print(len(raw)) open(\u0026#39;flag.png\u0026#39;, \u0026#39;wb\u0026#39;).write(cipher.decrypt(raw)) data = __import__(\u0026#39;requests\u0026#39;).get(\u0026#39;https://ctf.bamboofox.tw/rules\u0026#39;).text.encode() key = 99 iv = 153 # func(data[key:key + 16], data[iv:iv + 16], open(\u0026#39;flag.png\u0026#39;, \u0026#39;rb\u0026#39;).read(), __import__(\u0026#39;Crypto.Cipher.AES\u0026#39;).Cipher.AES) if len(data) != 0 else lambda fn: __import__(\u0026#39;os\u0026#39;).remove(fn)(\u0026#39;task.py\u0026#39;)) decrpt(data[key:key+16], data[iv:iv+16], AES) # okay decompiling task.pyc   orz Network 被casper丟了這題，他說這是質數什麼的題目應該交給我\n看起來像是隨便找一棵生成樹然後把每條邊都解密就可以了，他使用的加密方法是Diffie-Hellman，去維基百科可以翻到公鑰與私鑰各自的定義。\n總之，要求私鑰我們就必須求離散對數，但是他的數字範圍給到10^18而且有419個數字要解，很明顯不能直接大步小步做完，\n經過一番google，我發現了Pohlig-Hellman algorithm，是可以在大約sqrt(p)的量級解離散對數，其中p是mod的phi值（=mod-1）的最大質因數。因為完全沒有找到C++的code所以我自己按照維基上面的敘述刻，花了一段時間之後可以在合理的時間內解出某條邊了。\n接下來就找生成樹然後對那些邊解密就對了。這題比前面幾題的演算法題簡單多了，雖然還是套了一大堆模板XDD\n直接去抄waynedisonitau123的Pollard-Rho還有Millar-Rabin好爽喔XDDD\n然後大步小步跟中國剩餘也都不用自己寫，對打高中競程的人來說真的是夢幻待遇(X\nsolve.cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199  #include \u0026lt;bits/extc++.h\u0026gt; using namespace std; using ll = long long; using LLL = __int128; ll modpow(ll e, ll p, ll m) { ll r = 1; while(p) { if(p \u0026amp; 1) r = (LLL)r * e % m; e = (LLL) e * e % m; p \u0026gt;\u0026gt;= 1; } return r; } ll modmul(ll a, ll b, ll m) { return (LLL) a * b % m; } struct Factorization { struct MillerRabin { // n \u0026lt; 4759123141 chk = [2, 7, 61]  // n \u0026lt; 1122004669633 chk = [2, 13, 23, 1662803]  // n \u0026lt; 2^64 chk = [2, 325, 9375, 28178, 450775, 9780504, 1795265022]  vector\u0026lt;long long\u0026gt; chk = {2,325,9375,28178,450775,9780504,1795265022}; bool Check(long long a, long long u, long long n, int t) { a = modpow(a, u, n); if (a == 0 || a == 1 || a == n - 1) return true; for (int i = 0; i \u0026lt; t; ++i) { a = modmul(a, a, n); if (a == 1) return false; if (a == n - 1) return true; } return false; } bool operator()(long long n) { if (n \u0026lt; 2) return false; if (n % 2 == 0) return n == 2; long long u = n - 1; int t = 0; for (; !(u \u0026amp; 1); u \u0026gt;\u0026gt;= 1, ++t); for (long long i : chk) { if (!Check(i, u, n, t)) return false; } return true; } } prime; map\u0026lt;long long, int\u0026gt; cnt; void pollardRho(long long n) { if (n == 1) return; if (prime(n)) return ++cnt[n], void(); if (n % 2 == 0) return pollardRho(n / 2), ++cnt[2], void(); long long x = 2, y = 2, d = 1, p = 1; auto f = [\u0026amp;](auto x, auto n, int p) { return (modmul(x, x, n) + p) % n; }; while (true) { if (d != n \u0026amp;\u0026amp; d != 1) { pollardRho(n / d); pollardRho(d); return; } if (d == n) ++p; x = f(x, n, p); y = f(f(y, n, p), n, p); d = __gcd(abs(x - y), n); } } ll mxPrime(ll n) { ll mx = 0; cnt.clear(); pollardRho(n); for(auto [a, b]: cnt) mx = max(mx, a); return mx; } } factor; struct CRT { ll R, M; CRT() : R(0), M(1) {} template \u0026lt;typename T\u0026gt; tuple\u0026lt;T, T, T\u0026gt; extgcd(T a, T b) { if (!b) return make_tuple(a, 1, 0); T d, x, y; tie(d, x, y) = extgcd(b, a % b); return make_tuple(d, y, x - (a / b) * y); } void add(ll r, ll m) { long long d, x, y; tie(d, x, y) = extgcd(M, m * 1ll); assert ((r - R) % d == 0); long long new_M = M / __gcd(M, 1ll * m) * m; R += modmul(modmul(x, (r - R) / d, new_M), M, new_M); M = new_M; ((R %= M) += M) %= M; } pair\u0026lt;ll,ll\u0026gt; operator()() const { return {R, M}; } }; ll BSGS(ll a, ll b, ll m, ll T) { // a^x = b (mod m), and T is the period  ll n = sqrt(T) + 1; ll an = modpow(a, n, m); unordered_map\u0026lt;ll, ll\u0026gt; vals; for (ll q = 0, cur = b; q \u0026lt;= n; ++q) { vals[cur] = q; cur = ((LLL) cur * a) % m; } // std::cerr \u0026lt;\u0026lt; \u0026#34;q = \u0026#34; \u0026lt;\u0026lt; q \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;  for (ll p = 1, cur = 1; p \u0026lt;= n; ++p) { cur = ((LLL) cur * an) % m; if (vals.count(cur)) { ll ans = n * p - vals[cur]; return ans; } } cerr \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34; b = \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; \u0026#34; m = \u0026#34; \u0026lt;\u0026lt; m \u0026lt;\u0026lt; \u0026#34; T = \u0026#34; \u0026lt;\u0026lt; T \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; cerr \u0026lt;\u0026lt; \u0026#34;NOT FOUND\\n\u0026#34;; exit(1); } using __gnu_cxx::power; ll discreteLog(ll a, ll b, ll m) { // m is prime  auto solve = [m](ll g, ll h, ll p, ll e) { ll x = 0; ll r = modpow(g, power(p, e-1), m); ll invg = modpow(g, m-2, m); for(int k = 0; k \u0026lt; e; k++) { ll hk = modpow(modmul(modpow(invg, x, m), h, m), power(p, e-1-k), m); ll d = BSGS(r, hk, m, p); x += power(p, k) * d; // cerr\u0026lt;\u0026lt;\u0026#34;k = \u0026#34;\u0026lt;\u0026lt;k\u0026lt;\u0026lt;\u0026#34; ; \u0026#34;;  } // cerr \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;  return x; }; ll phi = m-1; CRT crt; for(auto [p, e]: factor.cnt) { ll P = power(p, e); ll X = solve(modpow(a, phi / P, m), modpow(b, phi / P, m), p, e); crt.add(X, P); } assert(crt().second == phi); assert(modpow(a, crt().first, m) == b); return crt().first; } struct Edge { int j; ll m, g, A, B; Edge(int j, ll m, ll g, ll A, ll B) : j(j), m(m), g(g), A(A), B(B) {} }; signed main() { std::cerr \u0026lt;\u0026lt; \u0026#34;solve.cpp::main() start.\\n\u0026#34;; ios_base::sync_with_stdio(0), cin.tie(0); const int n = 420; int a, b; vector\u0026lt;vector\u0026lt;Edge\u0026gt;\u0026gt; adj(n); while(cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b) { assert(1 \u0026lt;= a \u0026amp;\u0026amp; a \u0026lt;= n \u0026amp;\u0026amp; 1 \u0026lt;= b \u0026amp;\u0026amp; b \u0026lt;= n \u0026amp;\u0026amp; a != b); ll m, g, A, B; cin \u0026gt;\u0026gt; m \u0026gt;\u0026gt; g \u0026gt;\u0026gt; A \u0026gt;\u0026gt; B; --a, --b; adj[a].emplace_back(b, m, g, A, B); adj[b].emplace_back(a, m, g, B, A); } vector\u0026lt;ll\u0026gt; ans; vector\u0026lt;int\u0026gt; vis(n); function\u0026lt;void(int)\u0026gt; dfs = [\u0026amp;](int i) { vis[i] = true; for(auto [j, m, g, A, B]: adj[i]) { if(vis[j]) continue; if(factor.mxPrime(m-1) \u0026gt;= 1e15) { cerr \u0026lt;\u0026lt; m-1 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; continue; } // cerr \u0026lt;\u0026lt; A \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; B \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;  ll sa = discreteLog(g, A, m); ll sb = discreteLog(g, B, m); assert(modpow(g, sa, m) == A \u0026amp;\u0026amp; modpow(g, sb, m) == B); ans.emplace_back(modpow(A, sb, m)); // cerr \u0026lt;\u0026lt; ans.back() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;  dfs(j); } }; dfs(0); std::cerr \u0026lt;\u0026lt; \u0026#34;ans.size() = \u0026#34; \u0026lt;\u0026lt; ans.size() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; assert(ans.size() == n-1); for(ll x: ans) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }   solve.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70  #!/usr/bin/env python3 import os import sys import time import socket import hashlib import re import random host = \u0026#34;chall.ctf.bamboofox.tw\u0026#34; port = 10369 s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((host, port)) print(\u0026#39;connect success\u0026#39;) def pow_solver(prefix, difficulty): zeros = \u0026#39;0\u0026#39; * difficulty def is_valid(digest): if sys.version_info.major == 2: digest = [ord(i) for i in digest] bits = \u0026#39;\u0026#39;.join(bin(i)[2:].zfill(8) for i in digest) return bits[:difficulty] == zeros i = 0 while True: i += 1 s = prefix + str(i) if is_valid(hashlib.sha256(s.encode()).digest()): return i def main(): print(\u0026#39;main start\u0026#39;) question = s.recv(4096) question = question.decode(\u0026#39;ascii\u0026#39;) print(question) question = question[58:74] print(question) ans = pow_solver(question, 20) print(str(ans) + \u0026#39;\\n\u0026#39;) s.send(bytes(str(ans) + \u0026#39;\\n\u0026#39;, \u0026#39;ascii\u0026#39;)) _ = s.recv(4096) print(_.decode(\u0026#39;utf-8\u0026#39;)) s.send(bytes(\u0026#39;\\n\u0026#39;, \u0026#39;utf-8\u0026#39;)) with open(\u0026#39;edges.txt\u0026#39;, \u0026#39;w\u0026#39;) as f: while True: _ = s.recv(4096) if len(_) == 0: break content = _.decode(\u0026#39;ascii\u0026#39;) # print(content) content = re.sub(\u0026#34;[^\\d\\s]\u0026#34;, \u0026#34;\u0026#34;, content) f.write(content) if _.decode(\u0026#39;ascii\u0026#39;).find(\u0026#34;Enter\u0026#34;) != -1: break; os.system(\u0026#34;./solve \u0026lt; edges.txt \u0026gt; ans.txt\u0026#34;) with open(\u0026#34;ans.txt\u0026#34;, \u0026#34;r\u0026#34;) as f: ans = f.readlines(); print(ans, len(ans)) ans = \u0026#39; \u0026#39;.join([x.strip() for x in ans]) print(ans) s.send(bytes(str(ans) + \u0026#39;\\n\u0026#39;, \u0026#39;ascii\u0026#39;)) res = s.recv(1024) print(res.decode(\u0026#39;utf-8\u0026#39;)) # os.system(\u0026#34;./solve\u0026#34;) main()   1 2  g++ solve.cpp -o solve -std=c++17 python solve.py   After that 接下來我又花了一個半夜去嘗試Web題\ntime to draw看起來就是要對那個api做怪事情，但我整個方向錯誤了，我誤以為是要XSS所以瘋狂送color={\u0026quot;match\u0026quot;: \u0026quot;function() { ... }\u0026quot;}的請求，但其實根本沒辦法執行這字串裡面的東西QQ\n我也有看表情符號那一題，但是實在對PHP太陌生了，我現在連官方解答都不知道為什麼會對，他不是會檢查長度嗎？？？\n總之，我覺得我們web跟pwn太弱了（或者說這次出的都是演算法題XD）\n不知道這種injection應該如何練習是好(X\n最後名次是12名，跟去年比起來進步不只一半\n而且意外的是我們是台灣前三名所以可以拿獎金耶，超爽der\n明年不意外應該也是會來玩ㄅ，不過如果問我途中會不會認真學大概就是不會吧owo\n打CTF真的很讓人享受解謎（？）的過程，不過也可能只是因為解的出來才享受吧。另外打CTF還有一個優點就是不會被ZCK電爛很開心(X\n","permalink":"https://omeletwithoutegg.github.io/2021/01/19/bamboofox-ctf-2021/","tags":["CTF","experience"],"title":"BambooFox CTF 2021"},{"contents":"變動的過路費 https://tioj.ck.tp.edu.tw/problems/1597\nDescription 給你一張有向圖，每個邊會有隨時間變動的權重，並且邊的權重對時間是一個線性函數。\n再給你兩個點 $A,B$，現在你想要從 $A$ 走到 $B$ 再走回 $A$，\n問你在時間 $[0, D-1]$ 中，最長的最短路徑和最短的最短路徑相差多少。\n保證在時間內的邊權都是非負整數，並且答案不會超過long long。\nSolution 這題很久以前就跟蕭梓宏討論過了，不過我怎麼寫都會吃WA 0分\n今天#define int ll結果就拿了67分XD仔細檢查才發現原來一條邊的邊權可以不在int的範圍內但我卻用了int\n忘記開long long真的Orz\n因為線性函數的和還是線性函數，考慮所有的「路徑」，他們都代表一條對時間的線性函數。\n而某個時間點的最短路徑就是這些直線的 $\\min$。也就是說，所有時間點的最短路徑是所有路徑的線性函數的下凸包(lower envelope)\n把這個凸包建出來似乎不是可行的（？）所以就考慮三分搜找出最大值。至於最小值一定是在端點，所以相減就是答案了。\n好像有卡一些常數QQ我還得判如果dijkstra跑到終點就return、三分搜遇到相同就break;之類的，不知道是不是TIOJ主機變慢了QQ\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82  #pragma GCC optmize(\u0026#34;Ofast\u0026#34;) #include \u0026lt;bits/stdc++.h\u0026gt;#ifdef local #define safe cerr\u0026lt;\u0026lt;__PRETTY_FUNCTION__\u0026lt;\u0026lt;\u0026#34; line \u0026#34;\u0026lt;\u0026lt;__LINE__\u0026lt;\u0026lt;\u0026#34; safe\\n\u0026#34; #define debug(args...) qqbx(#args, args) template \u0026lt;typename ...T\u0026gt; void qqbx(const char *s, T ...args) { int cnt = sizeof...(T); ((std::cerr \u0026lt;\u0026lt; \u0026#34;(\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;) = (\u0026#34;) , ... , (std::cerr \u0026lt;\u0026lt; args \u0026lt;\u0026lt; (--cnt ? \u0026#34;, \u0026#34; : \u0026#34;)\\n\u0026#34;))); } #else #define safe ((void)0) #define debug(...) ((void)0) #endif // local #define pb emplace_back #define all(v) begin(v),end(v)  using namespace std; template \u0026lt;typename T\u0026gt; using min_heap = priority_queue\u0026lt;T, vector\u0026lt;T\u0026gt;, greater\u0026lt;T\u0026gt;\u0026gt;; using ll = long long; using ld = double; struct Dijkstra { vector\u0026lt;vector\u0026lt;tuple\u0026lt;ll,ll,int\u0026gt;\u0026gt;\u0026gt; g; vector\u0026lt;ll\u0026gt; dis; vector\u0026lt;bool\u0026gt; vis; Dijkstra(size_t n) : g(n), dis(n), vis(n) {} void addEdge(int a, int b, ll c, ll p) { g[a].pb(c, p, b); } ll shortestPath(int s, int t, int T) { fill(all(dis), -1); fill(all(vis), false); min_heap\u0026lt;pair\u0026lt;ll,int\u0026gt;\u0026gt; pq; pq.push({0, s}); dis[s] = 0; while(!pq.empty()) { auto [d, i] = pq.top(); pq.pop(); if(vis[i]) continue; vis[i] = true; if(i == t) return d; for(auto [c, p, j]: g[i]) { if(vis[j]) continue; ll w = c + p * T; if(dis[j] == -1 || dis[j] \u0026gt; d + w) { dis[j] = d+w; pq.push({dis[j], j}); } } } // assert(dis[t] != -1);  return dis[t]; } }; signed main() { ios_base::sync_with_stdio(0), cin.tie(0); int n, m, A, B, D; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; A \u0026gt;\u0026gt; B \u0026gt;\u0026gt; D; Dijkstra dij(n); // -\u0026gt; : i * 2  // \u0026lt;- : i*2+1  for(int i = 0; i \u0026lt; m; i++) { int x, y; ll c1, p1, c2, p2; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y \u0026gt;\u0026gt; c1 \u0026gt;\u0026gt; p1 \u0026gt;\u0026gt; c2 \u0026gt;\u0026gt; p2; dij.addEdge(x, y, c1, p1); dij.addEdge(y, x, c2, p2); } auto calc = [\u0026amp;](int T) -\u0026gt; ll { return dij.shortestPath(A, B, T) + dij.shortestPath(B, A, T); }; ll ans = 0; for(int s = 1 \u0026lt;\u0026lt; 29; s; s\u0026gt;\u0026gt;=1) { debug(ans, s); if(ans + s \u0026gt;= D) continue; ll c1 = calc(ans + s - 1); ll c2 = calc(ans + s); if(c1 \u0026lt;= c2) ans += s; if(c1 == c2) break; } cout \u0026lt;\u0026lt; calc(ans) - min(calc(0), calc(D-1)) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }   XD 突然發現最近發好幾題凸包的解\n我真的很喜歡凸包耶(X\n然後一年又過去了，時間真的好快\n前幾天去TPMSO還有dreamoon的課程，反而讓我的迷惘感更多了XD\n每個學長都超級厲害\n尤其是陳柏叡學長，他雖然外表超年輕但是超級成熟的感覺\n現在應該做的事，大概就是在寒假左右把專題弄一個段落，然後把選訓好好走完吧。\n也許今年還是有機會國手，但是我認真覺得不可能贏balbit跟ZCK，他們實在太強了\n而且我因為專題被催根本沒辦法好好練習QQ\n不過我的目標也不是贏過他們，希望至少有機會明年拿個更好的牌，為此我得先做完專題給自己一個好的練習環境（\n","permalink":"https://omeletwithoutegg.github.io/2020/12/30/TIOJ-1597/","tags":["TIOJ","dijkstra","ternary-search"],"title":"TIOJ 1597"},{"contents":"賽車問題 https://tioj.ck.tp.edu.tw/submissions/231136\nDescription 現在有 $n$ 輛往右邊跑的賽車，每一輛都有其固定的車速以及起始位置。\n你想要知道在從現在開始的所有時刻中，什麼時候最領先的車子跟最落後的車子的距離會最短。\n可以假設車速都不相同\nSolution 首先每個車的位置對於時間是一個一次函數，而「每個時刻最前面的車的位置」和「每個時刻最後面的車的位置」就是這些直線形成的上下凸包（envelope）\n這題可以用三分搜寫掉（？）\n不過可以把凸包真的建出來做。最佳的答案一定會出現在凸包的頂點上，或是邊界（也就是時刻=0的時候）\n於是建出來之後用雙指標依照x由小到大檢查上下凸包的距離就可以了，記得要處理邊界的case。\n這樣雖然時間複雜度還是有 $\\log$ ，不過是 sort 的 $\\log n$。\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74  #include \u0026lt;bits/stdc++.h\u0026gt;#ifdef local #define debug(args...) qqbx(#args, args) template \u0026lt;typename ...T\u0026gt; void qqbx(const char *s, T ...args) { int cnt = sizeof...(T); ((std::cerr \u0026lt;\u0026lt; \u0026#34;(\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;) = (\u0026#34;) , ... , (std::cerr \u0026lt;\u0026lt; args \u0026lt;\u0026lt; (--cnt ? \u0026#34;, \u0026#34; : \u0026#34;)\\n\u0026#34;))); } #else #define debug(...) ((void)0) #endif #define pb emplace_back #define all(v) begin(v),end(v)  using namespace std; using ll = long long; using ld = double; using pii = pair\u0026lt;int,int\u0026gt;; const int N = 1025; const ll INF = 1e18; ll ori(pii a, pii b, pii c) { return 1LL * (a.second - b.second) * (c.first - a.first) - 1LL * (a.second - c.second) * (b.first - a.first); } ld calc(pii L, ld x) { return L.first * x + L.second; } ld intersect(pii a, pii b) { return (a.second - b.second) / ld(b.first - a.first); } signed main() { ios_base::sync_with_stdio(0), cin.tie(0); int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; car(n); for(auto \u0026amp;[v, s]: car) cin \u0026gt;\u0026gt; v \u0026gt;\u0026gt; s; sort(all(car)); vector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; lo, up; for(auto [a, b]: car) { while(up.size() \u0026gt;= 2 \u0026amp;\u0026amp; ori(up[up.size()-2], up.back(), {a, b}) \u0026gt;= 0) up.pop_back(); up.pb(a, b); } reverse(all(car)); for(auto [a, b]: car) { while(lo.size() \u0026gt;= 2 \u0026amp;\u0026amp; ori(lo[lo.size()-2], lo.back(), {a, b}) \u0026gt;= 0) lo.pop_back(); lo.pb(a, b); } /* reverse(all(up)); */ /* cerr \u0026lt;\u0026lt; \u0026#34;lo =\\n\u0026#34;; */ /* for(auto [a, b]: lo) debug(a, b); */ /* cerr \u0026lt;\u0026lt; \u0026#34;up =\\n\u0026#34;; */ /* for(auto [a, b]: up) debug(a, b); */ int mx = -1e9, mn = 1e9; for(auto \u0026amp;[v, s]: car) mx = max(mx, s), mn = min(mn, s); ld ans = mx - mn; size_t i = 0, j = 0; debug(lo.size(), up.size()); while(i+1 \u0026lt; lo.size() || j+1 \u0026lt; up.size()) { ld xi = i+1 \u0026lt; lo.size() ? intersect(lo[i], lo[i+1]) : 1e18; ld xj = j+1 \u0026lt; up.size() ? intersect(up[j], up[j+1]) : 1e18; debug(xi, xj); debug(i, j); if(xi \u0026lt; xj) { if(xi \u0026gt;= 0) ans = min(ans, calc(up[j], xi) - calc(lo[i], xi)); i++; } else { if(xj \u0026gt;= 0) ans = min(ans, calc(up[j], xj) - calc(lo[i], xj)); j++; } } printf(\u0026#34;%.2lf\\n\u0026#34;, ans); }   ","permalink":"https://omeletwithoutegg.github.io/2020/12/23/TIOJ-1284/","tags":["TIOJ","geometry","math","ternary-search"],"title":"TIOJ 1284"},{"contents":"在Arch的初音游標 因為在Windows有下載一個可愛的初音游標，但是之前換成Ubuntu後就沒有把他裝回來，覺得很可惜。\n因此現在換成Arch之後，想說應該有一些社群的package可以用了，直接抓來就好，但是怎麼google都google不到？\n因此大概花了半天去解決他，想說在這邊做個小筆記以免下次重裝的時候重摸一遍。\n 找到巴哈姆特上面的原始檔（是.ani跟.cur） 利用cursor-converter把.ani和.cur換成x-cursor的icon類型 手動把對應的圖案複製到 ~/.icons/$THEME/cursors 裡面\n如果不知道哪個檔名是什麼的話，可以先複製別的theme的資料夾，接著用 xcur2png 換成 png看某個檔案實際上是對應哪個圖案。 加上 index.theme。反正只要有Name就可以了吧我猜  中間踩了各種怪東西XD\n我原本先去下載了其他主題，想說看別的主題的游標應該是什麼對應到什麼，尤其是有動畫的。\n不過似乎有動畫的游標和沒動畫的檔名一樣QQ\n然後有找到一個ani2png，但是畫質會爆炸而且沒有幫忙放到對應的位置（雖然最後也是我們自己放到對應的位置）\n接著找到CSDN上面有人說用CursorXP從Windows上面把游標主題包起來，接著在Linux下載一個用來轉換成icon類型的Perl腳本，\n會轉換成一個tar.gz然後就可以安裝的樣子了，不過還是偏糟，從Windows上面看就發現畫質還是大小大爆炸了\n最後終於走對路，找到github上面一個比較新的repo是把.ani跟.cur轉成linux的x-cursor檔案\n真是要感謝他們www\n話說我發現其實可以直接把檔案放到github上面，這樣也可以推廣或是找人來修改(X\n裡面有好多icon是從breeze主題抄過來的，畢竟應該都是很少看到的icon所以應該不會影響太大，但是想包成AUR或是什麼的時候好像就得在乎一點一致性ㄌ，所以希望放到github上之後有人可以把其他那些icon改成統一的風格owo\n","permalink":"https://omeletwithoutegg.github.io/2020/12/10/arch-miku-mouse/","tags":["Arch","experience","miku"],"title":"Miku Cursor on Arch Linux"},{"contents":"Hugo! 似乎因為casper而嘗試從hexo跳槽到hugo。\nhexo似乎是對windows比較友善？檔名都一堆底線之類的\n啊hugo好像是對macOS比較友善QQ\nStartup Hugo沒有預設的theme，所以如果不想無中生有一定要裝一個theme。\n我原本用的Hexo Theme Cactus在Hugo也有人維護一個theme，不過feature就沒有那麼多了。\n總之試著寫一個markdown然後 hugo server\n驚訝的發現他超快XDD應該說是Hexo太慢了，我想node.js天生本來就有一些缺點吧。\n既然可以拋棄噁心的 node_modules 還有底線，而且還可以讓他 generate 的時間變超快，我決定試看看能不能把整個網站從Hexo改成用Hugo寫，並且同時大部份東西仍然保持跟之前相同，例如Repo、網址、code highlight、search/tag feature等等\n一些遇到的問題  Hard Line Break  這個蠻可怕的。在用Hexo的時候沒什麼感覺，但是我的Markdown全部都是用直接換行來換行；而Hugo預設不是，也就是說他應該要用兩個空格或是反斜線的方式來換行。這其實是Markdown預設的換行方式，但是真的很不習慣，不知道該怎麼說。而且也不可能一個一個檔案調整XD Solution:\n一開始查到可以在 config.html 裡面加    1 2  [blackfriday] extensions = [\u0026#34;hardLineBreak\u0026#34;]   不過都沒有效。後來才知道Blackfriday是Hugo原本拿來render markdown的東西，而某次更新之後已經換成Goldmark這個套件了。 基於我找不到怎麼在Goldmark加上 Hard Line Break 的選項，我選擇改回用Blackfriday render就好。  1 2  [markup] defaultMarkdownHandler = \u0026#34;blackfriday\u0026#34;    沒有search  Solution:\nGoogle了一陣子。中間找到這個使用Fuse.js的一個實作，不知道為什麼是放在討論區：https://gist.github.com/eddiewebb/735feb48f50f0ddd65ae5606a1cb41ae\n雖然蠻快找到，不過我踩了很多雷。\n首先是他寫法是 define \u0026quot;footerfiles\u0026quot;，但是我的theme的基底模板沒有block \u0026quot;footerfiles\u0026quot;的區塊。所以我目前是把那段script跟他定義的main放在一起。\n再來是mark.js，一直出現 $(...).mark is not a function，我也不知道為什麼用 jquery 的 mark.js 就會出事，總之我最後是把 search.js 換成上面連結裡面有人提出來的不帶 jquery 的版本。CSS直接抄原本Hexo那邊的搜尋框XD   各種格式不一樣(日期、TOML v.s. YAML)\n這個其實還好，很快就能看懂TOML，畢竟他是設計給人看的。vim有插件可以幫TOML syntax highlight，如果是vim的使用者要記得學習使用工具wwww Code highlight and copy button\n我原本highlight的主題是 monokai-sublime，而Hugo是用Chroma這個套件幫程式碼區塊syntax highlight。研究了好久CSS之後終於調成跟原本差不多了www有夠難wwww\n另外原本我有一個Copy按鍵可以Copy整段Code，但是Hugo跟Hexo的程式碼區塊也被render得超不一樣，所以改那部份的JS、CSS跟調整Selector花了一些時間。 Background Animation\n我在之前就有用Canvas.js讓背景有奇怪的幾何線段，而在Hugo中要再做一遍這個太簡單了，就把code貼到可以include的地方就好。 mathjax escape\n以為自己快做完的時候發現出大事，好幾篇的LaTeX出事了。經過一些觀察我發現是 _ 前面沒有空格就可能會出事被解讀成粗體，還有在math裡面的 \\\\ 不知道為什麼沒用。\n因為幾乎查不到Hugo或Blackfriday Mathjax的選項或是解決方法，所以我的解法是妥協，在 _ 前後各加一個空格以示安全，而 \\\\則是換成\\newline；希望我之後寫文章會記得。由於這些修改都是針對很多文章，因此我是用grep跟sed批次解決的。  小撇步 在本機測試的時候，如果只是為了 hugo server 就得耗掉一個terminal的視窗有點浪費，可以用 hugo server \u0026gt;server.log \u0026amp;來讓他在背景執行，並且使用 fg 把他叫回前台以讓我們停止他。\n當然如果是用GUI文字編輯器就沒什麼差了XD\nTravis CI So hard\n不過這東西有點真香\n總之就是不用弄髒自己的電腦去安裝build、deploy需要的套件，而且可以讓你的整個專案管理變得很簡單。\n參考BB的寫法，想辦法把 .travis.yml 弄好之後，看起來他的deploy流程是這樣：\n 有兩個分支，master存md、js、css、html模板等local會存的東西、gh-pages存龐大的靜態檔案。\n每次遇到master的commit，就嘗試把master build出來的東西塞到gh-pages這個分支，並讓gh-pages作為githug pages。\n 然後我驚訝的發現這樣我的github repo就變得超乾淨XDD真香\n我大概 build 失敗了 10 次才穩定成功@@，中間都是在把從BB那邊抄過來的 .travis.yml 調整成新版本中官方建議的寫法，還有各種玩git：搬運repo或是fork、submodule等等，感覺好像稍微對git熟悉了一點。\nTravis CI可以有更客製化的Build跟Deploy選項，基本上得自己寫script。\n我還有看到BB他們會把Travis CI拿來編譯LaTeX，也就是說本機上為了編譯龐大的Codebook裝一大堆套件絕對不是最好的選擇。\nTODO:  search result只有一個？ (Bug, fixed) syntax highlight style (OK) Copy code button (OK) Background Animation (OK) Travis CI deploy (Finally done)  測試  This is nobody speaking.\n BOLD, italic, ITALIC BOLD\nThis is $\\LARGE{\\text{inline math text}}$.\n$$\n\\text{Display Math with } \\LaTeX. ,\nI_n =\n\\left[\\begin{matrix}\n1 \u0026amp; \u0026amp; \\dots \u0026amp; \u0026amp; 0 \\newline\n\u0026amp; \\ddots \u0026amp; \u0026amp; \u0026amp; \\newline\n\\vdots \u0026amp; \u0026amp; 1 \u0026amp; \u0026amp; \\vdots \\newline\n\u0026amp; \u0026amp; \u0026amp; \\ddots \u0026amp; \\newline\n0 \u0026amp; \u0026amp; \\dots \u0026amp; \u0026amp; 1 \\newline\n\\end{matrix}\\right]\n$$\n1 2  arr = [int(t) for t in input().split()] print([x**2 for x in arr])   1 2 3 4 5 6 7 8 9  #include \u0026lt;bits/stdc++.h\u0026gt;#define safe std::cerr \u0026lt;\u0026lt; __PRETTY_FUNCTION__ \u0026lt;\u0026lt; \u0026#34; line \u0026#34; \u0026lt;\u0026lt; __LINE__ \u0026lt;\u0026lt; \u0026#34; safe\\n\u0026#34; using namespace std; signed main() { safe; int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; cout \u0026lt;\u0026lt; a + b \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }   ","permalink":"https://omeletwithoutegg.github.io/2020/11/25/hugo-framework/","tags":["Hugo","blog"],"title":"Hugo Framework"},{"contents":"邀請函（Invitation） https://tioj.ck.tp.edu.tw/problems/1978\nDescription 給你一張圖，求出最大點獨立集。\n點數最多80\nSolution 我本來一直以為這題是一般圖最大匹配，不過今天仔細看之後發現不是，而且一般圖沒有最大匹配=最小點覆蓋的結論。\n不過有最大點獨立集$+$最小點覆蓋$=|V|$。\n吳邦一教授講過關於最小點覆蓋的一個回溯法，於是我想說把他拿來用。\n其實這個演算法也很簡單，就每次挑最大degree的點出來要選或者不選就好，這樣的話複雜度聽起來會是$\\mathcal{O}(2^n)$之類的。\n不過我們可以先做以下幾個處理(簡化)\n degree 0的點直接拔掉。 degree 1的點，選他不如選他唯一的鄰居 剩下假設最大的degree是2，那所有點的degree都是2了，也就是說是一堆環，可以判掉  於是乎我們只剩下最大degree至少是3的case了。\n如果不選那個點的話，那他的鄰居都必須要選，可以列出遞迴式$T(n) = T(n-1) + T(n-4) + f(n)$，$n$代表還沒決定要不要選的點的數量，$f(n)$代表維護上面那些東西需要的時間。\n解這個遞迴式可以直接DP，或是利用特徵方程式$\\lambda^n = \\lambda^{n-1} + \\lambda^{n-4} \\Rightarrow \\lambda^4 - \\lambda^3 - 1 = 0$，他最大的實根大約是1.38左右，所以我們dfs的複雜度最多是$\\mathcal{O}(1.38^n f(n))$。用蠻naive的寫法$f(n)$會是$\\mathcal{O}(n)$(我也不知道怎麼快速維護XD)，$n=80$代進去$80 \\cdot 1.38^{80}$似乎幾乎是不行，不過不知道為什麼會AC而且竟然只輸BB跟塗大為的submission XD\n寫完之後，身為admin看到幾乎所有人都是用random，心情很複雜(#\n還有BB跟waynetuinfor的演算法似乎是轉成clique在做，不知道大學打ICPC有沒有機會搞懂。\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126  // __________________ // | ________________ | // || ____ || // || /\\ | || // || /__\\ | || // || / \\ |____ || // ||________________|| // |__________________| // \\###################\\ // \\###################\\ // \\ ____ \\ // \\_______\\___\\_______\\ // An AC a day keeps the doctor away.  #ifdef local #include \u0026lt;bits/extc++.h\u0026gt;#define safe std::cerr\u0026lt;\u0026lt;__PRETTY_FUNCTION__\u0026lt;\u0026lt;\u0026#34; line \u0026#34;\u0026lt;\u0026lt;__LINE__\u0026lt;\u0026lt;\u0026#34; safe\\n\u0026#34; #define debug(args...) qqbx(#args, args) using ost = std::ostream; #define DESTL(STL, BEG, END, OUT) \\ template \u0026lt;typename ...T\u0026gt; ost\u0026amp; operator\u0026lt;\u0026lt;(ost \u0026amp;O, std::STL\u0026lt;T...\u0026gt; v) { int f=0; for(auto x: v) O \u0026lt;\u0026lt; (f++ ? \u0026#34;, \u0026#34; : BEG) \u0026lt;\u0026lt; OUT; return O \u0026lt;\u0026lt; END; } DESTL(deque, \u0026#34;[\u0026#34;, \u0026#34;]\u0026#34;, x); DESTL(vector, \u0026#34;[\u0026#34;, \u0026#34;]\u0026#34;, x); DESTL(set, \u0026#34;{\u0026#34;, \u0026#34;}\u0026#34;, x); DESTL(multiset, \u0026#34;{\u0026#34;, \u0026#34;}\u0026#34;, x); DESTL(unordered_set, \u0026#34;{\u0026#34;, \u0026#34;}\u0026#34;, x); DESTL(map , \u0026#34;{\u0026#34;, \u0026#34;}\u0026#34;, x.first \u0026lt;\u0026lt; \u0026#34;:\u0026#34; \u0026lt;\u0026lt; x.second); DESTL(unordered_map , \u0026#34;{\u0026#34;, \u0026#34;}\u0026#34;, x.first \u0026lt;\u0026lt; \u0026#34;:\u0026#34; \u0026lt;\u0026lt; x.second); template \u0026lt;typename U, typename V\u0026gt; ost\u0026amp; operator\u0026lt;\u0026lt;(ost \u0026amp;O, std::pair\u0026lt;U,V\u0026gt; p) { return O \u0026lt;\u0026lt; \u0026#39;(\u0026#39; \u0026lt;\u0026lt; p.first \u0026lt;\u0026lt; \u0026#39;,\u0026#39; \u0026lt;\u0026lt; p.second \u0026lt;\u0026lt; \u0026#39;)\u0026#39;; } template \u0026lt;typename T, size_t N\u0026gt; ost\u0026amp; operator\u0026lt;\u0026lt;(ost \u0026amp;O, std::array\u0026lt;T,N\u0026gt; a) { int f=0; for(T x: a) O \u0026lt;\u0026lt; (f++ ? \u0026#34;, \u0026#34; : \u0026#34;[\u0026#34;) \u0026lt;\u0026lt; x; return O \u0026lt;\u0026lt; \u0026#34;]\u0026#34;; } template \u0026lt;typename T, size_t ...I\u0026gt; ost\u0026amp; prtuple(ost \u0026amp;O, T t, std::index_sequence\u0026lt;I...\u0026gt;) { return (..., (O \u0026lt;\u0026lt; (I ? \u0026#34;, \u0026#34; : \u0026#34;(\u0026#34;) \u0026lt;\u0026lt; std::get\u0026lt;I\u0026gt;(t))), O \u0026lt;\u0026lt; \u0026#34;)\u0026#34;; } template \u0026lt;typename ...T\u0026gt; ost\u0026amp; operator\u0026lt;\u0026lt;(ost \u0026amp;O, std::tuple\u0026lt;T...\u0026gt; t) { return prtuple(O, t, std::make_index_sequence\u0026lt;sizeof...(T)\u0026gt;()); } template \u0026lt;typename ...T\u0026gt; void qqbx(const char *s, T ...args) { int cnt = sizeof...(T); (std::cerr \u0026lt;\u0026lt; \u0026#34;\\033[1;32m(\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;) = (\u0026#34; , ... , (std::cerr \u0026lt;\u0026lt; args \u0026lt;\u0026lt; (--cnt ? \u0026#34;, \u0026#34; : \u0026#34;)\\033[0m\\n\u0026#34;))); } #else #pragma GCC optimize(\u0026#34;Ofast\u0026#34;) #pragma loop_opt(on) #include \u0026lt;bits/extc++.h\u0026gt;#include \u0026lt;bits/stdc++.h\u0026gt;#define debug(...) ((void)0) #define safe ((void)0) #endif // local #define all(v) begin(v),end(v) #define get_pos(v,x) int(lower_bound(begin(v),end(v),x)-begin(v)) #define sort_uni(v) sort(begin(v),end(v)),v.erase(unique(begin(v),end(v)),end(v)) #define pb emplace_back #define ff first #define ss second #define mem(v,x) memset(v,x,sizeof v)  using namespace std; using namespace __gnu_pbds; typedef int64_t ll; typedef long double ld; typedef pair\u0026lt;ll,ll\u0026gt; pll; typedef pair\u0026lt;ld,ld\u0026gt; pld; template \u0026lt;typename T\u0026gt; using max_heap = std::priority_queue\u0026lt;T,vector\u0026lt;T\u0026gt;,less\u0026lt;T\u0026gt; \u0026gt;; template \u0026lt;typename T\u0026gt; using min_heap = std::priority_queue\u0026lt;T,vector\u0026lt;T\u0026gt;,greater\u0026lt;T\u0026gt; \u0026gt;; template \u0026lt;typename T\u0026gt; using rbt = tree\u0026lt;T,null_type,less\u0026lt;T\u0026gt;,rb_tree_tag,tree_order_statistics_node_update\u0026gt;; constexpr ld PI = acos(-1), eps = 1e-7; constexpr ll N = 85, INF = 1e18, MOD = 1000000007, K = 14699, inf = 1e9; constexpr inline ll cdiv(ll x, ll m) { return x/m + (x%m ? (x\u0026lt;0) ^ (m\u0026gt;0) : 0); } // ceiling divide constexpr inline ll modpow(ll e,ll p,ll m=MOD) { ll r=1; for(e%=m;p;p\u0026gt;\u0026gt;=1,e=e*e%m) if(p\u0026amp;1) r=r*e%m; return r; } int n, m; bool g[N][N]; int picked[N]; int deg[N]; int ans = inf; void pick(int x) { picked[x] = true; for(int i = 0; i \u0026lt; n; i++) if(g[x][i]) --deg[i]; } void unpick(int x) { picked[x] = false; for(int i = 0; i \u0026lt; n; i++) if(g[x][i]) ++deg[i]; } void dfs(int c = 0) { if(c \u0026gt; ans) return; // reduce  vector\u0026lt;int\u0026gt; zero; for(int i = 0; i \u0026lt; n; i++) if(!picked[i] \u0026amp;\u0026amp; deg[i] == 0) zero.pb(i); if(zero.size()) { for(int x: zero) pick(x); dfs(c); for(int x: zero) unpick(x); return; } for(int i = 0; i \u0026lt; n; i++) if(!picked[i] \u0026amp;\u0026amp; deg[i] == 1) { for(int j = 0; j \u0026lt; n; j++) if(!picked[j] \u0026amp;\u0026amp; g[i][j]) { pick(i); pick(j); dfs(c+1); unpick(i); unpick(j); return; } } int mx = -1; for(int i = 0; i \u0026lt; n; i++) if(!picked[i]) { if(mx == -1 || deg[i] \u0026gt; deg[mx]) mx = i; } if(mx == -1) { ans = min(ans, c); return; } vector\u0026lt;int\u0026gt; adj; for(int i = 0; i \u0026lt; n; i++) if(!picked[i] \u0026amp;\u0026amp; g[mx][i]) adj.pb(i); pick(mx); dfs(c+1); for(int x: adj) pick(x); dfs(c+adj.size()); for(int x: adj) unpick(x); unpick(mx); } signed main() { ios_base::sync_with_stdio(0), cin.tie(0); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for(int i = 0; i \u0026lt; m; i++) { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; g[a][b] = g[b][a] = true; ++deg[a], ++deg[b]; } dfs(); cout \u0026lt;\u0026lt; n - ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }   ","permalink":"https://omeletwithoutegg.github.io/2020/11/22/TIOJ-1978/","tags":["TIOJ","graph","dfs"],"title":"TIOJ-1978"},{"contents":"我只是想做一下筆記\n然後我還是不會縮花/帶花樹演算法，所以我也不會一般圖最大權匹配\n先備知識 看得懂$\\sum$\n然後會(不帶權)二分圖匹配的匈牙利演算法\nKuhn Munkres 這裡介紹KM演算法，而若要求解二分圖上的最大權匹配等相關問題可以透過下面的演算法轉換成KM的模型。\nKM演算法是用來求一張完全二分圖的最大權完美匹配的演算法，其中邊的權重都是非負的。\n演算法轉換  最大權匹配 $\\to$ 最大權完全二分圖完美匹配(非負邊權)\n把不存在的邊以及負邊權的邊邊權設成0 最大權完美匹配(有負邊權) $\\to$ 最大權完全二分圖完美匹配(非負邊權)\n把不存在的邊邊權設成0，並且把剩下每條邊的邊權加上一個夠大的數$M$，這樣就會傾向於選出儘量多邊。最後的答案記得要扣掉這些$M$  可以想想看為什麼上面兩種轉換是對的\n把問題敘述再好好的寫一遍\nDescription  給你一張完全二分圖 $K _ {n,n}$ ，每條邊 $e = (x_i,y_j)$ 有邊權 $w _ e$\n請選出 $n$ 條邊 $e_1, e_2, \\cdots e_n$ 兩兩不共端點，使得邊權和$\\sum\\limits _ {i=1}^n w _ {e _ i}$最大\n 對偶問題 首先引入頂標的概念。對於每個頂點$v$我們維護一個數字$L_v$，稱為頂標。\n在演算法的過程中，我們必須妥當的維護頂標，使得對於所有邊$e=(a,b)$都有$L_a+L_b \\geq w_e$\n那麼很顯然的，對於任何一種合法的頂標來說，頂標的總和會大於等於最大權完美匹配的值。\n因為對於任何匹配$M$都有$\\sum\\limits _ {e\\in M} w_e \\leq \\sum\\limits _ {e\\in M, e = (a,b)} (L_a + L_b) \\leq \\sum\\limits _ {v\\in V} L_v$\n另外，對於一個合法的頂標配置$L$，考慮所有$L_a+L_b = w_e$的邊$e=(a,b)$所形成的子圖$G'$(我們稱這類$e$為等邊)\n若這個子圖有完美匹配的話那麼顯然：原圖最大權完美匹配 $=$ $G'$的最大權完美匹配 $=$ $\\sum _ {v\\in V} L _ v$\n事實上，我們可以得出更強的結論，即最大權完美匹配 $=$ 所有合法頂標配置中總和最小者，不過證明我不會\u0026gt; \u0026lt;\n演算法的步驟 KM演算法的(非常模糊的)步驟大致如下：\n 依序以$x_1, x_2, \\dots, x_n$為起點尋找增廣路徑，但限制只能走等邊，即$e=(a,b)$滿足$L_a+L_b=w_e$ 如果找不到增廣路徑，我們就必須調整頂標，使得之前已經匹配好的邊仍然滿足等號，並且有機會在調整之後多出可以增廣的等邊 關於頂標的初始化以及如何調整頂標：   初始化：不失一般性一開始可以初始化$L _ {x_i} = \\max\\limits _ {x_i \\in e} w_e, L _ {y _ i} = 0$ 如何調整頂標：由於在前一步我們找增廣路徑失敗了，這表示我們找到的是一個交錯樹，樹上的邊都是等邊。我們考慮把所有在樹上的$x_i$或$y_j$，讓$L _ {x_i}$減少$\\delta$，$L _ {y_j}$增加$\\delta$。\n問題在於如何取這個$\\delta$。想要讓可以增廣的邊變多的話，肯定是多了連接樹上和非樹上的頂點的非等邊，我們取$\\delta$是所有這種非等邊$e=(a,b)$的$L _ a + L _ b - w_e$的最小值，這樣就能確定我們每次調整頂標都會至少多一條等邊(也至少多一個點跑到樹上！)，並且原有的等邊不會變少(如果你不確定可以看下面的圖想一下為什麼)。  注意到所謂樹上的點就是在 dfs 有走到的點owo\n扣得 以下是一個$\\mathcal{O}(n^4)$的版本。\n首先是宣告和建圖的部份。 g[a][b] 代表$e=(a,b)$的權重$w_e$； lx[i], ly[j] 分別代表$L _ {x_i}, L _ {y_i}$， visx, visy 是用在dfs的時候； match[j]=i 代表$y_j$跟$x_i$匹配了，如果沒人跟他匹配則是 -1 。\n1 2 3 4 5 6 7 8 9 10 11 12  const int N = 125, inf = 1e9; int g[N][N]; int lx[N], ly[N]; int visx[N], visy[N], match[N]; int n; void init(int _n) { n = _n; for(int i = 0; i \u0026lt; n; i++) for(int j = 0; j \u0026lt; n; j++) g[i][j] = 0; } void addEdge(int a, int b, int weight) { g[a][b] = max(g[a][b], weight); }   接下來是我們的主程式\n1 2 3 4 5 6 7 8 9 10 11  int solve() { for(int i = 0; i \u0026lt; n; i++) { lx[i] = ly[i] = 0; for(int j = 0; j \u0026lt; n; j++) lx[i] = max(lx[i], g[i][j]); } for(int i = 0; i \u0026lt; n; i++) match[i] = -1; for(int i = 0; i \u0026lt; n; i++) while(!augment(i)) relabel(); int ans = 0; for(int j = 0; j \u0026lt; n; j++) if(match[j] != -1) ans += g[match[j]][j]; return ans; }   大家應該很好奇 augment(i) 跟 relabel() 怎麼寫的吧！事實上 augment(i) 就只是初始化 vis 陣列並且 dfs 只走等邊找增廣路徑；而 relabel() 就是用剛剛提到的方法修改頂標。程式碼如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  bool dfs(int i) { if(visx[i]) return false; visx[i] = true; for(int j = 0; j \u0026lt; n; j++) if(!visy[j]) { int d = lx[i] + ly[j] - g[i][j]; if(d == 0) { visy[j] = true; if(match[j] == -1 || dfs(match[j])) { match[j] = i; return true; } } } return false; } bool augment(int x) { for(int i = 0; i \u0026lt; n; i++) visx[i] = visy[i] = false; return dfs(x); } void relabel() { int delta = inf; for(int i = 0; i \u0026lt; n; i++) if(visx[i]) { for(int j = 0; j \u0026lt; n; j++) if(!visy[j]) { delta = min(delta, lx[i] + ly[j] - g[i][j]); } } for(int i = 0; i \u0026lt; n; i++) if(visx[i]) lx[i] -= delta; for(int j = 0; j \u0026lt; n; j++) if(visy[j]) ly[j] += delta; }   時間複雜度 每次dfs並重新標號的時間是 $\\mathcal{O}(n^2)$ ，對於每個 $x_i$ ，最多就只要調整 $n$ 次頂標就能成功增廣，找到跟他配的 $y_j$ ，因為每次調整頂標都會至少多出一個 $y_j$ 和 $x_i$ 可以透過等邊連通。所以總時間複雜度是 $\\mathcal{O}(n^4)$ 。\nslack優化 這個演算法實際上可以簡單的優化到 $\\mathcal{O}(n^3)$ 。瓶頸在於 while(!augment(i)) relabel(); 這部份。\n對於每個沒有在交錯樹內的 $y_j$ ，我們維護一個變數 slack[j] ，維護 $\\min (L _ {x_i} + L _ {y_i} - w _ {(x_i, y_j)})$ ，其中 $x_i$ 必須在交錯樹上。這樣子每次 relabel() 要找 $\\delta$ 就只要花 $\\mathcal{O}(n)$ 了，但是如果仍然重設 vis 陣列每次從 $x_i$ dfs 那時間複雜度也沒變，畢竟 dfs 是 $\\mathcal{O}(V+E)$ 的事情。\n首先，注意到做完頂標的調整之後，樹上的點 slack 不會有變化；反之不在樹上的 $y_j$ 我們則可以知道他的 slack 減少了 $\\delta$ 。接著，假如調整完頂標之後找到了增廣路徑，路徑的端點會是不在交錯樹上的 $y _ j$ 並且 slack[j] 是0的形式，因此我們每次不應該重設 vis ，而是應該檢查是否有包含這些點的增廣路徑，或是讓交錯樹擴展。\n因為我們不重設 vis ，每個點最多被 dfs 一次，會跑滿他的 $n$ 個鄰居，所以在一個 $x_i$ 的phase當中 dfs 的總複雜度是 $\\mathcal{O}(n^2)$\n這邊附上一份可以AC TIOJ 1042的code。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92  #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int inf = 1e9; struct KuhnMunkres { int n; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; g; vector\u0026lt;int\u0026gt; lx, ly, slack; vector\u0026lt;int\u0026gt; match, visx, visy; KuhnMunkres(int n) : n(n), g(n, vector\u0026lt;int\u0026gt;(n)), lx(n), ly(n), slack(n), match(n), visx(n), visy(n) {} vector\u0026lt;int\u0026gt; \u0026amp; operator[](int i) { return g[i]; } bool dfs(int i, bool aug) { // aug = true 表示要更新 match  if(visx[i]) return false; visx[i] = true; for(int j = 0; j \u0026lt; n; j++) { if(visy[j]) continue; // 一邊擴增交錯樹、尋找增廣路徑  // 一邊更新slack：樹上的點跟樹外的點所造成的最小權重  int d = lx[i] + ly[j] - g[i][j]; if(d == 0) { visy[j] = true; if(match[j] == -1 || dfs(match[j], aug)) { if(aug) match[j] = i; return true; } } else { slack[j] = min(slack[j], d); } } return false; } bool augment() { // 回傳是否有增廣路  for(int j = 0; j \u0026lt; n; j++) if(!visy[j] \u0026amp;\u0026amp; slack[j] == 0) { visy[j] = true; if(match[j] == -1 || dfs(match[j], false)) { return true; } } return false; } void relabel() { int delta = inf; for(int j = 0; j \u0026lt; n; j++) if(!visy[j]) delta = min(delta, slack[j]); for(int i = 0; i \u0026lt; n; i++) if(visx[i]) lx[i] -= delta; for(int j = 0; j \u0026lt; n; j++) { if(visy[j]) ly[j] += delta; else slack[j] -= delta; } } int solve() { for(int i = 0; i \u0026lt; n; i++) { lx[i] = 0; for(int j = 0; j \u0026lt; n; j++) lx[i] = max(lx[i], g[i][j]); } fill(ly.begin(), ly.end(), 0); fill(match.begin(), match.end(), -1); for(int i = 0; i \u0026lt; n; i++) { // slack 在每一輪都要初始化  fill(slack.begin(), slack.end(), inf); fill(visx.begin(), visx.end(), false); fill(visy.begin(), visy.end(), false); if(dfs(i, true)) continue; // 重複調整頂標直到找到增廣路徑  while(!augment()) relabel(); fill(visx.begin(), visx.end(), false); fill(visy.begin(), visy.end(), false); dfs(i, true); } int ans = 0; for(int j = 0; j \u0026lt; n; j++) if(match[j] != -1) ans += g[match[j]][j]; return ans; } }; signed main() { ios_base::sync_with_stdio(0), cin.tie(0); int n; while(cin \u0026gt;\u0026gt; n \u0026amp;\u0026amp; n) { KuhnMunkres KM(n); for(int i = 0; i \u0026lt; n; i++) { for(int j = 0; j \u0026lt; n; j++) { int c; cin \u0026gt;\u0026gt; c; if(c \u0026gt; 0) KM[i][j] = c; } } cout \u0026lt;\u0026lt; KM.solve() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } }   小結 這次的筆記問了好多人\u0026gt; \u0026lt;還借圖論的書來看，不過還是輸光光不會證明。\n參考了日月卦長的網站跟slide超級多，還有OI wiki之類的，我自己覺得他們的code都寫的好醜(X\n如果有什麼不清楚或是覺得哪裡有問題歡迎通知我。\n另外寫這份筆記的時候有想到有沒有像Hopcroft Karp一樣用BFS就能加速之類的，不過我猜應該是沒有\n","permalink":"https://omeletwithoutegg.github.io/2020/11/16/Maximum-Weight-Bipartite-Matching/","tags":["tutorial","template","graph","matching"],"title":"二分圖最大權匹配"},{"contents":"AtCoder Regular Contest 106 最近一直被ZCK推坑，vir了好幾場ARC\n然後打完AGC才發現自己rating太低unrated，爛死XD\n結果打完這場還是不到能夠rated的標準1200 QQ\n然後想說寫一下題解好了 :P\nA. 106 Statement 給你$N$，問你有沒有正整數$A,B$使得$3^A+5^B = N$，$N \\leq 10^{18}$\nSolution 因為$A,B$最多都是$\\log$量級的所以亂枚舉就好了\n基本上也不太會溢位\nAC CODE\nB. Values Statement 給你一張無向圖，還有每個點一開始寫的數字$a_i$\n每次可以把兩個相鄰的點$x,y$一個數字+1一個數字-1\n問你是否能讓最後第$i$個點寫的數字是$b_i$\n$1 \\leq N \\leq 2 \\times 10^5$\n$0 \\leq M \\leq 2 \\times 10^5$\n$-10^9 \\leq a_i, b_i \\leq 10^9$\nSolution 只要一個連通塊裡$a_i$的總和和$b_i$的總和相同就做的到\n於是用 dsu 維護總和\nAC CODE\nC. Solutions 一開始想說這題題敘很長先跑去做 pD\n結果是水題，不過還是WA慘QQ\nStatement 「給你$N$個線段，請選出最多條兩兩完全不相交的線段。。」\n現在有兩種演算法$A,B$分別嘗試解決上述問題：\n $A$演算法：按照右界由小到大排序，並按照順序考慮線段。如果現在考慮的線段不會和當前的解的任何一條相交，則將其加入當前的解中。輸出最後的解的大小 $B$演算法：按照左界由小到大排序，並按照順序考慮線段。如果現在考慮的線段不會和當前的解的任何一條相交，則將其加入當前的解中。輸出最後的解的大小  請構造一組輸出使得「$A$輸出的答案 - $B$輸出的答案 = $M$」\n注意你構造的線段端點必須是不大於$10^9$的正整數，而且全部相異\n$1 \\leq N \\leq 10^5$\n$-N \\leq M \\leq N$\nSolution 因為$A$演算法會是這個問題的最佳解，所以$M\u0026lt;0$是無解\n首先$B$演算法一定至少會拿一個線段，所以$M=N$一定無解\n$M=N-1$的話表示有一個拿所有線段的解，也就是所有線段都不相交，$B$會和$A$有同樣的輸出，也是無解\n對於$0 \\leq M \u0026lt; N-1$的case，先構造$N-1$條完全不相交的線段，接著考慮把剩下來的那條當作左界最小的，讓他和後面$N-1$個線段中的前$M+1$條相交，於是$A,B$演算法的輸出將會相差$M$\n我在賽中一開始沒注意到$N = 1$的case，特判$N = 1, M = 0$才AC QQ\nAC CODE\nD. Powers Statement 給你長度$N$的序列$A = (A_1,A_2,\\dots,A_N)$以及$K$\n對於所有$1\\leq X\\leq K$\n請輸出$\\left( \\sum\\limits _ {i=1}^{N-1}\\sum\\limits _ {j=i+1}^N (A_i + A_j) ^ X \\right) \\pmod{998244353}$\nSolution 煩躁推式子\n我不擅長QQ花好久\n首先$\\sum\\limits _ {i=1}^{N-1}\\sum\\limits _ {j=i+1}^N (A_i + A_j) ^ x = \\frac{1}{2}\\left(\\sum\\limits _ {i=1}^N\\sum\\limits _ {j=1}^N (A_i + A_j) ^ X - \\sum\\limits _ {i=1}^N (2A_i)^X \\right)$，先把$i \u0026lt; j$的條件拔掉\n然後發現\n$$\n\\sum _ {i=1}^N \\sum _ {j=1}^N (A_i + A_j)^X = \\sum _ {i=1}^N \\sum _ {j=1}^N \\sum _ {p=0}^X \\binom{X}{p} A_i^p A_j^{X-p} = \\sum _ {p=0}^X \\binom{X}{p} \\left( \\sum _ {i=1}^N A_i^p \\right) \\left( \\sum _ {i=1}^N A_i^{X-p} \\right)\n$$\n對於$0\\leq p\\leq K$預處理$\\sum\\limits _ {i=1}^N A_i^p$就能$K^2$算出來了，總時間複雜度是$\\mathcal{O}(NK+K^2)$\nAC CODE\n後面都是賽後才寫出來的題目QQ我就爛\nE. Medals 我覺得這題真的很有趣，沒寫出來好可惜\nStatement 有$N$個員工，以今天為基準，第$i$個員工會先工作$A_i$天，接著放假$A_i$天，又工作$A_i$天、放假$A_i$天，周而復始。\n每天會頒發一個獎牌給有來工作的其中一個員工。當然如果當天沒有員工來工作就不會頒發任何獎牌。\n現在想請問你，在最佳的情況下，最少要多少天，才能讓所有員工都得到至少$K$面獎牌？\n$1 \\leq N \\leq 18$\n$1 \\leq K \\leq 10^5$\n$1 \\leq A_i \\leq 10^5$\nSolution 最近才vir到一場需要Hall\u0026rsquo;s theorem的題目XD馬上就用到\n我的解是考慮對答案二分搜\n對於一個固定的天數$D$，想像一張有$D+NK$個頂點的二分圖，兩部份分別代表每一天以及每個人的$K$個獎牌，並且如果該天可以頒給那個人獎牌就連一條邊，那麼我們想要知道的就是是否有一個大小$NK$的匹配。\n假設$A$是$NK$個頂點中的一個subset，$\\Gamma(A)$是其鄰居，包含一些代表天數的頂點\n那麼，根據Hall\u0026rsquo;s theorem，有那樣的完美匹配若且唯若$\\forall A, |A| \\leq |\\Gamma(A)|$\n不失一般性只需要枚舉$2^N$種組合，因為代表同一個人的頂點選再多個都不會影響鄰居的集合\n接下來就是我因為不熟而沒在賽中寫完的部份QQ\n為了對於所有subset都確認不等式的條件，我們必須知道有多少天會影響到這個subset的點\n注意答案最多是$2K\\sum A_i$，因此可以預處理每天可以對應到的鄰居\n假設$Cnt_s$代表在$D$天內有多少天對應到$s$這個subset，以及$Day_s$代表有多少天會影響到$s$這個subset\n那麼\n$$\nDay_s = \\sum _ {t \\\u0026amp; s \\neq 0} Cnt_t\n$$\n用SOS DP或是被稱為Fast Zeta Transform的技巧可以在$\\mathcal{O}(N2^N)$的時間複雜度內計算。\n總時間複雜度是$\\mathcal{O}((C+N2^N)\\log C)$，其中$C = 2K\\sum A_i$。聽說$C$可以壓到$\\mathcal{O}(NK)$不過我不太會OAO\nAC CODE\nF. Figure Statement 有一個玩具有$N$個零件，還有$N-1$個連接部件\n第$i$個零件上面有$d_i$個孔\n每個孔只能和一個連接部件連接，每個連接部件可以透過孔連接兩個零件\n問你有多少不同的連接方式把所有零件組裝在一起。\n注意零件上面的孔是相異的，但是所有連接部件都是相同的。\n也就是說，兩種連接方式$T_1, T_2$相同，若且唯若所有在$T_1$中的連接部件$e_1$，在$T_2$中都有對應的$e_2$，兩端的零件編號以及孔編號完全相同。\nSolution 我們將會介紹一種方法計算完全圖的生成樹有幾種，並且仿照該方式計算此問題的答案。\n 假設$N$個點的完全圖有$X$個生成樹。對於某個生成樹，可以任意定一個點當作根，並且把$N-1$個邊加上編號，這樣的方式總共有$X \\times N \\times (N-1)!$種。 用另一種觀點來看邊有標號的有根樹數量。每一步我們加上一條有向邊，考慮加邊加到現在的生成森林，這一步加上去的有向邊的起點可以是任何一個點，但是終點必須是某個連通塊的根，而且不能是同一個連通塊。也就是說，在第$i$輪有$N \\times (N-i)$種選擇，因為除了自己以外的連通塊有$N-i$個。於是總方法數是$\\prod\\limits _ {i=1}^{N-1} N (N-i) = N^{N-1} (N-1)!$ $X \\times N \\times (N-1)! = N^{N-1} (N-1)! \\Rightarrow X = N^{N-2}$  同樣地，我們先假設本題的答案是$X$，並且令$S = \\sum d _ i$\n 考慮某種連接零件的方式，並且把$N-1$個邊加上編號，這樣的方式總共有$X \\times (N-1)!$種。 首先，先在每個零件選擇一個特殊孔，大致上是負責當作那個點和他的父節點連接的孔。在前$N-2$步，我們每次加上一條邊，其中一個端點可以是任何還沒用過的孔，但是不能是特殊孔；而另一個點必須是某個連通塊的根的特殊孔。這樣在第$i$輪有$(S - N - i + 1) \\cdot (N - i)$種方法。最後一步，剩下兩個連通塊，我們把他們的特殊孔連在一起。這樣有$\\prod\\limits d _ i \\cdot \\prod\\limits _ {i=1}^{N-2} (S - N - i + 1) (N - i)$種方法。 故 $X = \\prod\\limits d_i \\prod\\limits _ {i=0}^{N-3} (S - N - i)$  這題是我跑去找別人的解QQ\n我看了好多解，好像都有用到Cayley定理甚至生成函數之類的QAQ好噁心\n找了好久最後看到官方youtube的講解才聽懂\nAC CODE\n總結 這次有點可惜沒做出E QQ\n然後看別人blog的時候驚訝他怎麼那麼厲害orz\n希望某次有機會破台ARC\n","permalink":"https://omeletwithoutegg.github.io/2020/10/26/ARC-106/","tags":["AtCoder","math","graph"],"title":"ARC-106"},{"contents":"好久又沒有發文了\n來講講上一次發文之後我都在做什麼好了\nBefore IOI 首先在8/17開始所謂的賽前集訓\n總共為期三周，分別在台南、新竹和台北\n在台南的前幾天是一個奇怪的教授要我們寫爛題目\n還得用PC2 judge，不過我們最後都變成在玩python in one line了\n之後他又講了有關點連通、邊連通跟degree之類的關係\n後來吳邦一教授來講課，他講了一些IOI的題目還有一些常見的trick，例如四邊形之類的\n那時候就能看出來我超爛(((\n週末是在師大上王柄豐的課\n這時似乎已經累計很多他丟的題目沒寫了QQ\n下一個禮拜是在清大和交大\n第一天韓永楷教授早上早上上的有點基礎，不過下午上的東西還蠻有趣的\n另外有遇到吳宗達跟盧可瑜(?) 還聽到了奇怪的洋蔥式資料結構\n第二天是蔡孟宗教授講parametric search跟matroid之類的東西\n雖然matroid和submodular的東西我是幾乎聽不懂，不過我覺得這天的課都還算是有趣\n第三天是蔡錫鈞教授，我一開始感覺他不是很友善，然後外加上我超想睡，而且其實頗難的，課聽進去的沒有多少QQ\n下午的時候謝旻錚教授找了hank來跟我們virtual IOI2017\n想當然而我被打爆，而且AY還贏了hank，超強orzzzz\n晚上被教授請客XD不過餐廳有點太高級不敢吃什麼東西\n周五的時候謝旻錚教授講了一些計算幾何的東西，感覺只要提到簡單多邊形就是超級噁心的@@\n回到台北之後都是王柄豐的課了\n終於聽到了toptree，不過還沒有實作過QQ\n然後也把之前ICPC的題目程式碼給補了一點點\n啊IOI也vir了幾場 可是總感覺沒有胸有成竹的感覺\n只能說IOI比成這樣真的是自己練習不足啊\n在集訓完到IOI這中間有空一個禮拜，而且還是在開學期間，實在有夠尷尬\n總之我把他當成有公假，而我們的校內賽初賽也是在這個禮拜，正好可以回去確認狀況以及去校內培訓玩玩(?)\n話說我們這屆的人能出校內賽其實算神奇\n原因是因為我們幾個有進過全國賽不會在北市賽佔到建中的名額，所以老師就找我們來出題目\n雖然我們出的題目好像沒有說很好QQ\n不過初賽感覺問題比較像是當天流程沒有仔細check好QQ\nAfter IOI 回到教室有種更尷尬的感覺\n不過總之周一下午跟著蕭梓宏他們跑去台大上了微積分一\n前面幾堂講的實在好基礎(#)\n另外我周三和周五的早上有去旁聽線性代數\n上了幾天的課之後\n我發現我就算沒去台大修課，大家也剛好會去，因為班上沒人自然就沒辦法上課\n再加上我也沒有修這學期的數理課程，事實上我幾乎沒有課需要上啊OAO\n要擔心的只有國文/英文/藝術與生活/體育，我覺得英文應該是最佳選擇\n我上微積分的第二個禮拜就開始感覺困難了orz\n總之希望是可以好好修完\n校內賽複賽變成是有點尷尬，因為我們流程是我們出題、老師選題，啊又剛好沒選到太多水題或是學長的題目QQ\n我覺得我應該當初直接寫出來說推薦可以直接選哪些題\n而且老實說也應該出幾題培訓有講過的東西，自己的盲點真的自己看不到@@\n大家當天的分數普遍都很低\n不過至少最後預期會進的人大部份都進了，還算是幸運\n在中秋連假的時候我買了一把新鍵盤，是ducky one的60%紅軸，用起來真的只能說超爽的wwww紅軸軟又軟，啊鍵位也都整個習慣了之後小巧的它就很有魅力wwww\n現在我的書包裡面除了筆電跟軟軟以外還多了鍵盤這個常駐物品\nEsc離手指超近而且方向鍵又被拔掉超爽的XDDDD\n可是有一個重大問題是用注音打字的時候我習慣按方向鍵XDD 所以還是得跑去弄組合鍵\n總之，希望我以後還能夠常常用到這把鍵盤，還有希望他能陪我很久\n","permalink":"https://omeletwithoutegg.github.io/2020/10/06/after-IOI/","tags":["experience"],"title":"Recent"},{"contents":"國培第二周 原本的課是在周六和周日的上午\n似乎因為需要電力檢修還是什麼的都被移到周日了\n週日 上課的教授是王柄豐，他都會先丟給我們一些題目然後過幾個小時再來叫我們上台\n原本是兩天各三題ICPC final的題目，不過全都被移到周日總共是六題\n我也忘記他丟哪些題目了，不過我記得我早上上去講一個rerooting+分塊凸包優化的算法之後就被重剖作法電爆了QQ\n下午我找到一題最短路去講，後來以為只會經過一條邊不用跑最短路，結果被教授抓到假解XD不過只要跑最短路應該是對的\n教授也跟我們說，上他的課想到一個做法不一定要急著實作出來，只要把想法確認好就好\n花了整個早上實作分塊凸包優化的我直接中槍QQ\nEND 中午第一次在國培吃便當XDD 好油(?)\n之前都是吃拉麵(#\n另外我們這禮拜有配飯吃看動畫，油上加油呢\n看了RE:0、魔王什麼的、史萊姆，還有格里爾的賢者時間XD，超污\n晚上跑去吃山嵐，第一次點赤湯，沒想到意外的不那麼辣，看起來明明是全紅的www\n然後東東曹宸睿好像要趕去報到AIS3就散會ㄌ\n","permalink":"https://omeletwithoutegg.github.io/2020/08/05/TOI-2020-7-26-weekend/","tags":null,"title":"國培 week 2"},{"contents":"國培第一週 週五 前一天東東跟曹宸睿跑去住宿，似乎是住在捷絲旅（好好），不過他們的晚餐費只有一百元XD\n至於我則是在考完資格考後又忙著去YTP初賽，並且發現自己被最後一題電爆QQ\n因為17號是鳥人食雞日所以我拉一些人去ㄘ鳥人，加上加點的總共可以有八片雞肉叉燒，超爽。\n週六 前一天不知道吃了什麼毒超早睡OAO可是起床又超晚，最後遲到了十幾分鐘到，不過好像是沒差owo\n早上是王弘倫教授講IOI的詳細規則，詳細到我不知道怎麼形容。\n他還講了四模pC的題解(?)還有丟一題 Christmas 類似斜率優化但是好像有四邊形優化的性質，總之一整個好強OAO。\n下午跑去西門町訂做西裝，原本以為會是常常看到的那種沒什麼裝潢普通店面（海派那種），結果是一家看起來超高級的西裝店，\n好像叫ElegaZzle，之前應該是完全沒聽說過\n我們一群人都是穿著T-shirt加短褲還有布鞋，我一整個鄉下人長見識了(?)\n選定布料還有樣式的時候選有夠久，三個人一起選還是有選擇障礙，尤其因為選擇超多，大概有幾十種布料可以選擇\n選了西裝的布料後又得選領口的樣式、襯衫的布料、襯衫的樣式、鈕扣、袖口要繡上的名字blablabla。\n總之做了很困難的選擇之後來到更困難的部分：量尺寸\n我超胖QQ太sad了，一開始大概量了一個尺寸換上去後肚子那邊好緊（眼睛也看的出來）\n然後我還被要求在門口量尺寸QQ，超級羞恥play(#\n順帶一提這家店有一個很酷的房間可以掃描人體的3D模型，還有跟手機的藍芽弄一些特效，聽說曹宸睿的手機有閃退一次XD\n我們每一餐的餐費是一百元，我們決定把午餐和晚餐合在一起變成兩百元，這樣就可以ㄘ拉麵了，\n話說我這天也沒吃早餐，只靠一餐拉麵果腹，爽！\n好笑的是今天又跑去ㄘ鳥人（因為西門町太近ㄌ而且他們上次剛好錯過）\n這天嘗試了辛白湯，實在是頗辣的不過還不錯吃啦\n然後後來跑去踩踩安利美特、又走到北車地下街Y區，看到好多軟軟\u0026lt;3\u0026lt;3\n不過都沒買任何東西感覺有點浪費時間(#\n噢，最覺得浪費時間的可能是我跑去打音遊另外兩個人站在後面看的尷尬時間。\n周日 隔天早上沒有課，他們兩個又說晚半小時到，於是我想說可以安心吃早餐慢慢出門， 結果我還是晚他們到XD\n因為我前一天不小心玩壞OJDL，所以這個早上花了不少時間來修。\n一切的主因都是因為沒事update東西QQ，造成的影響到現在還沒修完\n這天修好的 bug 好像是因為沙盒有限制記憶體之類的，但是 update 之後的執行檔編譯出來不知道為什麼就爆炸了(?)\n好像在 g++ 的選項加個 -static 就修好了，完全不知道為什麼之前不會出事更新就會出事。\n下午的講師是張經略教授（對就是加菲貓教授）\n他仍然超酷，講的主題是 subexponential algorithms。首先講了subset sum和0/1背包的meet in the middle作法，中途還一直說「這個部分我不會……所以時間複雜度就是 $2^{N/2}$ + 我不會 + $2^{N/2} \\cdot (N/2)$ ……」，超好笑，O(我不會)的演算法。接著講了一個 $O^{ \\star }(3^{N/2})$ 的3-SAT確定性演算法，並且還有講了 $O^{ \\star }(3^{N/4})$的隨機演算法和一個O(我不會)的隨機演算法XD。\n接下來就變成討論「1-median selection in metric space」的一大堆東西， 這個問題主要是在問給一堆點，你要找到與其他點平均距離最小的一個點，很神奇的是可以隨機選一個夠多點的subset，然後對每個點只算與這個subset的平均距離之類的，會得到一個近似解。\n教授也分享了很多相關的結果，例如壓掉一個log或是在某種條件下變成超級好的複雜度之類的\n總之很難理解但是我大致上就邊開水題邊聽他講證明，可能因為我前一天晚睡超想睡覺的，最後真的累到不行了XD\n下午再度拉麵行，本來要去吃雞二但是又是到現場才發現他公休，明明google有寫qqq我超雷\n於是想說在附近隨便找吃的又放棄了，最後變成去中山站吃武藏神山（完全不知道為啥）\n加麵真香，雖然我好像不小心選到這家略貴，不過有些許甜味的厚叉燒兩片還是值得的！粗麵和湯頭我也很喜歡。\n接著就走路到北車，各自搭車解散 OwO！\n寫題呢QQ 我本來以為會刷一些OI題，不過看來我自己也還沒什麼動力（\n東東好像有一個ICPC培訓班的考試，十題裡面需要作出七題，而且全都超難的。\n全部應該都是OI題，有些我想半天都想不出來QQ\n我覺得我絕對就是那種少一點練習很快就退步的選手，\n這幾天就先從刷CF題開始吧(#\n還有希望暑假自己可以開心\u0026gt; \u0026lt;雖然很多事要掛心，不過跟其他人比起來我已經少很多煩躁ㄌ！\n話說這篇圖片好多，希望大家不要在半夜點進來發現太餓(X\n","permalink":"https://omeletwithoutegg.github.io/2020/07/20/TOI-2020-7-18-weekend/","tags":null,"title":"國培 week 1"},{"contents":"vim ?! vim : 古老的編輯器\n來由 之前 ZCK 很早就開始一直推坑 vim ，而我大概是在開始瘋狂玩 OJDL 之後才開始使用 vim 的\n因為在遠端 server 上改 code 最直接的方式就是使用遠端主機上的 vim 直接在 ssh 的介面改\n所以經過幾個月(我也不知道具體多久)我大概熟悉 vim 了之後，在我的筆電上也裝了 gvim\n因為是 windows 的所以用起來很怪，不過經過 Google 一些設定之後變得正常一些了\n至於我的筆電呢，我覺得裝 linux 的必要性還沒有麻煩性高(X\n而且感覺arch \u0026gt; Ubuntu但是裝了arch又會因為更新速度出現各種神奇的事件\n所以姑且先不裝(?)\n一些心得 我覺得 vim 的優點可能就是讓你可以只使用鍵盤編輯文件，\n再來就是你可以依照自己的喜好更改 vimrc 或是安裝插件\n此外記憶這些快捷鍵也是很有成就感的事情(?)\n變魔法的快速鍵就跟突然講起德語或上古漢語一樣吸引人目光\nmy vimrc 附上我自己的 vimrc\n一開始我沒有裝任何插件，後來查到一篇使用 Vundle 的就去載了\n最後跟風(?)改成用 vim-plug 管理所有插件\n物色自己喜歡的插件真的很難，可能害我熬夜了好幾次QQ\n不知道過了一段時間之後我的 vimrc 又會變成什麼樣子\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89  set nocompatibleset encoding=utf8set fileencoding=utf8\u0026#34;\u0026#34;\u0026#34; Plugins, use \u0026#39;vim-plug\u0026#39; to manage pluginscall plug#begin(\u0026#39;~/.vim/plugged\u0026#39;)Plug \u0026#39;hzchirs/vim-material\u0026#39;\u0026#34; Plug \u0026#39;flazz/vim-colorschemes\u0026#39;Plug \u0026#39;itchyny/lightline.vim\u0026#39;\u0026#34; Plug \u0026#39;vim-airline/vim-airline\u0026#39;Plug \u0026#39;mhinz/vim-startify\u0026#39;Plug \u0026#39;tpope/vim-fugitive\u0026#39; \u0026#34; :G [option] for git commandsPlug \u0026#39;preservim/nerdtree\u0026#39;, { \u0026#39;on\u0026#39;: \u0026#39;NERDTreeToggle\u0026#39; } \u0026#34; \u0026lt;F2\u0026gt; for toggle nerdtreePlug \u0026#39;Xuyuanp/nerdtree-git-plugin\u0026#39;, { \u0026#39;on\u0026#39;: \u0026#39;NERDTreeToggle\u0026#39; } \u0026#34; git statusPlug \u0026#39;kien/ctrlp.vim\u0026#39;, { \u0026#39;on\u0026#39;: \u0026#39;NERDTreeToggle\u0026#39; } \u0026#34; \u0026lt;C-p\u0026gt; for found filePlug \u0026#39;tpope/vim-commentary\u0026#39; \u0026#34; gc for comment\u0026#34; Plug \u0026#39;yuttie/comfortable-motion.vim\u0026#39;Plug \u0026#39;joker1007/vim-markdown-quote-syntax\u0026#39;\u0026#34; Plug \u0026#39;octol/vim-cpp-enhanced-highlight\u0026#39;call plug#end() \u0026#34; let c_no_curly_error=1 \u0026#34; enhanced highlight issue\u0026#34;\u0026#34;\u0026#34; GUI settingsif has(\u0026#39;gui_running\u0026#39;) au GUIEnter * simalt ~x \u0026#34; maximize window set guioptions-=m | set guioptions-=e | set guioptions-=T\u0026#34; menu | tab page | toolbar set guioptions-=L | set guioptions-=R | set guioptions-=l | set guioptions-=r\u0026#34; left scrollbar | right scrollbar | left scrollbar (split) | right scrollbar (split) set guifont=Microsoft\\ Yahei\\ Mono:h14 \u0026#34; for Windowsendif\u0026#34;\u0026#34;\u0026#34; Appearance\u0026#34; startify#center([\u0026#39;VIM - Vi IMproved\u0026#39;, \u0026#39;JIZZZZZZZZZZZZZZZ\u0026#39;, \u0026#39;OmeletWithoutEgg\u0026#39;])let g:startify_custom_header = []let g:startify_bookmarks = [\u0026#39;~/_vimrc\u0026#39;, \u0026#39;D:/project/randgum\u0026#39;, \u0026#39;D:/C++\u0026#39;, \u0026#39;D:/blog\u0026#39;]\u0026#34; :h g:lightline.colorschemelet g:lightline = { \\ \u0026#39;colorscheme\u0026#39;: \u0026#39;materia\u0026#39;, \\ \u0026#39;active\u0026#39;: { \u0026#39;left\u0026#39;: [ [ \u0026#39;mode\u0026#39;, \u0026#39;paste\u0026#39; ], [ \u0026#39;readonly\u0026#39;, \u0026#39;filename\u0026#39;, \u0026#39;modified\u0026#39;, \u0026#39;gitbranch\u0026#39; ] ] }, \\ \u0026#39;component_function\u0026#39;: { \u0026#39;gitbranch\u0026#39;: \u0026#39;FugitiveHead\u0026#39; } \\ }color vim-material\u0026#34; color desertau ColorScheme * hi Comment cterm=none gui=none | hi Search ctermfg=yellow guifg=yellow\u0026#34; disable italic comment and enable highlight search color\u0026#34;\u0026#34;\u0026#34; Basic Configurationsyntax onset nu rnu ai bs=2 et sw=4 sts=4 hlsset belloff=all laststatus=2set cursorline noshowmode lazyredraw termguicolorsaugroup rnutoggle au! au InsertEnter,InsertLeave * set rnu!augroup END\u0026#34;\u0026#34;\u0026#34; Edit Mappingsinoremap \u0026lt;C-c\u0026gt; \u0026lt;Esc\u0026gt;inoremap {\u0026lt;CR\u0026gt; {\u0026lt;CR\u0026gt;}\u0026lt;C-o\u0026gt;Onnoremap ya :%y+\u0026lt;CR\u0026gt;nnoremap \u0026lt;silent\u0026gt; \u0026lt;C-TAB\u0026gt; :tabn\u0026lt;CR\u0026gt;nnoremap \u0026lt;silent\u0026gt; \u0026lt;C-S-TAB\u0026gt; :tabp\u0026lt;CR\u0026gt;nnoremap \u0026lt;silent\u0026gt; \u0026lt;C-n\u0026gt; :tabnew\u0026lt;CR\u0026gt;:Startify\u0026lt;CR\u0026gt;nnoremap \u0026lt;silent\u0026gt; \u0026lt;A-j\u0026gt; :m.1\u0026lt;CR\u0026gt;==nnoremap \u0026lt;silent\u0026gt; \u0026lt;A-k\u0026gt; :m.-2\u0026lt;CR\u0026gt;==vnoremap \u0026lt;silent\u0026gt; \u0026lt;A-j\u0026gt; :m \u0026#39;\u0026gt;+1\u0026lt;CR\u0026gt;gv=gvvnoremap \u0026lt;silent\u0026gt; \u0026lt;A-k\u0026gt; :m \u0026#39;\u0026lt;-2\u0026lt;CR\u0026gt;gv=gvvnoremap \u0026gt; \u0026gt;gvvnoremap \u0026lt; \u0026lt;gvnnoremap \u0026lt;silent\u0026gt; \u0026lt;F2\u0026gt; :cd %:h\u0026lt;CR\u0026gt;:NERDTreeToggle\u0026lt;CR\u0026gt;\u0026#34;\u0026#34;\u0026#34; Build Commandsau BufEnter *.cpp call CppFastBuild()function CppFastBuild() nnoremap \u0026lt;F9\u0026gt; :w\u0026lt;CR\u0026gt;:!g++ % -o %:r -std=c++17 -Dlocal\u0026lt;CR\u0026gt;:!%:r\u0026lt;CR\u0026gt;\u0026lt;CR\u0026gt; nnoremap \u0026lt;F10\u0026gt; :!%:r\u0026lt;CR\u0026gt;\u0026lt;CR\u0026gt;endfunctionau BufEnter *.py call PythonFastBuild()function PythonFastBuild() nnoremap \u0026lt;F10\u0026gt; :w\u0026lt;CR\u0026gt;:cd %:h\u0026lt;CR\u0026gt;:!%\u0026lt;CR\u0026gt;\u0026lt;CR\u0026gt; nnoremap \u0026lt;F8\u0026gt; :w\u0026lt;CR\u0026gt;:cd %:h\u0026lt;CR\u0026gt;:!cmd\u0026lt;CR\u0026gt;\u0026lt;CR\u0026gt;endfunction  順帶一提在windows的gvim底下的vimrc路徑是 $HOME/_vimrc\n詳細解析! 為了推坑我用的所有東西我要來一一解釋他們的功能 owo\nPlugins 我使用vim-plug來管理插件們\n1 2 3 4  \u0026#34;\u0026#34;\u0026#34; Plugins, use \u0026#39;vim-plug\u0026#39; to manage pluginscall plug#begin(\u0026#39;~/.vim/plugged\u0026#39;) ...call plug#end()   用法非常簡單，而且自己用了什麼插件都一眼就能看出來，超棒的XD\nDisplay  vim-material：我現在用的 colorscheme vim-colorschemes：一個有很多 colorscheme 的 plugin，可以考慮從這裡開始物色喜歡的 lightline：底下的狀態列，用起來就是潮 airline：另一種狀態列，比較好看，但是對 windows 還是中文不友善所以我沒裝 startify 這超棒，讓你打開 vim 的時候會顯示最近的檔案，還有自訂 bookmark 跟 session 的功能(?)不過我還在摸索  Files and Git 在做專案的時候，樹狀目錄和git的功能肯定是不能少的\n尤其是裝了 nerdtree 這個插件後根本就變成IDE的樣子了XDD\n vim-fugitive：似乎是增強一些 git 的功能 nerdtree：可以在旁邊顯示樹狀目錄，做專案的時候頗有用 nerdtree-git-plugin：如果檔案有被 git 管理會在 nerdtree 顯示 git 狀態 ctrlp：尋找檔案的一個插件，不過我好像很少用\n注意到後面我有加 , { 'on': 'NERDTreeToggle' } ，也就是說這些插件在我開啟 nerdtree 時才會被 load 到 vim 裡面  Misc (?)  vim-commentary：為程式碼加上註解的快捷鍵 comfortable-motion：讓畫面在滑動的時候可以連續、平順的移動 vim-markdown-quote-syntax：可以幫 markdown 程式碼區塊上色，另外有一些 vim 跟 markdown 有關的插件不過我試用過後是覺得沒啥用處就刪掉了 vim-cpp-enhanced-highlight：幫 STL 容器等等更多 keyword 上色，不過我現在也沒開著這個功能。有一個括弧上色的錯誤還必須透過 let c_no_curly_error=1 來解決  GUI settings 首先第一行可以讓我怎麼打開 vim 都會幫我最大化螢幕\n因為我用的是 gvim ，所以預設會有一些選單和工具欄還有捲動條，我把他們全部禁用掉\n另外設定字體也只有有 GUI 的 vim 才能設置，終端機的 vim 會直接是終端機介面的字型\n我不太知道有什麼 windows 上包含中文的等寬字體，於是選用 Microsoft Yahei Mono ，英文是 Consolas 中文是雅黑體\n1 2 3 4 5 6 7 8  if has(\u0026#39;gui_running\u0026#39;) au GUIEnter * simalt ~x \u0026#34; maximize window set guioptions-=m | set guioptions-=e | set guioptions-=T\u0026#34; menu | tab page | toolbar set guioptions-=L | set guioptions-=R | set guioptions-=l | set guioptions-=r\u0026#34; left scrollbar | right scrollbar | left scrollbar (split) | right scrollbar (split) set guifont=Microsoft\\ Yahei\\ Mono:h14 \u0026#34; for Windowsendif  Appearance 1 2 3 4 5 6 7 8 9 10 11 12 13  \u0026#34; startify#center([\u0026#39;VIM - Vi IMproved\u0026#39;, \u0026#39;JIZZZZZZZZZZZZZZZ\u0026#39;, \u0026#39;OmeletWithoutEgg\u0026#39;])let g:startify_custom_header = []let g:startify_bookmarks = [\u0026#39;~/_vimrc\u0026#39;, \u0026#39;D:/project/randgum\u0026#39;, \u0026#39;D:/C++\u0026#39;, \u0026#39;D:/blog\u0026#39;]\u0026#34; :h g:lightline.colorschemelet g:lightline = { \\ \u0026#39;colorscheme\u0026#39;: \u0026#39;materia\u0026#39;, \\ \u0026#39;active\u0026#39;: { \u0026#39;left\u0026#39;: [ [ \u0026#39;mode\u0026#39;, \u0026#39;paste\u0026#39; ], [ \u0026#39;readonly\u0026#39;, \u0026#39;filename\u0026#39;, \u0026#39;modified\u0026#39;, \u0026#39;gitbranch\u0026#39; ] ] }, \\ \u0026#39;component_function\u0026#39;: { \u0026#39;gitbranch\u0026#39;: \u0026#39;FugitiveHead\u0026#39; } \\ }color vim-material\u0026#34; color desertau ColorScheme * hi Comment cterm=none gui=none | hi Search ctermfg=yellow guifg=yellow\u0026#34; disable italic comment and enable highlight search color  startify 最上面預設會顯示一隻不知道什麼生物說出隨機名人的名言，不過我覺得太占空間於是選擇都不顯示，另外也可以用任何自定義的文字或 ascii art。\nstartify 的書籤似乎有更好的使用方法，不過我目前是 hardcode 寫在這裡\nlightline 超潮的，還可以跟 fugitive 配合一起用\n我的 colorscheme vim-material 的 C++ 註解是斜體的，會讓我模板的AC變得不好看所以我下面把它給取消；另外搜尋時預設是底線但我覺得太不清楚於是加上黃色凸顯搜尋結果\n順帶一提 au 是 autocmd 的縮寫，hi 是 highlight 的縮寫， color 是 colorscheme 的縮寫\nBasic Configuration 1 2 3 4 5 6 7 8  syntax onset nu rnu ai bs=2 et sw=4 sts=4 hlsset belloff=all laststatus=2set cursorline noshowmode lazyredraw termguicolorsaugroup rnutoggle au! au InsertEnter,InsertLeave * set rnu!augroup END  這些設定是在終端機也可以用的(應該啦)\n syntax on：開啟 syntax highlight set nu rnu：分別是number跟relativenumber的縮寫，顯示絕對與相對行號 set ai：autoindent，自動接續上一行縮排。雖然似乎檔名是 cpp 的話就會好好幫你自動縮排 set bs=2：等價於set backspace=indent,eol,start，讓 backspace 可以刪除換行、自動產生的縮排還有在進入該次 insert mode 之前打的字 set et sw=4 sts=4：等價於set expandtab shiftwidth=4 softtabstop=4，因為我習慣讓所有縮排從 tab 變成 4 個空白 set hls：在搜尋的時候能夠高亮度凸顯 set belloff=all：關掉錯誤時的鈴聲 set laststatus=2：顯示狀態列 set cursorline：在當前游標那一行上色 set noshowmode：因為 lightline 已經有顯示目前模式所以不需要再額外顯示目前模式 set lazyredraw：有些 macro 執行會有點雜亂所以讓他先執行完再顯示最後結果就好 set termguicolors：原本是想讓終端機也能好好上色，不過我好像不可能會在 windows 上用終端機的 vim XD\n最後的 augroup 是我希望在 insert mode 和其他模式下分別會顯示絕對行號和相對行號  Mappings 1 2 3  inoremap \u0026lt;C-c\u0026gt; \u0026lt;Esc\u0026gt;inoremap {\u0026lt;CR\u0026gt; {\u0026lt;CR\u0026gt;}\u0026lt;C-o\u0026gt;Onnoremap ya :%y+\u0026lt;CR\u0026gt;  因為 esc 離我太遠了所以我最近開始用 Ctrl+C 代替，不過它不會被幫我執行切換絕對與相對行號的 autocmd 偵測到，所以我又跑去 map 它\n在一些嘗試之後我發現只有大括弧的補全我延續得比較順手以及美觀，我設定在上大括弧後若換行則會補上下大括弧並在中間插入一行\n在打 CF 的時候常常會用到全選但是四個字的指令讓人很急所以我 map ya 當作全選\n1 2 3  nnoremap \u0026lt;silent\u0026gt; \u0026lt;C-TAB\u0026gt; :tabn\u0026lt;CR\u0026gt;nnoremap \u0026lt;silent\u0026gt; \u0026lt;C-S-TAB\u0026gt; :tabp\u0026lt;CR\u0026gt;nnoremap \u0026lt;silent\u0026gt; \u0026lt;C-n\u0026gt; :tabnew\u0026lt;CR\u0026gt;:Startify\u0026lt;CR\u0026gt;  這三個是關於開新分頁，我在 code::blocks 和 chrome 都習慣會切分頁\n另外我發現 startify 很適合放在新增一個分頁的時候\n1 2 3 4 5 6  nnoremap \u0026lt;silent\u0026gt; \u0026lt;A-j\u0026gt; :m.1\u0026lt;CR\u0026gt;==nnoremap \u0026lt;silent\u0026gt; \u0026lt;A-k\u0026gt; :m.-2\u0026lt;CR\u0026gt;==vnoremap \u0026lt;silent\u0026gt; \u0026lt;A-j\u0026gt; :m \u0026#39;\u0026gt;+1\u0026lt;CR\u0026gt;gv=gvvnoremap \u0026lt;silent\u0026gt; \u0026lt;A-k\u0026gt; :m \u0026#39;\u0026lt;-2\u0026lt;CR\u0026gt;gv=gvvnoremap \u0026gt; \u0026gt;gvvnoremap \u0026lt; \u0026lt;gv  這些是我從 code::blocks 帶來的習慣，我常常把一行或一塊程式碼上下拉，或者增加/減少縮排等等\n1  nnoremap \u0026lt;silent\u0026gt; \u0026lt;F2\u0026gt; :cd %:h\u0026lt;CR\u0026gt;:NERDTreeToggle\u0026lt;CR\u0026gt;  我讓 F2 是開啟當前檔案的樹狀目錄的快捷鍵\nBuild Commands 身為一個前 code::blocks 使用者，快速編譯是不可少的\n在前面加了 :w 讓我不用按存檔再編譯\n自定義這些鍵位真舒服\n1 2 3 4 5 6 7 8 9 10 11  au BufEnter *.cpp call CppFastBuild()function CppFastBuild() nnoremap \u0026lt;F9\u0026gt; :w\u0026lt;CR\u0026gt;:!g++ % -o %:r -std=c++17 -Dlocal\u0026lt;CR\u0026gt;:!%:r\u0026lt;CR\u0026gt;\u0026lt;CR\u0026gt; nnoremap \u0026lt;F10\u0026gt; :!%:r\u0026lt;CR\u0026gt;\u0026lt;CR\u0026gt;endfunctionau BufEnter *.py call PythonFastBuild()function PythonFastBuild() nnoremap \u0026lt;F10\u0026gt; :w\u0026lt;CR\u0026gt;:cd %:h\u0026lt;CR\u0026gt;:!%\u0026lt;CR\u0026gt;\u0026lt;CR\u0026gt; nnoremap \u0026lt;F8\u0026gt; :w\u0026lt;CR\u0026gt;:cd %:h\u0026lt;CR\u0026gt;:!cmd\u0026lt;CR\u0026gt;\u0026lt;CR\u0026gt;endfunction  結語 一個完全客製化的編輯器真的頗吸引人，不過有時候還是得妥協的地方\n找插件找超久不如改變自己的習慣或是 vimrc 來解決問題(或者解決提出問題的人XD)\n另外最近好久沒發文，好廢喔，不知道下一篇題解會什麼時候出現(?)\n","permalink":"https://omeletwithoutegg.github.io/2020/07/08/Using-Vim/","tags":["vim","linux"],"title":"Using-Vim"},{"contents":"Ch2. Section 9. 補魔力的條件 https://tioj.ck.tp.edu.tw/problems/1764\nDescription  現在有排成一直線的$N$個格子，從左到右編號為$1 \\dots N$，每個格子都有自己的高度 一開始你站在第一格，每次移動都只能往編號大的格子跳，目標是走到第$N$格 假設第$i$個格子的高度是$x_i$，從格子$i$跳到格子$j$需要耗費$\\max(0, (j-i)+(x_j-x_i))$的力氣\n請問在花最少力氣到達終點的前提下，他最多可以跳幾次?  Solution 先考慮最小化力氣\n令$x_i+i = v_i$，簡單的列出DP式\n$$\ndp[i] = \\min _ {j \u0026lt; i}(dp[j] + \\max(0,v_j-v_i))\n$$\n這樣的複雜度是$\\mathcal{O}(N^2)$\n不過可以分case討論\n$$\ndp[i] = \\min(\n\\min _ {j \u0026lt; i \\wedge v_j \\geq v_i}(dp[j]+v_j)-v_i,\n\\min _ {j \u0026lt; i \\wedge v_j \u0026lt; v_i}(dp[j])\n)\n$$\n就可以用資料結構$\\mathcal{O}(N \\log N)$維護了\n那麼最多可以跳的次數也可以一邊維護\n也就是說如果力氣不同就選力氣小的，力氣相同則選跳的次數多的，可以直接用pair做就好\n這邊寫的是值域壓縮之後用BIT維護前後綴min OAO\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  #pragma GCC optimize(\u0026#34;Ofast\u0026#34;) #pragma loop_opt(on) #include \u0026lt;bits/stdc++.h\u0026gt;#define ff first #define ss second  using namespace std; typedef int64_t ll; constexpr ll N = 300025, INF = 1e18; struct BIT { pair\u0026lt;ll,int\u0026gt; mn[N]; int n; void init(int _n) { n = _n; for(int i = 1; i \u0026lt;= n; i++) mn[i] = {INF, 0}; } void edit(int p, pair\u0026lt;ll,int\u0026gt; d) { for(; p \u0026lt;= n; p += p\u0026amp;-p) mn[p] = min(mn[p], d); } pair\u0026lt;ll,int\u0026gt; query(int p) { pair\u0026lt;ll,int\u0026gt; res = {INF, 0}; for(; p \u0026gt; 0; p -= p\u0026amp;-p) res = min(res, mn[p]); return res; } } pre, suf; signed main() { ios_base::sync_with_stdio(0), cin.tie(0); // dp[i] = min{dp[j] + max(v[i] - v[j], 0)};  // dp[i] = min{v[i] + dp[j]-v[j] | v[i] \u0026gt;= v[j]}, min{dp[j] | v[i] \u0026lt; v[j]}  // dp[1] = {0, 0}  int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; vector\u0026lt;int\u0026gt; h(n); for(int \u0026amp;x: h) cin \u0026gt;\u0026gt; x; vector\u0026lt;int\u0026gt; u = h; sort(u.begin(), u.end()), u.erase(unique(u.begin(), u.end()), u.end()); for(int \u0026amp;x: h) x = lower_bound(u.begin(), u.end(), x) - u.begin() + 1; pre.init(u.size()); suf.init(u.size()); pre.edit(h[0], {-h[0], 0}); suf.edit(u.size()+1-h[0], {0, 0}); pair\u0026lt;ll,int\u0026gt; dp; for(int i = 1; i \u0026lt; n; i++) { pair\u0026lt;ll,int\u0026gt; a = pre.query(h[i]), b = suf.query(u.size()-h[i]); a.ff += h[i]; dp = min(a,b); dp.ss -= 1; suf.edit(u.size()+1-h[i], dp); dp.ff -= h[i]; pre.edit(h[i], dp); } cout \u0026lt;\u0026lt; min(m, -dp.ss) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }   ","permalink":"https://omeletwithoutegg.github.io/2020/05/12/TIOJ-1764/","tags":["TIOJ","dp","data-structure"],"title":"TIOJ-1764"},{"contents":"序列維護問題 https://tioj.ck.tp.edu.tw/problems/1633\nDescription 有一個由1到N的數字排成的序列。\n可是你對於現在這個排列很不滿意，決定透過一些操作改變這個序列。\n你現在有兩種操作：\n REV L R ：把L到R所有數字反轉順序，例如1 2 3 4變成4 3 2 1 SWAP L1 R1 L2 R2：把L1到R1所有數字跟L2到R2所有數字交換位置，但順序不變。  你總共進行了M次操作，請輸出最後序列的樣子。\nSolution 平衡二元樹裸題，我用的是Treap\n要反轉的話可以打懶標(?)然後記得push\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99  #pragma GCC optimize(\u0026#34;Ofast\u0026#34;) #pragma loop_opt(on) #include \u0026lt;cstdio\u0026gt;#include \u0026lt;random\u0026gt; const int N = 130025; inline char readchar() { constexpr int B = 1\u0026lt;\u0026lt;20; static char buf[B], *p, *q; if(p == q \u0026amp;\u0026amp; (q=(p=buf)+fread(buf,1,B,stdin)) == buf) return EOF; return *p++; } inline int nextint() { int x = 0, c = readchar(); while(c \u0026lt; \u0026#39;0\u0026#39;) c = readchar(); while(c \u0026gt;= \u0026#39;0\u0026#39;) x=x*10+(c^\u0026#39;0\u0026#39;), c=readchar(); return x; } inline void readuntil(char *s, char esc = \u0026#39;\\n\u0026#39;) { char c = readchar(); while(c != esc) *s++ = c, c = readchar(); } std::mt19937 rnd(7122); struct BST { struct node { int pri, sz, rev; int l, r; } S[N]; void flip(int x) { S[x].rev = !S[x].rev; std::swap(S[x].l, S[x].r); } void pull(int x) { S[x].sz = S[S[x].l].sz + 1 + S[S[x].r].sz; } void push(int x) { if(!S[x].rev) return; flip(S[x].l), flip(S[x].r); S[x].rev = false; } void split(int o, int \u0026amp;a, int \u0026amp;b, int k) { if(!o) return a = b = 0, void(); push(o); int s = S[S[o].l].sz + 1; //debug(k,s,o,S[o].l);  if(k \u0026lt; s) b = o, split(S[o].l, a, S[b].l, k), pull(b); else a = o, split(S[o].r, S[a].r, b, k - s), pull(a); } int join(int a, int b) { if(!a || !b) return a ? a : b; push(a), push(b); if(S[a].pri \u0026lt; S[b].pri) return S[a].r = join(S[a].r, b), pull(a), a; else return S[b].l = join(a, S[b].l), pull(b), b; } void dfs(int i, bool r = true, int d = 0) { if(!i) return; push(i); dfs(S[i].l, 0, d+1); printf(\u0026#34;%d%c\u0026#34;, i, (r \u0026amp;\u0026amp; !S[i].r ? \u0026#39;\\n\u0026#39; : \u0026#39; \u0026#39;)); dfs(S[i].r, r, d+1); } } trp; signed main() { //ios_base::sync_with_stdio(0), cin.tie(0);  int n=nextint(), q=nextint(); int root = 0; for(int i = 1; i \u0026lt;= n; i++) trp.S[i] = {rnd(), 1, 0, 0, 0}, root = trp.join(root, i); //trp.dfs(root);  while(q--) { char com[5]; readuntil(com, \u0026#39; \u0026#39;); if(com[0] == \u0026#39;R\u0026#39;) { int a, b, c, l, r; l = nextint(), r = nextint(); trp.split(root, b, c, r); trp.split(b, a, b, l-1); trp.flip(b); //cout \u0026lt;\u0026lt; \u0026#34;rev \u0026#34;;  //trp.dfs(b);  root = trp.join(a, trp.join(b,c)); } else { int l1, r1, l2, r2, a, b, c, d, e; l1 = nextint(), r1 = nextint(), l2 = nextint(), r2 = nextint(); trp.split(root, d, e, r2); trp.split(d, c, d, l2-1); trp.split(c, b, c, r1); trp.split(b, a, b, l1-1); root = trp.join(a, trp.join(d, trp.join(c, trp.join(b, e)))); } } trp.dfs(root); }   ","permalink":"https://omeletwithoutegg.github.io/2020/05/08/TIOJ-1633/","tags":["TIOJ","data-structure"],"title":"TIOJ-1633"},{"contents":"二階奇幻之旅 原本一段剛好和一階撞到，可以免考，但是因為疫情的緣故又錯過了\n不過在我們從一階回來之後傳出師大那邊有確診的消息，而且還跟我們用過同一間教室(?)\n所以我們就剛好利用防疫公假得到免考的資格，嘻嘻\n防疫公假? 在自主健康管理的這段期間，我除了家裡基本上都待在王政祺家地下室\n寒假的時候去那邊都是在打桌遊，不過這個禮拜去不是在刷題就是在刷題XD\n有戳了一些POI還是BOI，不過POI真的好怪，什麼官解一兩百行特判的數學題之類的\nAY來的時候他會丟CF的題目，然後帶我們吃超多拉麵\n不過我真的對蒜不行\u0026gt;\u0026lt;\n二階 總之防疫公假結束之後就無縫接軌二階\n因為師大有確診所以我們原本應該是要待在家裡邊防疫邊線上上課\n我們的住宿和披薩全都因為疫情泡湯QAQ，變成線上授課\n啊我們上課就不是重點喔@@我覺得能夠不管任何外部事務，只專心互相討論題目、或者耍廢才是我心目中(?)的選訓營QQ\n非新北、台北的學生可以有一晚的住宿，我好想要飯店早餐(\n既然我們都覺得教授上的課不是重點，能夠和其他電神互相討論才是選訓營最大的好處\u0026gt;\u0026lt;\n於是我們建中一群人就借用了電教和創客教室來討論(?)\n有些南部人待在台北的也跟著來ㄌ，這一團變得超熱鬧\n捯捯捯捯捯捯捯 AY跑去新竹跟東東和balbit刷題的樣子，第二個禮拜double學長也跑下去\n模考的時候他們再跑上來\n總之我們好像每次模考就會吃一兩次拉麵XD好爽\n課程 在二階上的有些課很奇怪，比如說什麼KMP和SA，或者建凸包求面積之類的\n雖然從北市賽到入營考考的字串題好像只有AC自動機那題，可是在二階教這些超奇怪的吧XD\n有一堂課是教授會丟題目給我們寫，給一個很大的測資然後要我們找出答案之類的\n去年似乎是舉手讓教授看，不過今年是用google meet，答案直接打在聊天室，沒有避嫌超奇怪啦\n雖然是教分治的教授，不過有丟了一些有趣的DP題目\n這次也聽到了Level Ancestor的做法，Ladder Algorithm好神奇喔\n不過RMQ的O(N)O(1)也聽了好幾遍，已經聽膩了\n國手們來講課的時候AY好像弄了一個DC的bot，於是我們後面就開始duel\n休閒娛樂 什麼是duel呢?\n就是讓bot選一題然後兩個人比誰先想出來然後AC XD\n我好像沒有duel的太積極ww不過AY和balbit似乎超常對決\n不知道從誰開始玩BTD battles的，我們幾乎每天都玩(到二階結束還在玩)\n03t教的策略超強，可是我還是常常玩到破產，只能打五元的，超可憐又一直遇到金錢幾百萬的對手，怎麼贏?\n另外因為沒有被關在師大，吃飯就成了一個問題\n我們除了在建中的熱食部吃以外，也去吃了好幾家拉麵，有點罪惡感XD\n啊也因為沒有被關在師大，我就可以順理成章的在晚上去打音遊，真爽(現在sdvx中毒中:P)\n模考 模考在師大本部舉行，地點是一個會議室(汗)\n而且跟全國賽一樣是用筆電，不過這次升級成電競筆電了(不如把預算拿去幫我們弄住宿或上課空間QQ)\n三模難度超高QQ，本來以為自己被電爆不過似乎拿到最高分，因為拿到一題FWT的56分@@可惜我沒拿滿\n剩下pCpD幾乎沒人拿到分數，超可怕\n我pA沒有把手做的分數拿滿有點可惜(?)\n四模的話，pA看起來是可以做的題目(幸好進位制不是負的)，花了一些時間丟上去部分分確定是對的之後優化個兩三次就AC了\n剩下的題目都做不出來QQ原本以為pB是可以做的DP但是出來好像大家都不會\npC沒有拿滿很可惜，pD也是和大家一樣沒想法不過可惜我沒去拿一條鏈的case\n接下來? 因為我在學校嘗試待了一個禮拜之後發現真的待不太下去(這就是奧林匹亞回歸症候群嗎\u0026hellip;)\n於是成功的用準備資奧的理由請了假，罪惡感爆棚呢XD\n現在該做的事可能就是編講義、寫題解吧，希望自己不要頹廢OvO\n","permalink":"https://omeletwithoutegg.github.io/2020/05/07/TOI-2/","tags":["experience","TOI"],"title":"TOI-2!"},{"contents":"B.魔術數字 https://tioj.ck.tp.edu.tw/problems/1039\nDescription 超級長orz\n總之名次的比較是看勝率，勝率的定義是「勝場數/(勝場數+敗場數)」\n而兩隊魔術數字$M$的定義如下：\n假設A隊的勝率領先B隊，只要A隊再贏除了B隊以外的隊伍$M$場，就算$B$隊剩下的所有場次都贏也不能得到和A相等的勝率\n假設$M$大於A隊對上除了B隊以外的隊伍剩下的場次，那我們說A隊對B隊的魔術數字尚未點亮\n否則我們說A隊對B隊的魔術數字是$M$\n如果$M$歸零的話，表示A隊不管怎麼樣名次都會超過B隊\n對於每一筆測試資料，請輸出一排版過的戰績表。依n支球隊的戰績排名順序輸出n行。除了第1名球隊以外，若發生勝率相同的情形，請依球隊在原資料的出現順序為輸出順序，但其排名則應並列。格式請參考範例輸出。隊名，勝率，魔術數字分別以一個空格來間隔，而隊名部分不足9個字元的部分則需填入空格。勝率固定輸出到小數點後三位(四捨五入)。第一名球隊不需要輸出魔術數字，請你分別計算出第一名球隊對其他球隊的魔術數字。若對其他球隊的魔術數字尚未點亮，請輸出--。若魔術數字已點亮，則輸出M以及該數字。測試資料之間請留一個空行。\nSolution 呃\u0026hellip;就是一大堆噁心輸出\n注意勝率的定義不包括和局QQ\n計算魔術數字的方法就是用while迴圈一直加，跑到在題敘指定的情況下A隊的勝率會大於B隊的勝率\n噢名次的地方也是要注意QQ很容易沒注意就寫錯\n還有他的空行是在測試資料之間(?)雖然我不知道有沒有差啦\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;cmath\u0026gt;#include \u0026lt;algorithm\u0026gt;struct Team { char name[10]; int W, T, L, id; double rate; friend bool operator\u0026lt;(const Team \u0026amp;a, const Team \u0026amp;b) { return a.rate != b.rate ? a.rate \u0026gt; b.rate : a.id \u0026lt; b.id; } } t[100]; int rest[100][100]; signed main() { int n, g; bool first = true; while(scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;g), n || g) { if(!first) puts(\u0026#34;\u0026#34;); first = false; for(int i = 0; i \u0026lt; n; i++) { scanf(\u0026#34;%s%d%d%d\u0026#34;, t[i].name, \u0026amp;t[i].W, \u0026amp;t[i].T, \u0026amp;t[i].L); t[i].id = i; t[i].rate = t[i].W / double(t[i].W+t[i].L); } for(int i = 0; i \u0026lt; n; i++) for(int j = 0; j \u0026lt; n; j++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;rest[i][j]); std::sort(t, t+n); int rk = 0; double last = 7122; for(int i = 0; i \u0026lt; n; i++) { if(t[i].rate != last) rk = i+1; last = t[i].rate; printf(\u0026#34;%d:%-9s %.3f\u0026#34;, rk, t[i].name, round(t[i].rate * 1000) / 1000); if(i) { int magic = 0; while((t[0].W + magic) / double(g - t[0].T) \u0026lt;= (g - t[i].T - t[i].L) / double(g - t[i].T)) ++magic; if(magic \u0026lt;= g - (t[0].W+t[0].T+t[0].L) - rest[t[0].id][t[i].id]) printf(\u0026#34; M%d\u0026#34;, magic); else printf(\u0026#34; --\u0026#34;); } puts(\u0026#34;\u0026#34;); } } }   ","permalink":"https://omeletwithoutegg.github.io/2020/05/06/TIOJ-1039/","tags":["TIOJ"],"title":"TIOJ-1039"},{"contents":"照亮的山景 https://tioj.ck.tp.edu.tw/problems/1404\nDescription 在一片山的上空，高度為$T$處有$N$個處於不同水平位置的燈泡，如上圖所示。\n如果山的邊界上某一點與第$i$盞燈的連線不經過任何山稜線上的一點，我們稱第$i$盞燈可以照亮該點。\n請問在所有$M$盞燈中，至少要打開幾盞燈，才能照亮山上每一個轉折點，或者打開所有的燈也無法照亮所有轉折點？\n$1 \\leq M, N \\leq 10^5$\n所有座標的絕對值小於$10^5$\nSolution 發現到每個燈泡可以照到的範圍可能會長的非常奇怪\n於是我們轉換思維，考慮每個轉折點如果要被照到要有什麼條件\n可以發現，對於每個轉折點來說有一個區間，只要區間內有一個燈泡有開，這個轉折點就會被照到\n找出那些區間之後這題就是經典的greedy題目了（按照右界由小到大，有拿過的跳過沒拿過的拿右界那個點）\n那麼要怎麼找出這些區間呢？某個轉折點$p_i$對應的右界，正好是他和他右邊所有其他點所連出的射線中斜率最大者\n維護一個上凸包能夠找到對應的那個點，再用直線求交點公式找出高度恰好是$T$的位置就好\n左界也是同樣方式處理\n因為題目給定的點已經幫我們排序好了，所以做凸包是$\\mathcal{O}(M)$，而greedy的部分也可以做到$\\mathcal{O}(N)$不過我這邊是放了$\\mathcal{O}(N\\log N)$的，因為找到交點之後必須二分搜求出到底涵蓋了哪些燈泡\n總複雜度是$\\mathcal{O}((M+N)\\log N)$\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70  #include \u0026lt;bits/stdc++.h\u0026gt;#define debug(x) cerr\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;  using namespace std; const int N = 100025; signed main() { ios_base::sync_with_stdio(0), cin.tie(0); int m, n, T; while(cin \u0026gt;\u0026gt; m) { vector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; v(m); for(auto \u0026amp;[x, y]: v) cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; T; vector\u0026lt;int\u0026gt; bulb(n); for(int \u0026amp;x: bulb) cin \u0026gt;\u0026gt; x; vector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; seg(m, pair\u0026lt;int,int\u0026gt;(0, n)); { auto better = [](pair\u0026lt;int,int\u0026gt; a, pair\u0026lt;int,int\u0026gt; b, pair\u0026lt;int,int\u0026gt; c) { pair\u0026lt;int,int\u0026gt; AB(b.first-a.first, b.second-a.second); pair\u0026lt;int,int\u0026gt; BC(c.first-b.first, c.second-b.second); return 1LL * AB.first * BC.second - 1LL * BC.first * AB.second \u0026gt; 0; }; vector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; stk; for(int i = 0; i \u0026lt; m; i++) { while(stk.size() \u0026gt;= 2 \u0026amp;\u0026amp; better(stk[stk.size()-2], stk[stk.size()-1], v[i])) stk.pop_back(); if(stk.size() \u0026amp;\u0026amp; stk.back().second \u0026gt; v[i].second) { double x = v[i].first + (T - v[i].second) * (stk.back().first - v[i].first) / double(stk.back().second - v[i].second); seg[i].first = upper_bound(bulb.begin(), bulb.end(), x) - bulb.begin(); } stk.push_back(v[i]); } } { auto better = [](pair\u0026lt;int,int\u0026gt; a, pair\u0026lt;int,int\u0026gt; b, pair\u0026lt;int,int\u0026gt; c) { pair\u0026lt;int,int\u0026gt; AB(b.first-a.first, b.second-a.second); pair\u0026lt;int,int\u0026gt; BC(c.first-b.first, c.second-b.second); return 1LL * AB.first * BC.second - 1LL * BC.first * AB.second \u0026lt; 0; }; vector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; stk; for(int i = m-1; i \u0026gt;= 0; i--) { while(stk.size() \u0026gt;= 2 \u0026amp;\u0026amp; better(stk[stk.size()-2], stk[stk.size()-1], v[i])) stk.pop_back(); if(stk.size() \u0026amp;\u0026amp; stk.back().second \u0026gt; v[i].second) { double x = v[i].first + (T - v[i].second) * (stk.back().first - v[i].first) / double(stk.back().second - v[i].second); seg[i].second = lower_bound(bulb.begin(), bulb.end(), x) - bulb.begin(); } stk.push_back(v[i]); } } bool ok = true; for(int i = 0; i \u0026lt; m; i++) if(seg[i].first == seg[i].second) { cout \u0026lt;\u0026lt; \u0026#34;you need more bulbs!\\n\u0026#34;; ok = false; break; } if(!ok) continue; sort(seg.begin(), seg.end(), [](pair\u0026lt;int,int\u0026gt; a, pair\u0026lt;int,int\u0026gt; b){return a.second \u0026lt; b.second;}); int last = -1, ans = 0; for(auto [l, r]: seg) { if(l \u0026gt;= last) { last = r; ++ans; } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } }   ","permalink":"https://omeletwithoutegg.github.io/2020/05/04/TIOJ-1404/","tags":["TIOJ","geometry","greedy"],"title":"TIOJ-1404"},{"contents":"組合布丁 https://tioj.ck.tp.edu.tw/problems/1628\nDescription 記得在快樂暑假營開始前，你曾經說過：「只要我有一次比賽沒有破台，就要請全快樂營的人吃布丁。」\n好吧，蚯蚓太威了，你終究是沒有破台。\n根據小道消息，你得知了這次的快樂暑假營總共有 $n$ 個人報名，\n但是實際上會出席的只有 $k$ 個人，因此你只要請 $k$ 個人吃布丁就好。\n而報名的第 $i$ 個人只會願意吃 $t_i$ 口味的布丁(用一個 int 範圍內的整數表示)。\n假設你不確定究竟誰會出席，那有幾種不同的布丁組合可能會出現在你的採買清單上 ?\n喔對了，因為答案可能太大了，所以你決定只要知道答案除以 $M$ 的餘數就好。\n輸入包含多筆測資\n$$\n1 \\leq n, k \\leq 5000, 1 \\leq M \u0026lt; 2^{31}\n$$\nSolution 兩種布丁組合不同，若且唯若某一種布丁的數量不同\n因此我們枚舉每個布丁的數量去做計數背包就好了\n可以用前綴和甚至FFT加速(?)不過FFT應該不會比較快www\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int t[5025], n, k, M; long long dp[5025]; void go(int maxcnt) { for(int i = k; i \u0026gt;= 0; i--) { long long sum = 0; for(int j = 0; j \u0026lt;= i \u0026amp;\u0026amp; j \u0026lt;= maxcnt; j++) { sum = (sum + dp[i-j])%M; } dp[i] = sum; } } signed main() { while(cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k \u0026gt;\u0026gt; M) { dp[0] = 1; for(int i = 1; i \u0026lt;= k; i++) dp[i] = 0; for(int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; t[i]; sort(t,t+n); for(int i = 0, j; i \u0026lt; n; i = j) { for(j = i; j \u0026lt; n; j++) if(t[i] != t[j]) break; go(j-i); } cout \u0026lt;\u0026lt; dp[k] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } }   ","permalink":"https://omeletwithoutegg.github.io/2020/05/03/TIOJ-1628/","tags":["TIOJ","dp"],"title":"TIOJ-1628"},{"contents":"蘿莉切割問題 https://tioj.ck.tp.edu.tw/problems/1861\nDescription 請你把一個數字$L$切成$a_1, a_2, \\dots, a_n$\n切一個數字$x$的代價是$x$，可以把它切成$b, x-b$兩個數字\n找出最小的代價\nSolution 霍夫曼編碼XD老題目\n把切割的過程看成一個二元樹，每個$a_i$都代表一個葉子\n其餘的節點代表合併中會出現的數字(?)\n那麼總代價就是所有葉子的權重乘上各自的深度的和\n我們想要讓這個代價越小越好\n可以發現，在最優解$T$中：\n 沒有節點只有一個兒子，只要不是葉子的節點都恰好有兩個子節點 深度最大的那層節點一定是權重最小的，否則可以直接交換得到更優解  由上面兩點可以發現，權重最小的兩個節點一定都在最深的那一層\n並且可以在不影響代價的情況下交換節點使得最小的兩個節點互為兄弟\n結論是：每次把最小和次小的節點合併成一個節點，一定可以得到最佳解\n(QQ我覺得我不會查也不會寫證明)\n要怎麼維護所有節點的最小和次小呢？用一個heap就可以啦\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; const int N = 100025; #define int ll int v[N]; signed main() { ios_base::sync_with_stdio(0), cin.tie(0); int n,ans; while(cin \u0026gt;\u0026gt; n) { ans = 0; for(int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; v[i]; std::priority_queue\u0026lt;int,vector\u0026lt;int\u0026gt;,greater\u0026lt;int\u0026gt;\u0026gt; pq(v,v+n); while(pq.size() \u0026gt; 1) { int x = pq.top(); pq.pop(); int y = pq.top(); pq.pop(); ans += (x+y); pq.push(x+y); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } }   ","permalink":"https://omeletwithoutegg.github.io/2020/05/01/TIOJ-1861/","tags":["TIOJ","greedy"],"title":"TIOJ-1861"},{"contents":"選訓生活(?) 最近部落格停更好久喔\u0026gt;\u0026lt;\n不知道有沒有沒有追蹤我facebook的人在看我的部落格，嘻嘻\n入營考當天? 我和蕭梓宏還有王品翔一起去師大看好戲(X)\n然後電石似乎在旁邊寫作業和嘴砲(?)\n不過記分板上沒有每個人的名字，只有學校和編號\n幸好遇到一個奇怪的家長有拍名單之類的XD 讓我們能夠對照\n最後結果是AY破台拿第一，除了03t以外的建中高二應該都進了一階\n我們之後分團去ㄘ了拉麵！\n一階 懷著新奇的心情來到這個地方，報到時我好像是蠻晚進去的幾個(因為林哲宇帶路)\n一開始我本來想說可以打osu，因為去年似乎好多人那樣刷時間?\n不過晚上看到好多人在刷題，我超怕www\n於是就開始寫不知道甚麼題目\n課程 有幾堂是教授講課，首先是入營考的題解，不過好像被發現有一題假解XDD\n之後有一個是張經略教授，他會在白板上畫加菲貓而且上課超級high(他自嗨功力很高)\n有一堂課是國手經驗分享，bert和minson說了好多奇怪的趣聞(?)\n第一個禮拜幾乎所有人都出現了(?) BB、電石、吳聖福、王彥仁好幾位都有來講題目or分享奇怪心得\n從一模隔天開始，剩下的教授幾乎都是線上上課，所以我後來幾乎沒有在上課QQ\nO(N)O(1)RMQ 教了幾百遍聽到不想再聽(X)\n教室似乎因為防疫的關係換了三次左右，有點煩躁\n第一個禮拜我刷的比較多應該還是TIOJ，畢竟我還是覺得我刷不動POI(?)\n不過第二個禮拜開始刷一些BOI，想說練一下喇分能力\n可是不知道是題目問題還是我的個性幾乎不是直接想到滿分解就是只有不到三十的部分分QQ\nPOI和JOI仍然還在我的實力的很上方\n話說一模附近幾天剛好是JOISC，不過難到炸，我完全寫不出啥\n飲食住宿 我們的飯店是台大捷絲旅，對面就是哈拉星球XDD，可惜沒有辦法去打QQ\n然後我的室友是暘典，好像有點自然的就稍微變熟不過還是很不熟(?)\n早餐是飯店的早餐，這十四天每天早上吃這個真的超級爽耶，我超愛炒蛋和炸的東西\n午餐和晚餐在師大的學餐吃，我覺得中餐真的就是該吃早餐部XD\njoy一直推薦西西里雞腿堡加蛋加起司，不過我覺得沒有傳言那麼好吃\n晚餐就只剩西餐廳跟自助餐兩個選，我覺得西餐廳的拉麵超級糟糕，丼飯也只是勉強能吃ww\n自助餐則是超級尷尬的選擇，不好吃也不難吃，不過很容易就超過預算90元要自掏腰包www\n在吃飯的時候基本上都會打牌，因為這似乎是無聊的選訓生活中少數的消遣(?) (雖然我現在覺得選訓一點都不無聊QQ)\n最常打的是拿破崙，ericxiao真的大師，啊seanliu到第二個禮拜才發現他知道的比牌大小規則是錯的XD超好笑\n此外因為那時候mini metro限免，大家一窩蜂去下載來玩\n吃完飯之後我幾乎都會買微舒打，好爽喔\n在飯店，有時候晚上會和祺他人在其他房玩狼人殺或打拿破崙之類的(?)\n有時也會有淇怪的人來我們房間玩(?)\n每天晚上點名的時候有零食和飲料，算是填填牙縫(\n晚上沒什麼消遣，除了打牌玩狼人殺，或者打code以外，也可以跟人聊天 \u0026lt;3\n模考 如同國手們分享經驗時所說的，我覺得我正好就是那些在北市賽、全國賽也許表現得好，但是是第一次模考的菜雞\n他們提到說賽中要多喝水、多上廁所，也要記得補充血糖，轉換轉換心情並讓大腦保持清醒\n其實這些我在500days那本書就看過了好幾次，不過我還是當作重要的一些策略記著\n一模的時候我雖然打得很差，可是我沒有想到什麼特別的原因讓我打爛，單純只是我都沒有想法而已\n因為還沒踏進棺材所以晚上也不是特別難過，不過看到打得比我好的說什麼我很強就覺得超級不爽= =想打人(例如joy)\n看到別人分數比自己高還是會超級羨慕的吧\n二模因為pC出一大堆問題所以大家好像都打得很爛，不過我pC是最後才碰的所以幸運沒有踩雷\n而且還是因為pD測資爛撈到一個AC= =現在回去看每一場都有憐憫我的分數\n模考的難度聽說比以往難，然後我實際寫也是感覺真的很難(雖然我沒去過以前的)，可能跟一些div 1的場次一樣吧?\n不過撈部分分的能力應該才是真正決勝的地方，有請品翔喇分大師分享入營考0AC的經驗\n列舉事項 因為一階遇到很多酷哥，所以我要從facebook抄過來那段列舉\n幾件神奇的事情：\n thomaswang和ericxiao分別站在爛梗光譜的兩端 西餐廳的拉麵超糟 午餐吃早餐部唯一真理吧 天天喝微舒打好爽 吃飯店的早餐有夠爽 晚餐或晚上超常打拿破崙 seanliu打了兩個禮拜竟然有規則不知道 然後蕭電超強 YoJaHuang\u0026amp;品翔歌神了吧 實中的人都超酷 除了tommydong比較正常一點 仲群病毒大家都一直學www 「我燒雞」 「呃 我弱」 casperwang洗澡專家 不過還是教不會品翔 好多東西都是第一次接觸到 例如十二人狼人殺或是學生餐廳的點餐方法www  待續\u0026hellip; 因為打這篇的時候我在學校努力上課(?) 所以打得斷斷續續的，一階結束之後的事放到下一篇打好了\n待在學校真的好可怕，所謂奧林匹亞回歸症候群就是這樣嗎QQ\n英文國文化學物理一直打瞌睡，然後我也不敢(或懶得)要之前沒拿的講義，完美詮釋社交障礙\n問了一些學長，明天問問看特教組申請推薦的方法和能不能請公假好了\n我要跑去看FF7實況了，TIFA真香\n","permalink":"https://omeletwithoutegg.github.io/2020/04/30/TOI-1/","tags":["experience","TOI"],"title":"TOI-1!"},{"contents":"快樂規劃路徑 https://tioj.ck.tp.edu.tw/problems/1629\nDescription 樹朋友們生活在一個湖邊，湖邊的樹依照順時針方向編號為$1, 2, \\dots n$。\n他們想要讓自己更快樂，所以發明了一種娛樂方式，就是找到一條路徑遍歷全部$n$棵樹剛好一遍。\n要從A樹到B樹唯一的方法就是架一條很長的梯子直直伸過去。\n可是當然不是任何兩棵樹都可以架梯子，所以他們會先把所有可能架梯子的樹對(沒有錯字!)給你。\n當然，(A,B)表示A可以到B、B也可以到A。\n但是給定的遊歷路徑不能出現任兩條梯子交叉，不然可能會讓想要快樂的樹朋友發生危險。\n例如上圖粗線所示就是一個合法的快樂路徑。\n給你樹的個數以及樹對，請輸出一組快樂路徑。\n若有很多組解，樹朋友希望看到字典順序最小的那一組。\n$5 \\leq n \\leq 1000$\nSolution 由不能交叉的條件可以推出，在某個時刻已經遍歷過的點一定是環上的一個連續區間\n所以可以2D/0D的區間DP，並記錄最小的轉移來源\n我的dp$[i][L][0]$代表的是現在站在$i$，往順時鐘方向的$L$個都已經遍歷過了，$dp[i][L][1]$也相似只是換成逆時鐘\n因為實在想不到更好的實作方式所以寫的有夠醜，但是只要好好選到最小的轉移來源就會是字典序最小的路徑了\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74  #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 1025; int n, m; bool dp[N][N][2], fr[N][N][2], g[N][N]; signed main() { ios_base::sync_with_stdio(0), cin.tie(0); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for(int i = 0; i \u0026lt; m; i++) { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b, --a, --b; g[a][b] = g[b][a] = true; } for(int i = 0; i \u0026lt; n; i++) dp[i][1][0] = dp[i][1][1] = true; for(int L = 2; L \u0026lt;= n; L++) for(int i = 0; i \u0026lt; n; i++) { // dp[i][L][0]  if(dp[(i+1)%n][L-1][0] \u0026amp;\u0026amp; g[(i+1)%n][i]) { // (i+1)%n  fr[i][L][0] = 0; dp[i][L][0] = true; } if(dp[(i+L-1)%n][L-1][1] \u0026amp;\u0026amp; g[(i+L-1)%n][i]) { // (i+L-1)%n  if(!dp[i][L][0] || (i+1)%n \u0026gt; (i+L-1)%n) fr[i][L][0] = 1; dp[i][L][0] = true; } // dp[i][L][1]  if(dp[(i+n-1)%n][L-1][1] \u0026amp;\u0026amp; g[(i+n-1)%n][i]) { // (i+n-1)%n  fr[i][L][1] = 0; dp[i][L][1] = true; } if(dp[(i+n+1-L)%n][L-1][0] \u0026amp;\u0026amp; g[(i+n+1-L)%n][i]) { // (i+n+1-L)%n  if(!dp[i][L][1] || (i+n-1)%n \u0026gt; (i+n+1-L)%n) fr[i][L][1] = 1; dp[i][L][1] = true; } } for(int i = 0; i \u0026lt; n; i++) { if(dp[i][n][0] || dp[i][n][1]) { vector\u0026lt;int\u0026gt; ans; for(int c = 0; c \u0026lt; 2; c++) if(dp[i][n][c]) { int d = c; vector\u0026lt;int\u0026gt; vv; for(int L = n; L \u0026gt;= 1; L--) { vv.push_back(i); // cerr\u0026lt;\u0026lt;dp[i][L][d]\u0026lt;\u0026lt;\u0026#39;,\u0026#39;;  int f = fr[i][L][d]; if(d) { if(f) { i = (i+n+1-L)%n; d = 0; }else { i = (i+n-1)%n; d = 1; } }else { if(f) { i = (i+L-1)%n; d = 1; }else { i = (i+1)%n; d = 0; } } } if(ans.empty() || vv \u0026lt; ans) ans = vv; } for(int x: ans) cout \u0026lt;\u0026lt; x+1 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } } cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }   ","permalink":"https://omeletwithoutegg.github.io/2020/02/29/TIOJ-1629/","tags":["TIOJ","IOI"],"title":"TIOJ-1629"},{"contents":"Assssss!! https://tioj.ck.tp.edu.tw/problems/1505\nDescription 現在有一個正整數構成的除法數列\n$\nx_1 / x_2 / x_3 / \\dots / x_n\n$\n請問是否有一種加上括號的方法使得最後運算的結果是整數?\n$2 \\leq n \\leq 10^5, 1 \\leq x_i \\leq 10^9$\nSolution 加上括號之後每個數字會被放到分母或分子，想當然而放在分子的數字越多越好\n可以發現$x_2$會恰好被放到分母一次，因此在最後他一定是當分母的\n而我們可以構造出一個方法讓除了$x_2$最後當分母以外，其他數字都當分子\n$$\n(x_1 / (((x_2 / x_3) / x_4) / x_5 \\dots)) = \\frac{x_1 x_3 x_4 x_5 \\dots x_n}{x_2}\n$$\n由於$x_2$最後一定會待在分母，只要檢查其他數字的乘積是否可以被$x_2$整除就好了\n記得 long long 的問題\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  #include \u0026lt;cstdio\u0026gt; inline char readchar() { constexpr int B = 1\u0026lt;\u0026lt;20; static char buf[B], *p, *q; if(p == q \u0026amp;\u0026amp; (q=(p=buf)+fread(buf,1,B,stdin)) == buf) return EOF; return *p++; } inline int nextint() { int x = 0, c = readchar(); while(c \u0026lt; \u0026#39;0\u0026#39;) c = readchar(); while(c \u0026gt;= \u0026#39;0\u0026#39;) x=x*10+(c^\u0026#39;0\u0026#39;), c=readchar(); return x; } signed main() { int t = nextint(); while(t--) { int n = nextint(); int res = nextint(), mod = nextint(); for(int i = 2; i \u0026lt; n; i++) res = 1LL * res * nextint() % mod; puts(res ? \u0026#34;zzz...\u0026#34; : \u0026#34;Asssss!!\u0026#34;); } }   ","permalink":"https://omeletwithoutegg.github.io/2020/02/27/TIOJ-1505/","tags":["TIOJ","math"],"title":"TIOJ-1505"},{"contents":"發糖果囉 https://tioj.ck.tp.edu.tw/problems/1219\nDescription 求符合$1 \\leq x \\leq n, 1 \\leq y \\leq m$且$x,y$的最大公因數是$g$的數對有多少對\n有多筆測試資料，$1 \\leq n, m, g \\leq 50000$\nSolution 莫比烏斯反演\nlemma $$\n\\sum_d \\mu(d) [d | x] = [x = 1]\n$$\n拿來簡化 $[\\gcd(i,j)=1]$ 的部分，再想辦法換一下$\\sum$的位置\n$$\n\\begin{align*}\n\\sum _ {i=1}^n \\sum _ {j=1}^m [\\gcd(i, j) = g] \u0026amp;= \\sum _ {i=1}^{\\lfloor n/g \\rfloor} \\sum _ {j=1}^{\\lfloor m/g \\rfloor} [\\gcd(i, j) = 1]\\newline\n\\sum _ {i=1}^N \\sum _ {j=1}^M [\\gcd(i, j) = 1] \u0026amp;= \\sum _ {i=1}^N \\sum _ {j=1}^M \\sum_d \\mu(d) \\cdot [d | \\gcd(i, j)]\\newline\n\u0026amp;= \\sum_d \\mu(d) \\sum _ {i=1}^N \\sum _ {j=1}^M [d | \\gcd(i, j)]\\newline\n\u0026amp;= \\sum_d \\mu(d) {\\lfloor \\frac{N}{d} \\rfloor} {\\lfloor \\frac{M}{d} \\rfloor}\n\\end{align*}\n$$\n預處理$\\mu$的前綴，利用數論分塊可以做到$\\mathcal{O}(N + Q \\sqrt{N})$\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;vector\u0026gt; const int N = 50025; bool sv[N]; int mu[N], smu[N]; std::vector\u0026lt;int\u0026gt; prs; inline int min(int a, int b) {return a\u0026lt;b?a:b;} signed main() { mu[1] = 1; for(int i = 2; i \u0026lt; N; i++) { if(!sv[i]) prs.emplace_back(i), mu[i] = -1; for(int p: prs) { if(i*p \u0026gt;= N) break; sv[i*p] = true; if(i%p) { mu[i*p] = -mu[i]; }else { mu[i*p] = 0; break; } } } for(int i = 1; i \u0026lt; N; i++) smu[i] = smu[i-1]+mu[i]; int n, m, g; while(scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;m, \u0026amp;g), n || m || g) { n /= g, m /= g; long long ans = 0; for(int i = 1, j; i \u0026lt;= n \u0026amp;\u0026amp; i \u0026lt;= m; i = j) { j = min(n/(n/i), m/(m/i))+1; ans += 1LL * (smu[j-1] - smu[i-1]) * (n/i) * (m/i); } printf(\u0026#34;%lld\\n\u0026#34;, ans); } }   ","permalink":"https://omeletwithoutegg.github.io/2020/02/25/TIOJ-1219/","tags":["TIOJ","math"],"title":"TIOJ-1219"},{"contents":"殿壬愛序列 https://tioj.ck.tp.edu.tw/problems/1102\nDescription 給你一個長度為$N$的序列$a_1, a_2, \\dots, a_N$，並且依序執行$Q$個操作，每個操作可能是\n  1 x y ：把$a_x$設成$y$\n  2 L R k ：對於每個$i \\in [L, R]$，把$a_i$設成$\\lfloor \\frac{a_i}{k} \\rfloor$。其中$\\lfloor x \\rfloor$代表不大於$x$的最大整數\n  3 L R ：請輸出$a_L, a _ {L+1}, \\dots, a_R$的絕對眾數，如果絕對眾數不存在請輸出-1。一個數字若為$T$個數字的絕對眾數，代表這個數字至少在$T$個數字中出現$\\lfloor \\frac{T+2}{2} \\rfloor$次。\n  $1 \\leq N, Q \\leq 10^5$\n  $1 \\leq L \\leq R \\leq N$\n  $1 \\leq x \\leq N$\n  $0 \\leq a_i, y \\leq 10^9$\n  $1 \\leq k \\leq 10^9$\n  Solution 打架線段樹的裸題\n對每個節點維護val和win，分別表示那個區間打贏的數字以及他贏了多少(?)\n合併的時候假如兩個區間的val一樣，那麼他們的win就會相加\n不同的話就是讓他們打架! win比較多的一方獲勝，但是必須減去對方的win\n詳細請看node operator+的部分\n一個區間的絕對眾數一定是打贏的數字，但是打贏的數字不一定是絕對眾數\n得到一個區間打贏的數字之後，我們得知道這個數字到底在這個區間出現幾次\n我們可以開rank tree對每個數字$x$紀錄$a_i=x$的index\n只要知道$l,r$在rank tree的名次就能知道$l, r$之間有多少數字是$x$\n至於區間除法就是暴力去做，如果該區間不全為$0$就遞迴計算直到葉節點\n每個葉節點最多就被暴力除$\\log C$次，每次暴力除最多影響另外$\\log N$個節點，還有rank tree的一個$\\log N$\n即使有單點更新，也只會貢獻$\\log C \\log N$的複雜度\n注意除以$1$不會讓$\\log C$次是好的，不過他不會影響答案所以請記得略過\n總複雜度大概是$\\mathcal{O}((N+Q) \\log N \\log C)$吧\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101  #pragma g++ optimize(\u0026#34;Ofast\u0026#34;) #pragma loop_opt(on) #include \u0026lt;bits/stdc++.h\u0026gt;#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt; using namespace std; using namespace __gnu_pbds; template \u0026lt;typename T\u0026gt; using rbt = tree\u0026lt;T,null_type,less\u0026lt;T\u0026gt;,rb_tree_tag,tree_order_statistics_node_update\u0026gt;; const int N = 100025; unordered_map\u0026lt;int,rbt\u0026lt;int\u0026gt;\u0026gt; mp; struct zkw{ struct node { int val,win,isZero; node() : val(-1), win(0), isZero(0) {} node(int x) : val(x), win(1), isZero(x==0) {} inline friend node operator+(const node \u0026amp;a, const node \u0026amp;b) { node r; if(a.val == b.val) r.val=a.val, r.win=a.win+b.win; else if(a.win\u0026gt;b.win) r.val=a.val, r.win=a.win-b.win; else r.val=b.val, r.win=b.win-a.win; r.isZero = a.isZero\u0026amp;\u0026amp;b.isZero; return r; } friend void pr(const node \u0026amp;p) { cerr \u0026lt;\u0026lt; p.val \u0026lt;\u0026lt; \u0026#39;,\u0026#39; \u0026lt;\u0026lt; p.win \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } seg[N\u0026lt;\u0026lt;1]; int n; inline void init(int sz, int v[]) { n = sz; for(int i = 0; i \u0026lt; n; i++) seg[i+n] = node(v[i]), mp[v[i]].insert(i); for(int i = n-1; i \u0026gt;= 1; i--) seg[i] = seg[i\u0026lt;\u0026lt;1]+seg[i\u0026lt;\u0026lt;1|1]; } void pull(int p) { for(; p; p\u0026gt;\u0026gt;=1) seg[p\u0026gt;\u0026gt;1] = seg[p]+seg[p^1]; } inline void edit(int p, int k) { p+=n; mp[seg[p].val].erase(p-n); seg[p].val = k; seg[p].isZero = (seg[p].val == 0); mp[seg[p].val].insert(p-n); pull(p); } inline void brute(int i,int k) { if(seg[i].isZero) return; if(i \u0026lt; n) brute(i\u0026lt;\u0026lt;1,k), brute(i\u0026lt;\u0026lt;1|1,k), seg[i] = seg[i\u0026lt;\u0026lt;1]+seg[i\u0026lt;\u0026lt;1|1]; //else edit(i-n,seg[i].val/k);  else { mp[seg[i].val].erase(i-n); seg[i].val /= k; seg[i].isZero = (seg[i].val == 0); mp[seg[i].val].insert(i-n); } } inline void div(int l,int r,int k) { int L = l, R = r; for(l+=n,r+=n; l\u0026lt;r; l\u0026gt;\u0026gt;=1, r\u0026gt;\u0026gt;=1) { if(l\u0026amp;1) brute(l++,k); if(r\u0026amp;1) brute(--r,k); } pull(L+n), pull(R-1+n); } inline int winner(int l,int r) { node res = node(); for(l+=n,r+=n; l\u0026lt;r; l\u0026gt;\u0026gt;=1, r\u0026gt;\u0026gt;=1) { //debug(l), debug(r);  if(l\u0026amp;1) res = res+seg[l++]; if(r\u0026amp;1) res = res+seg[--r]; } return res.val; } } sgt; int n,q,v[N]; signed main() { mp.reserve(N); mp.max_load_factor(0.25); ios_base::sync_with_stdio(0), cin.tie(0); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; for(int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; v[i]; sgt.init(n,v); for(int i = 0; i \u0026lt; q; i++) { int c,x,v,l,r; cin \u0026gt;\u0026gt; c; if(c == 1) { cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; v, --x; sgt.edit(x,v); }else if(c == 2) { cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r \u0026gt;\u0026gt; v, --l; if(v!=1) sgt.div(l,r,v); }else if(c == 3) { cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r, --l; v = sgt.winner(l,r); int cnt = mp[v].order_of_key(r) - mp[v].order_of_key(l); if(cnt \u0026gt; (r-l)/2) cout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; else cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } }   ","permalink":"https://omeletwithoutegg.github.io/2020/02/25/TIOJ-2140/","tags":["TIOJ","data-structure"],"title":"TIOJ-2140"},{"contents":"E.海賊王 https://tioj.ck.tp.edu.tw/problems/1102\nDescription 你是一位海賊，現在有$P$個敵人與$T$個寶藏等間距圍成一圓形\n你必須決定一個發射砲彈的方式\n砲彈會波及的範圍是圓形的，每次發射後範圍內的海賊會被殺死，寶藏也會被毀壞\n剩下的會重整隊形，同樣等間距圍成一圓形，且半徑不變（炮彈可以波及的半徑大於他們圍成的圈的半徑）\n檢查過船上的砲彈存量以後，你發現一次至少要炸死兩個敵方海賊（所以剩三個海賊的話一定要一次打死三個）\n你決定寫個程式幫你計算最多可以拿到多少未被毀壞的寶藏\nSolution 半徑根本就是垃圾資訊XDD\n只要炸的到的範圍比圍成的圈的範圍還要大，每次炸的就是環上的一段區間\n總之考慮海賊之間的間隙，本題等價於選取環上許多個不相鄰的間隙使得權重最大\n那麼顯然就直接DP，只要記得考慮環形的問題就好\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68  // __________________ // | ________________ | // || ____ || // || /\\ | || // || /__\\ | || // || / \\ |____ || // ||________________|| // |__________________| // \\###################\\ // \\###################\\ // \\ ____ \\ // \\_______\\___\\_______\\ // An AC a day keeps the doctor away.  #pragma g++ optimize(\u0026#34;Ofast\u0026#34;) #pragma loop_opt(on) #include \u0026lt;bits/extc++.h\u0026gt;#ifdef local #define debug(x) (cerr\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;) #else #include \u0026lt;bits/stdc++.h\u0026gt;#define debug(x) ((void)0) #endif // local #define all(v) begin(v),end(v) #define siz(v) (ll(v.size())) #define get_pos(v,x) (lower_bound(all(v),x)-begin(v)) #define sort_uni(v) sort(begin(v),end(v)),v.erase(unique(begin(v),end(v)),end(v)) #define pb emplace_back #define ff first #define ss second #define mem(v,x) memset(v,x,sizeof v)  using namespace std; using namespace __gnu_pbds; typedef int64_t ll; typedef long double ld; typedef pair\u0026lt;ll,ll\u0026gt; pll; typedef pair\u0026lt;ld,ld\u0026gt; pld; template \u0026lt;typename T\u0026gt; using max_heap = std::priority_queue\u0026lt;T,vector\u0026lt;T\u0026gt;,less\u0026lt;T\u0026gt; \u0026gt;; template \u0026lt;typename T\u0026gt; using min_heap = std::priority_queue\u0026lt;T,vector\u0026lt;T\u0026gt;,greater\u0026lt;T\u0026gt; \u0026gt;; template \u0026lt;typename T\u0026gt; using rbt = tree\u0026lt;T,null_type,less\u0026lt;T\u0026gt;,rb_tree_tag,tree_order_statistics_node_update\u0026gt;; constexpr ld PI = acos(-1), eps = 1e-11; constexpr ll N = 100025, INF = 1e18, MOD = 1000000007, K = 146, inf = 1e9; constexpr inline ll cdiv(ll x, ll m) { return x/m + ((x\u0026lt;0 ^ m\u0026gt;0) \u0026amp;\u0026amp; (x%m)); } // ceiling divide constexpr inline ll modpow(ll e,ll p,ll m=MOD) {ll r=1; for(e%=m;p;p\u0026gt;\u0026gt;=1,e=e*e%m) if(p\u0026amp;1) r=r*e%m; return r;} int r1, r2, n, L, p[N], v[N], dp[N][2], mx[N][2]; signed main() { ios_base::sync_with_stdio(0), cin.tie(0); while(cin \u0026gt;\u0026gt; r1 \u0026gt;\u0026gt; r2 \u0026gt;\u0026gt; n \u0026gt;\u0026gt; L, r1) { L += n; for(int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; p[i]; for(int i = 1; i \u0026lt; n; i++) v[i] = p[i]-p[i-1] - 1; v[n] = p[0]+L-p[n-1] - 1; dp[1][0] = mx[1][0] = 0; dp[1][1] = mx[1][1] = v[1]; int ans = 0; for(int i = 2; i \u0026lt;= n; i++) { dp[i][0] = mx[i-2][0] + v[i]; dp[i][1] = mx[i-2][1] + v[i]; mx[i][0] = max(mx[i-1][0], dp[i][0]); mx[i][1] = max(mx[i-1][1], dp[i][1]); ans = max(ans, dp[i][0]); if(i != n) ans = max(ans, dp[i][1]); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } }   ","permalink":"https://omeletwithoutegg.github.io/2020/02/25/TIOJ-1102/","tags":["TIOJ","dp"],"title":"TIOJ-1102"},{"contents":"Can You Arrive? https://tioj.ck.tp.edu.tw/problems/1798\nDescription 地鐵有$N$個站，$M$條軌道，$K$段行駛路線\n站與站之間使用軌道連接\n保證軌道不會形成環，且$M = N-1$\n每段行駛路線代表有一輛車在兩站之間的最短路徑來回發車\n也就是說這段路上的任意兩站都是互通的，可以直接抵達不需轉車\n現在$Q$位妹子來向你問路，問你能不能從某一站經過任意多次的轉車搭到另一站。\n保證兩站不是同一站。\n$K \\leq N \\leq 10^6, M = N-1, Q \\leq 10^6$\nSolution 每條行駛路線代表的就是在這條路徑上加值\n而查詢到不到得了就是查詢路徑上有沒有$0$\n可以採用輕重鏈剖分維護樹上路徑和\n因為修改都在詢問之前，所以利用前綴和就好，不需要開線段樹\n複雜度$\\mathcal{O}(N + Q \\log N)$\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120  // __________________ // | ________________ | // || ____ || // || /\\ | || // || /__\\ | || // || / \\ |____ || // ||________________|| // |__________________| // \\###################\\ // \\###################\\ // \\ ____ \\ // \\_______\\___\\_______\\ // An AC a day keeps the doctor away.  #pragma g++ optimize(\u0026#34;Ofast\u0026#34;) #pragma loop_opt(on) #include \u0026lt;bits/extc++.h\u0026gt;#ifdef local #define debug(x) (cerr\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;) #else #include \u0026lt;bits/stdc++.h\u0026gt;#define debug(x) ((void)0) #endif // local #define all(v) begin(v),end(v) #define siz(v) (ll(v.size())) #define get_pos(v,x) (lower_bound(all(v),x)-begin(v)) #define sort_uni(v) sort(begin(v),end(v)),v.erase(unique(begin(v),end(v)),end(v)) #define pb emplace_back #define ff first #define ss second #define mem(v,x) memset(v,x,sizeof v)  using namespace std; using namespace __gnu_pbds; typedef int64_t ll; typedef long double ld; typedef pair\u0026lt;ll,ll\u0026gt; pll; typedef pair\u0026lt;ld,ld\u0026gt; pld; template \u0026lt;typename T\u0026gt; using max_heap = std::priority_queue\u0026lt;T,vector\u0026lt;T\u0026gt;,less\u0026lt;T\u0026gt; \u0026gt;; template \u0026lt;typename T\u0026gt; using min_heap = std::priority_queue\u0026lt;T,vector\u0026lt;T\u0026gt;,greater\u0026lt;T\u0026gt; \u0026gt;; template \u0026lt;typename T\u0026gt; using rbt = tree\u0026lt;T,null_type,less\u0026lt;T\u0026gt;,rb_tree_tag,tree_order_statistics_node_update\u0026gt;; constexpr ld PI = acos(-1), eps = 1e-11; constexpr ll N = 1000025, INF = 1e18, MOD = 1000000007, K = 146, inf = 1e9; constexpr inline ll cdiv(ll x, ll m) { return x/m + ((x\u0026lt;0 ^ m\u0026gt;0) \u0026amp;\u0026amp; (x%m)); } // ceiling divide constexpr inline ll modpow(ll e,ll p,ll m=MOD) {ll r=1; for(e%=m;p;p\u0026gt;\u0026gt;=1,e=e*e%m) if(p\u0026amp;1) r=r*e%m; return r;} int n, m, k, q; vector\u0026lt;int\u0026gt; g[N]; int sz[N], pa[N], mxs[N], top[N], dep[N], vis[N], cnt[N], tot; void dfs(int i, int p = 0) { sz[i] = 1, mxs[i] = 0, pa[i] = p, dep[i] = dep[p] + 1;; for(int j: g[i]) if(j != p) { dfs(j, i); sz[i] += sz[j]; if(sz[j] \u0026gt; sz[mxs[i]]) mxs[i] = j; } } void deco(int i, int t, int p = 0) { vis[i] = ++tot, top[i] = t if(mxs[i]) deco(mxs[i], t, i); for(int j: g[i]) if(j != p \u0026amp;\u0026amp; j != mxs[i]) deco(j, j, i); } void add(int a, int b) { //debug(\u0026#34;add\u0026#34;);  while(top[a] != top[b]) { int ta = top[a], tb = top[b]; if(dep[ta] \u0026lt; dep[tb]) swap(a,b), swap(ta,tb); //debug(a), debug(b);  ++cnt[vis[ta]], --cnt[vis[a]+1]; a = pa[ta]; //int sum[100] = {}; for(int i = 1; i \u0026lt;= n; i++) sum[i] = cnt[i]+sum[i-1]; for(int i = 1; i \u0026lt;= n; i++) cout \u0026lt;\u0026lt; !sum[vis[i]] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;  } if(a != b) { if(dep[a] \u0026lt; dep[b]) swap(a,b); //debug(a), debug(b);  ++cnt[vis[b]+1], --cnt[vis[a]+1]; } } int query(int a, int b) { int res = 0; while(top[a] != top[b]) { int ta = top[a], tb = top[b]; if(dep[ta] \u0026lt; dep[tb]) swap(a,b), swap(ta,tb); res += cnt[vis[a]] - cnt[vis[ta]-1]; //debug(res);  a = pa[ta]; } if(a != b) { if(dep[a] \u0026lt; dep[b]) swap(a,b); assert(vis[b] \u0026lt; vis[a]); res += cnt[vis[a]] - cnt[vis[b]]; } //debug(res);  return res == 0; } signed main() { ios_base::sync_with_stdio(0), cin.tie(0); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k \u0026gt;\u0026gt; q; for(int i = 0, a, b; i \u0026lt; m; i++) { cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; g[a].pb(b), g[b].pb(a); } dfs(1); deco(1,1); while(k--) { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; add(a,b); } for(int i = 1; i \u0026lt;= n; i++) cnt[i] += cnt[i-1]; for(int i = 1; i \u0026lt;= n; i++) cnt[i] = !cnt[i]; //for(int i = 1; i \u0026lt;= n; i++) cout \u0026lt;\u0026lt; top[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;  //for(int i = 1; i \u0026lt;= n; i++) cout \u0026lt;\u0026lt; cnt[vis[i]] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;  for(int i = 1; i \u0026lt;= n; i++) cnt[i] += cnt[i-1]; while(q--) { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; cout \u0026lt;\u0026lt; query(a, b) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } }   ","permalink":"https://omeletwithoutegg.github.io/2020/02/23/TIOJ-1798/","tags":["TIOJ","tree","data-structure"],"title":"TIOJ-1798"},{"contents":"聚集問題 https://tioj.ck.tp.edu.tw/problems/1129\nDescription 給定二維平面上$N$個點，若編號$i,j$的點之間的距離不大於$C$則他們之間有連邊\n問最後的連通塊數量以及每個連通塊的大小\nSolution 我想不到比$\\mathcal{O}(N^2)$枚舉直接連邊更好的解了XD\n比起DFS我更喜歡用DSU因此code是DSU\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;vector\u0026gt; const int N = 4001; int s, n, r; std::pair\u0026lt;int,int\u0026gt; p[N]; int pa[N], sz[N]; std::vector\u0026lt;int\u0026gt; ans; int dis(std::pair\u0026lt;int,int\u0026gt; a, std::pair\u0026lt;int,int\u0026gt; b) {return (a.first-b.first)*(a.first-b.first) + (a.second-b.second)*(a.second-b.second);} int anc(int x) {return x==pa[x]?x:pa[x]=anc(pa[x]);} void uni(int x, int y) { if((x=anc(x)) == (y=anc(y))) return; if(sz[x] \u0026lt; sz[y]) s=x, x=y, y=s; pa[y] = x, sz[x] += sz[y]; } signed main() { while(~scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;s, \u0026amp;n, \u0026amp;r)) { p[0] = {s, s}; for(int i = 1; i \u0026lt;= n; i++) { p[i].first = (p[i-1].first*269+11)%103; p[i].second = (p[i-1].second*271+13)%97; pa[i] = i, sz[i] = 1; } sort(p+1, p+n+1); for(int i = 1; i \u0026lt;= n; i++) { for(int j = i+1; j \u0026lt;= n; j++) { if(p[j].first - p[i].first \u0026gt; r) break; if(dis(p[i],p[j]) \u0026lt;= r*r) uni(i, j); } } ans.clear(); for(int i = 1; i \u0026lt;= n; i++) if(pa[i] == i) ans.emplace_back(sz[i]); std::sort(ans.begin(), ans.end()); printf(\u0026#34;%d\\n\u0026#34;, int(ans.size())); for(int x: ans) printf(\u0026#34;%d \u0026#34;, x); puts(\u0026#34;\u0026#34;); } }   ","permalink":"https://omeletwithoutegg.github.io/2020/02/23/TIOJ-1129/","tags":["TIOJ","dsu"],"title":"TIOJ-1129"},{"contents":"殿壬看蝴蝶 https://tioj.ck.tp.edu.tw/problems/2124\nDescription 太長了，略\nSolution 看到第五種操作就會想用平衡樹去寫這題\n然後仔細看看就會發現第八種操作其實和其他操作都沒什麼關係，只有第三、四種操作會改變以蝴蝶編號為順序的區間和\n所以呢對蝴蝶的編號開一個線段樹、對樹的編號開個Splay就能AC了\nSplay只需要實現查一個節點在中序是第個、查中序第k個節點是什麼，還有剪切區間\n至於區間和就隨便維護吧XD，code如下，我不知道該對裸題做甚麼解釋\n寫剪切區間的splay的時候要注意的可能就是不要改到空節點(我是用0代表空節點)的任何值\n也小心不要讓合併的時候合併到同一棵splay，出現環\n中途有一次一個回傳int的函數忘記回傳東西，在TIOJ上吃SF\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;cstdlib\u0026gt; const int N = 200025; int n, q, v[N]; struct SplayTree { struct node { int val, sz; int sum; int ch[2], pa; //bool rev;  } S[N]; bool dir(int i) {return i==S[S[i].pa].ch[1];} /*void filp(int i) { int t = S[i].ch[0]; S[i].ch[0]=S[i].ch[1]; S[i].ch[1]=t; if(i) S[i].rev = !S[i].rev; } void push(int i) { if(S[i].rev) { flip(S[i].ch[0]); flip(S[i].ch[1]); S[i].rev = false; } } void pushdown(int i) { if(S[i].pa) pushdown(S[i].pa); push(i); }*/ void pull(int i) { S[i].sum = S[S[i].ch[0]].sum + S[i].val + S[S[i].ch[1]].sum; S[i].sz = S[S[i].ch[0]].sz + 1 + S[S[i].ch[1]].sz; } void rot(int x) { int y = S[x].pa, z = S[y].pa, d = dir(x); if(z) S[z].ch[dir(y)] = x; S[x].pa = z; S[y].ch[d] = S[x].ch[!d]; if(S[x].ch[!d]) S[S[x].ch[!d]].pa = y; S[x].ch[!d] = y; S[y].pa = x; pull(x), pull(y); } void splay(int x) { while(int y = S[x].pa) { if(S[y].pa) rot(dir(x)!=dir(y) ? x : y); rot(x); } } int kth(int k) { splay(1); //printf(\u0026#34;k = %d\\n\u0026#34;, k);  for(int i = 1; i; ) { //printf(\u0026#34;i = %d\\n\u0026#34;, i);  //system(\u0026#34;PAUSE\u0026#34;);  int s = S[S[i].ch[0]].sz + 1; //printf(\u0026#34;%d\\n\u0026#34;, s);  if(s == k) return splay(i), i; if(k \u0026lt; s) i = S[i].ch[0]; else i = S[i].ch[1], k -= s; } puts(\u0026#34;No such node\u0026#34;), exit(0); } int getrank(int i) { splay(i); return S[S[i].ch[0]].sz + 1; } int endpoint(int i, bool d) { for(splay(i); S[i].ch[d]; i = S[i].ch[d]); return splay(i), i; } int split(int i, bool d) { splay(i); int res = S[i].ch[d]; S[res].pa = S[i].ch[d] = 0, pull(i); return endpoint(res, !d); } void join(int a, int b) { splay(a), splay(b); if(!a || !b || S[a].pa || a == b) return; //printf(\u0026#34;a = %d b = %d\\n\u0026#34;, a, b);  S[b].pa = a, S[a].ch[1] = b, pull(a); } int getsum(int l, int r) { // [l, r]  int a = split(l, 0), b = split(r, 1); int res = S[r].sum; join(a, l), join(r, b); return res; } //#define debug(x) printf(#x \u0026#34; = %d\\n\u0026#34;, x);  void jizz(int l1, int r1, int l2, int r2) { //printf(\u0026#34;IN\\n\u0026#34;);  //debug(l1); debug(r1);  int a1 = split(l1, 0), b1 = split(r1, 1); int a2 = split(l2, 0), b2 = split(r2, 1); //dbg(a1); dbg(b1); dbg(a2); dbg(b2);  join(a1, l2), join(r2, b1); join(a2, l1), join(r1, b2); if(b1 == l2) join(r2, l1); //if(b2 == l1) join(r1, l2);  //dbg();  //printf(\u0026#34;OUT\\n\u0026#34;);  } void modify(int i, int d) { splay(i); S[i].val = d; pull(i); } void init(int n, int v[]) { for(int i = 1; i \u0026lt;= n; i++) S[i].sz = 1, S[i].val = S[i].sum = v[i]; for(int i = 1; i \u0026lt;= n-1; i++) { splay(i); S[i].ch[1] = i+1, S[i+1].pa = i; pull(i); } /* std::function\u0026lt;int(int,int)\u0026gt; build = [\u0026amp;](int l, int r) { if(l \u0026gt; r) return 0; if(l == r) return l; int m = (l+r)/2; int L = build(l, m-1), R = build(m+1, r); S[m].ch[0] = L, S[m].ch[1] = R, S[L].pa = S[R].pa = m, pull(m); return m; }; build(1, n); */ } void dfs(int i) { if(!i) return; dfs(S[i].ch[0]); printf(\u0026#34;%d \u0026#34;, i); dfs(S[i].ch[1]); } void dbg(int i = 1) { printf(\u0026#34;SPLAY %d: \u0026#34;, i); splay(i); dfs(i); puts(\u0026#34;\u0026#34;); } } sp; struct segtree { int n; int sum[N\u0026lt;\u0026lt;1]; void init(int _n, int v[]) { n = _n; for(int i = 0; i \u0026lt; n; i++) sum[i+n] = v[i]; for(int i = n-1; i \u0026gt; 0; i--) sum[i] = sum[i\u0026lt;\u0026lt;1]+sum[i\u0026lt;\u0026lt;1|1]; } void modify(int p, int d) { for(sum[p+=n] = d; p \u0026gt; 1; p \u0026gt;\u0026gt;= 1) sum[p\u0026gt;\u0026gt;1] = sum[p]+sum[p^1]; } int query(int l, int r) { // [l, r) 0 base  int res = 0; for(l+=n, r+=n; l\u0026lt;r; l\u0026gt;\u0026gt;=1, r\u0026gt;\u0026gt;=1) { if(l\u0026amp;1) res += sum[l++]; if(r\u0026amp;1) res += sum[--r]; } return res; } } sgt; signed main() { scanf(\u0026#34;%d%d\\n\u0026#34;, \u0026amp;n, \u0026amp;q); for(int i = 1; i \u0026lt;= n; i++) scanf(\u0026#34;%d\u0026#34;, v+i); sp.init(n, v); sgt.init(n+1, v); while(q--) { int t; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); if(t == 1) { int i, j; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;i, \u0026amp;j); sp.jizz(i,i,j,j); }else if(t == 2) { int i, j; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;i, \u0026amp;j); i = sp.kth(i), j = sp.kth(j); sp.jizz(i,i,j,j); }else if(t == 3) { int i, d; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;i, \u0026amp;d); sp.modify(i, d); sgt.modify(i, d); }else if(t == 4) { int i, d; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;i, \u0026amp;d); i = sp.kth(i); sp.modify(i, d); sgt.modify(i, d); }else if(t == 5) { int l1, r1, l2, r2; scanf(\u0026#34;%d%d%d%d\u0026#34;, \u0026amp;l1, \u0026amp;r1, \u0026amp;l2, \u0026amp;r2); l1 = sp.kth(l1), r1 = sp.kth(r1), l2 = sp.kth(l2), r2 = sp.kth(r2); sp.jizz(l1, r1, l2, r2); }else if(t == 6) { int i; scanf(\u0026#34;%d\u0026#34;, \u0026amp;i); printf(\u0026#34;%d\\n\u0026#34;, sp.kth(i)); }else if(t == 7) { int i; scanf(\u0026#34;%d\u0026#34;, \u0026amp;i); printf(\u0026#34;%d\\n\u0026#34;, sp.getrank(i)); }else if(t == 8) { int l, r; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;l, \u0026amp;r); printf(\u0026#34;%d\\n\u0026#34;, sgt.query(l, r+1)); }else if(t == 9) { int l, r; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;l, \u0026amp;r); l = sp.kth(l), r = sp.kth(r); printf(\u0026#34;%d\\n\u0026#34;, sp.getsum(l, r)); } //sp.dbg();  } return 0; }   ","permalink":"https://omeletwithoutegg.github.io/2020/02/22/TIOJ-2124/","tags":["TIOJ","data-structure","splay-tree"],"title":"TIOJ-2124"},{"contents":"【IOI2015】Boxes 一堆盒子 https://tioj.ck.tp.edu.tw/problems/1884\nDescription 有$L$個地區排成一環狀，依序編號為$0, 1, \\dots, L-1$\n從任何一個地區移動到相鄰的地區所需要的時間均為一單位時間\n現在有$N$個人需要寄送貨物，他們分別住在編號為$p_1, p_2, \\dots, p_n$的地區(已經依非遞減順序排序)\n貨物中心位在編號$0$的地區，並且郵差每次只能帶至多$K$件貨物移動\n(世界上只有一個郵差\u0026hellip;真辛苦)\n身上所有的貨物都送到後，必須回到$0$號地區，才能進行下一輪的送貨\n你的任務就是幫送貨的郵差計算他最少要花多少時間\n才能從貨物中心出發，寄送完所有貨物，最後再回到貨物中心\n(其中可能會回貨物中心很多次以補充貨物)\n$\n1 \\leq K \\leq N \\leq 10^7,\n1 \\leq L \\leq 10^9,\n0 \\leq p_i \u0026lt; L\n$\nSolution 首先有$K=1$的Subtask，可以確定自己對題意的理解\n可以發現題目就是要把這$N$個點分成很多堆，每堆不超過$K$個，使得總成本最小\n一個關鍵的觀察是分的方式肯定是排序過後切成很多連續區間\n不需要考慮$i \u0026lt; x \u0026lt; j$但$x$卻不和$i,j$同一堆的情形，否則可以想辦法交換一下使得答案不會變更差\n至此可以列出DP式\n$$\ndp[i] = \\min\\limits _ {\\max(0, i-k) \\leq j \u0026lt; i} { dp[j] + cost(j+1, i) }\n$$\n其中$cost(l, r) = \\min {L, 2p_r, 2(L-p_l)}$\n代表從$0$號節點開始經過$p_l, p _ {l+1}, \\dots, p_r$再回到$0$號節點所需要的最少時間\n複雜度$\\mathcal{O}(NK)$\n令$a_i = \\min(L, 2p_i), b_i = 2(L-p _ {i+1})$\n$$\ndp[i] = \\min {dp[j] + \\min(a_i, b_j)} = \\min(\\min{dp[j]}+a_i, \\min {dp[j]+b_j});\n$$\n利用單調隊列優化可以快速求得$dp[j]$和$dp[j]+b_j$的最小值，最後的複雜度是$\\mathcal{O}(N)$\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  #include \u0026lt;bits/stdc++.h\u0026gt;#define ff first #define ss second #define pb emplace_back  using namespace std; typedef int64_t ll; const int N = 10000025; int n, k, L; int p[N]; ll solve() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k \u0026gt;\u0026gt; L; for(int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; p[i]; ll dp = 0; deque\u0026lt;pair\u0026lt;int,ll\u0026gt;\u0026gt; dq[2]; dq[0].pb(0, 0); dq[1].pb(0, 2*(L-p[1])); for(int i = 1; i \u0026lt;= n; i++) { /*dp[i] = INF; for(int j = max(0, i-k); j \u0026lt; i; j++) { dp[i] = min(dp[i], dp[j] + min({L, 2*v[i], 2*(L-v[j+1])})); }*/ while(dq[0].front().ff \u0026lt; i-k) dq[0].pop_front(); while(dq[1].front().ff \u0026lt; i-k) dq[1].pop_front(); dp = min(dq[0].front().ss+min(L,2*p[i]), dq[1].front().ss); while(dq[0].size() \u0026amp;\u0026amp; dq[0].back().ss \u0026gt;= dp) dq[0].pop_back(); while(dq[1].size() \u0026amp;\u0026amp; dq[1].back().ss \u0026gt;= dp+2*(L-p[i+1])) dq[1].pop_back(); dq[0].pb(i, dp); dq[1].pb(i, dp+2*(L-p[i+1])); } return dp; /* dp[i] = min(dp[j] + min(L, 2*v[i], 2*(L-v[j])); dp[i] = min(dp[j] + min(a[i], b[j])) = min(min(dp[j])+a[i], min(dp[j]+b[j])); */ } signed main() { ios_base::sync_with_stdio(0), cin.tie(0); int t; cin \u0026gt;\u0026gt; t; while(t--) cout \u0026lt;\u0026lt; solve() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }   ","permalink":"https://omeletwithoutegg.github.io/2020/02/20/TIOJ-1884/","tags":["TIOJ","IOI"],"title":"TIOJ-1884"},{"contents":"控控控之蘿莉控 https://tioj.ck.tp.edu.tw/problems/1828\nDescription 你走在路上遇到了一個可愛小蘿莉，因為你的控屬性，所以你跑上去問了她的名字：「小妹妹～你叫什麼名字啊？」\n她回答：「啊！！！你幹嘛！我不認識你啊你誰啊！！！」\n你：「我是你的好哥哥，來和我一起玩吧～」\n這時機智的小妹妹拿起手機打了110\n你決定要趕快逃跑，以免進入暗無天日的深淵\n於是問題來了！\n你要跑多快才不會被抓(你只能跑整數的速度)？\n因為警察的體力有限，不能跑超過警局外的$10000$單位距離，所以逃出$10000$單位距離就好了\n第一行有一個整數$T$代表測資筆數，\n每行有三個無號整數$X,Y,Z$\n$X$代表你現在跟警察局的距離，\n$Y$代表小妹妹跟警察叔叔還要在$Y$秒才會講完電話，\n$Z$代表講完電話後警察會馬上用秒速$Z$的速度沖上來追你\n$0 \\leq X,Y,Z \\leq 10^6$\n如果講完電話後，你還待在警察局門口，是會被抓的喔\n注意你站在距警察局恰$10000$單位距離的點上也還是會被抓的喔\n請輸出ㄧ個整數代表你至少要用多少的體力才不會被追悼\n如果不管怎麼樣都會被追到請輸出 -1\nSolution 是個大特判題呢\n唯ㄧ會出現 -1 的case就是$X=Y=0$的時候，也就是ㄧ開始就被追上\n首先可以知道人和警察兩個直線的差會與時間成線性\n所以最小的差肯定是出現在端點\n我們僅需要考慮剛出發那一刻和警察跨過$10000$那一刻，是否有被警察超前過即可\n假設$T$是距離講完電話過了$T$秒，並且逃跑的速度是$V$\n那麼可以列出式子\n$$\nX + (Y+T)V \u0026gt; TZ\n$$\n當$T$是$0$，可以知道$V$的最小值不是$0$就是$1$，取決於$X,Y$是否為0\n當警察跨過$10000$時，$T=10000/Z$，移項一下可以得到$V \u0026gt; \\frac{(10000-X)Z}{YZ+10000}$\n不過注意$Z$必須不為$0$，若$Z$為$0$可以直接特判掉\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  #pragma g++ optimize(\u0026#34;Ofast\u0026#34;) #pragma loop_opt(on) #include \u0026lt;cstdio\u0026gt; typedef long long ll; const int L = 10000; int solve() { int x, y, z; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;x, \u0026amp;y, \u0026amp;z); if(x == 0 \u0026amp;\u0026amp; y == 0) return -1; if(x \u0026gt; L) return 0; if(!z) return !x; return (L-x) * ll(z) / (ll(z)*y + L) + 1; /* X + (Y+T)V \u0026gt; min(10000, TZ) X + (Y+T)V \u0026gt; TZ XZ + (YZ+TZ)V \u0026gt; TZZ consider T == 10000/Z and T == 0 V \u0026gt; (10000-X)Z / (ZY+10000) X + YV \u0026gt; 0 */ } signed main() { int t; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); while(t--) printf(\u0026#34;%d\\n\u0026#34;, solve()); return 0; }   ","permalink":"https://omeletwithoutegg.github.io/2020/02/20/TIOJ-1828/","tags":"TIOJ","title":"TIOJ-1828"},{"contents":"B-Game https://tioj.ck.tp.edu.tw/problems/1553\nDescription B-Game是個殘酷的兩人卡片對戰遊戲(Battle Game)\n檯面上有$n$張卡片，排成環狀，每張卡片有其數值\n兩人輪流取卡片，只能選與已經取過的卡片相鄰的卡片，但第一個人不受此限\n選完卡片之後，勝負決定在將兩人手中卡片的數值和\n若某位玩家得分大於另一位玩家，無論大多少均是勝利\n輸出一行包含兩個數\n分別是一開始有幾種拿法可以讓先拿的人勝利\n與先拿的人最多可以拿到多少\nSolution 一開始我沒有注意到環型的條件，送了好多次假解XD\n後面還忘記%n，WA到癱軟www\n現在假設先手第一步取了某張卡\n則剩下的卡片就是環上的一段連續區間，並且不管怎麼拿都會一直保持是連續區間\n可以透過奇偶性知道最後一步輪到誰拿，且拿的位置肯定是區間的最左邊或是最右邊\n而對手ㄧ定會讓自己分數最低，我們則是讓分數盡量高\n因此可以列出簡單的2D/0D轉移式，得到每個區間可以從兩頭拿時先手的最高得分\n再加上先手第一步取得的分數就可以知道從每個地方起手先手所能得到的最高分\n也就知道在那個位置是否有機會勝利了\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  #include \u0026lt;cstdio\u0026gt; inline int min(int a, int b) {return a\u0026lt;b?a:b;} inline int max(int a, int b) {return a\u0026gt;b?a:b;} const int N = 225; int n, v[N], dp[N][N], sum, cnt, mx = 0; signed main() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i = 0; i \u0026lt; n; i++) scanf(\u0026#34;%d\u0026#34;, v+i); for(int i = 0; i \u0026lt; n; i++) sum += v[i]; for(int L = 1; L \u0026lt;= n-1; L++) { for(int i = 0; i \u0026lt; n; i++) { if(n-L \u0026amp; 1) { dp[i][L] = min(dp[i][L-1], dp[(i+1)%n][L-1]); }else { dp[i][L] = max(dp[i][L-1]+v[(i+L-1)%n], dp[(i+1)%n][L-1]+v[i]); } //cout \u0026lt;\u0026lt; dp[i][L] \u0026lt;\u0026lt; \u0026#39; \u0026#39;;  } //cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;  } //for(int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; v[i]+dp[(i+1)%n][n-1] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;  //debug(sum);  for(int i = 0; i \u0026lt; n; i++) { int t = v[i]+dp[(i+1)%n][n-1]; if(t \u0026gt; mx) mx = t; if(t \u0026gt; sum-t) ++cnt; } printf(\u0026#34;%d %d\\n\u0026#34;, cnt, mx); }   ","permalink":"https://omeletwithoutegg.github.io/2020/02/19/TIOJ-1553/","tags":["TIOJ","dp"],"title":"TIOJ-1553"},{"contents":"[純屬無聊] Tie Breaker https://tioj.ck.tp.edu.tw/problems/1274\nDescription 本題考驗你對小向的試煉題敘的理解程度。請回答以下三個問題：\n 假設2-2的圖來自遊戲「甲」(一個包含五個字母的單字)，2-3的圖來自動畫「乙」(一個包含九個字母的單字 ，請問甲和乙中字母e出現幾次？ 假設3-1的圖來自動畫「丙」(包含四個中文字)，3-3的圖來自漫畫「丁」(包含六個中文字) ，請問丙和丁中聲調為二聲的字有幾個？ 假設4-1的圖來自動畫「戊」(包含八個中文字，其中第五個字是三聲)，4-2的圖來自動畫「己」(包含四個中文字)，4-3的圖來自動畫「庚」(包含六個中文字) ，且令為己的前兩個字翻譯成英文後的字母數，為戊的第二個字所代表的數字 ，「辛」是「庚」的第一個字。請問「辛」倍的x+y是幾？  Solution 註: 小向的試煉是TIOJ上一系列的題目，可以自行搜尋\n甲 = Deemo 乙 = charlotte\n第一點的答案 = 3\n丙 = 遊戲人生 丁 = 我的英雄學院\n第二點的答案 = 4\n戊 = 中二病也想談戀愛 己 = 東京闇鴉 庚 = 雙星之陰陽師\n第三點的答案 = 2 * (5 + 2) = 14\n這題是考驗油度或是google程度，不過casper用猜的猜出答案，好糟糕\nAC code 1 2 3 4 5 6  #include \u0026lt;cstdio\u0026gt;int main() { int ans[4] = {-1, 3, 4, 14}, n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); printf(\u0026#34;%d\\n\u0026#34;, ans[n]); }   ","permalink":"https://omeletwithoutegg.github.io/2020/02/16/TIOJ-1274/","tags":"TIOJ","title":"TIOJ-1274"},{"contents":"Problem A. 雷射防護網 https://tioj.ck.tp.edu.tw/problems/1511\nDescription 考慮在正$n$邊形的頂點中任選三點形成的三角形，請統計分別有幾個銳角三角形、直角三角形和鈍角三角形\n注意：兩個三角形被視為不同的，若且唯若三個頂點的編號不完全相同，並且不可以旋轉三角形\n$n \\leq 10^6$\nSolution 簡單排列組合，不過我寫好久還踩到一些坑\n直角的case很容易解決，因為斜邊必須要是外接圓的直徑，故$n$得是偶數\n而所有$n/2$條直徑對應的直角三角形個數就是$2(n/2-1)$\n接著我們先計算鈍角的case\n固定鈍角那個頂點，假設三個角的角度分別等於$a, b, c$個邊(因為是正多邊形所以可以這樣統計)，且$a \u0026gt; b,c$\n那麼所有鈍角三角形的個數就等於$a+b+c = n$且$a \u0026gt; n/2$的正整數解的個數\n此時枚舉$a$，$b+c=n-a$有$n-a-1$組正整數解，可以知道所求即是\n$$\n\\sum _ {a = \\left \\lfloor n/2 \\right \\rfloor + 1} ^ {n-2} n-a-1 = \\sum _ {i=1}^{n-2 - \\left \\lfloor n/2 \\right \\rfloor} i = \\frac{(n-2 - \\left \\lfloor n/2 \\right \\rfloor) (n-2 - \\left \\lfloor n/2 \\right \\rfloor + 1)}{2}\n$$\n記得要乘上$n$，代表以每個頂點當作鈍角頂點\n又所有三角形的個數就是$\\binom{n}{3} = \\frac{n(n-1)(n-2)}{6}$\n扣掉直角及鈍角的個數就是銳角的個數了\n這裡比較慘的是雖然題目的範圍似乎不會讓答案超過 long long\n但計算所有三角形個數的時候可能會溢位\n因此在計算銳角三角形時我先把一個$n/3$提出來，再想辦法好好約分\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; typedef int64_t ll; signed main() { ios_base::sync_with_stdio(0), cin.tie(0); ll n; string s, _; while(cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; s \u0026gt;\u0026gt; _) { ll h = n/2; // half  ll right = n\u0026amp;1 ? 0 : n*(h-1); ll tmp = n-2-h; ll obtuse = tmp*(tmp+1)/2*n; // (# a + b + c = n, max(a,b,c) \u0026gt; n/2)  // (sum _ {a = n/2+1}^{n-2} n-a-1) = sum _ {i=1}^{n-2-n/2} i  // tot = n*(n-1)*(n-2)/6  ll acute = (n-1)*(n-2)/2 - tmp*(tmp+1)/2*3; if(n%3 == 0) acute *= n/3; else acute /= 3, acute *= n; acute -= right; if(s[0] == \u0026#34;Right\u0026#34;[0]) cout \u0026lt;\u0026lt; right \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; else if(s[0] == \u0026#34;Acute\u0026#34;[0]) cout \u0026lt;\u0026lt; acute \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; else if(s[0] == \u0026#34;Obtuse\u0026#34;[0]) cout \u0026lt;\u0026lt; obtuse \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } }   ","permalink":"https://omeletwithoutegg.github.io/2020/02/15/TIOJ-1511/","tags":["TIOJ","math"],"title":"TIOJ-1511"},{"contents":"重疊的天際線 https://tioj.ck.tp.edu.tw/problems/1202\nDescription 地平線上有許多房子，而這些房子在夕陽的照射之下形成有趣的輪廓，我們稱之為天際線(Skyline)。為了方便起見，你可以假設所有的房子都是一個位在2D平面上的矩形，並且有一條邊貼在這個假想2D平面上的X軸。\n一棟建築可以用三元數組$(L_i, H_i, R_i)$來表示，依序代表該建築物的左界座標、高度、右界座標。\n下圖中的八棟建築就是用此方法表示就是\n$(1,11,5), (2,6,7), (3,13,9), (12,7,16), (14,3,25), (19,18,22), (23,13,29), (24,4,28)$。\n一個天際線也可以用類似的「X-遞增序列」表示出來，例如上面的八棟建築合併之後上方右圖的天際線可表示為：\n$(1, 11, 3, 13, 9, 0, 12, 7, 16, 3, 19, 18, 22, 3, 23, 13, 29, 0)$\n請你寫一個程式，給你這些房子的位置，請你把它們形成的天際線描述出來。\n對於每一筆測試資料，請按照題目以及範例輸出格式輸出天際線的樣子。\n請注意，最後一個數字一定是0。也請不要輸出多餘空白。\nSolution 考慮所有矩形的邊界上的點，我們只要確定這些點的最大高度就能夠描述這個天際線\n更進一步的話題目要求的格式甚至只需要考慮左界這個點\n因此我們維護一個 multiset\n從左到右考慮所有邊界，對於任一個建築物的高度$H$，都在$L$的時候加進 multiset 裡面然後在$R$的時候刪掉\n如果這個點的高度和前一次的答案一樣就不需要加進答案裡面\n注意輸出格式QQ，一開始還吃WA好幾次\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  #include \u0026lt;bits/stdc++.h\u0026gt;#define ff first #define ss second #define pb emplace_back  using namespace std; signed main() { ios_base::sync_with_stdio(0), cin.tie(0); int n; while(cin \u0026gt;\u0026gt; n \u0026amp;\u0026amp; n) { map\u0026lt;int, array\u0026lt;vector\u0026lt;int\u0026gt;,2\u0026gt;\u0026gt; mp; multiset\u0026lt;int\u0026gt; ms{0}; vector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; ans; for(int i = 0; i \u0026lt; n; i++) { int L, H, R; cin \u0026gt;\u0026gt; L \u0026gt;\u0026gt; H \u0026gt;\u0026gt; R; mp[L][0].push_back(H); mp[R][1].push_back(H); } for(const auto \u0026amp;V: mp) { int p = V.ff; const auto \u0026amp;in = V.ss[0]; const auto \u0026amp;ou = V.ss[1]; for(int h: in) ms.insert(h); for(int h: ou) ms.erase(ms.find(h)); int H = *--ms.end(); if(ans.empty() || ans.back().ss != H) ans.pb(p,H); } for(int i = 0; i \u0026lt; ans.size(); i++) cout \u0026lt;\u0026lt; ans[i].ff \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; ans[i].ss \u0026lt;\u0026lt; (i+1 == ans.size() ? \u0026#39;\\n\u0026#39; : \u0026#39; \u0026#39;); } }   ","permalink":"https://omeletwithoutegg.github.io/2020/02/09/TIOJ-1202/","tags":["TIOJ","data-structure"],"title":"TIOJ-1202"},{"contents":"5.高中運動會 https://tioj.ck.tp.edu.tw/problems/1156\nDescription 夢幻城市每年為全市高中生舉辦一次運動大會。為促進各校同學之間的交流，採用特別的分隊方式：每一個學校的同學，必須被均勻分散到各隊，使得每一隊中該校的人數皆相同。為增加比賽的競爭性，希望分成越多隊越好。你的任務是由各校的人數，決定最多可分成的隊數。\nSolution 沒想到全國賽竟然有這麼水的題目XDD，題目所求就是所有學校人數的最大公因數\n用 __gcd 就足夠了，不過我覺得這份code寫起來很簡短所以我想貼出來ouo，順便加了個輸入優化\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  #include \u0026lt;cstdio\u0026gt; inline char readchar() { constexpr int B = 1\u0026lt;\u0026lt;20; static char buf[B], *p, *q; if(p == q \u0026amp;\u0026amp; (q=(p=buf)+fread(buf,1,B,stdin)) == buf) return EOF; return *p++; } inline int nextint() { int x = 0, c = readchar(); while(c \u0026lt; \u0026#39;0\u0026#39;) c = readchar(); while(c \u0026gt;= \u0026#39;0\u0026#39;) x=x*10+(c^\u0026#39;0\u0026#39;), c=readchar(); return x; } int gcd(int a, int b) { while(int t = b) b = a%b, a = t; return a; } signed main() { int n = nextint(), g = 0; while(n--) g = gcd(g, nextint()); printf(\u0026#34;%d\\n\u0026#34;, g); }   ","permalink":"https://omeletwithoutegg.github.io/2020/02/08/TIOJ-1156/","tags":"TIOJ","title":"TIOJ-1156"},{"contents":"爆炸吧現充~ https://tioj.ck.tp.edu.tw/problems/1600\nDescription 求共有幾個滿足\n$$\n1 \\leq x \\leq n,\n\\exists k \u0026gt; 1, k^2 | x\n$$\n的$x$\nSolution 一開始我的想法是$[\\mu(x)=0]$的前綴，想說用杜教篩或莫比烏斯反演什麼的，但怎麼推都推不出來\n去問王政祺之後，他說直接枚舉平方數再排容就好，至於排容的係數就直接取$\\mu$\n令\n$$\nS_k = \\{x | 1 \\leq x = k^2t \\leq n\\}\n$$\n則答案就是\n$$\n\\begin{matrix}\n|\\bigcup _ {k} S_k| \u0026amp;= \u0026amp; (|S_2| + |S_3| + |S_5| + |S_7| + \\cdots)\\newline\n\u0026amp;- \u0026amp; (|S_6|+|S _ {10}|+|S _ {14}|+|S _ {15}|+ \\cdots)\\newline\n\u0026amp;+ \u0026amp; (|S _ {30}|+|S _ {42}|+|S _ {66}|+|S _ {70}|+ \\cdots)\\newline\n\u0026amp; \u0026amp; \\vdots\\newline\n\u0026amp;= \u0026amp; \\sum -\\mu(k) |S_k|\\newline\n\u0026amp;= \u0026amp; -\\sum\\limits _ {k=2}^\\sqrt{n} \\mu(k) \\frac{n}{k^2}\n\\end{matrix}\n$$\n依照不同質因數去分類，可以發現排容的正負號和$\\mu$一致(我也不太會證明最後的部分QQ)\n看來我的思維要再靈活一些 \u0026gt; \u0026lt;\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; typedef long long ll const ll N = 1000025; int mu[N],np[N]; vector\u0026lt;int\u0026gt; prs; signed main() { mu[1] = np[1] = 1; for(int i = 2; i \u0026lt; N; i++) { if(!np[i]) prs.push_back(i), mu[i] = -1; for(int p: prs) { if(i*p \u0026gt;= N) break; np[i*p] = 1; if(i%p) { mu[i*p] = -mu[i]; }else { mu[i*p] = 0; break; } } } ll ans = 0, n; while(cin \u0026gt;\u0026gt; n) { ans = 0; for(ll i = 2; i*i \u0026lt;= n; i++) ans -= n / (i*i) * mu[i]; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } }   ","permalink":"https://omeletwithoutegg.github.io/2020/01/26/TIOJ-1600/","tags":["TIOJ","math"],"title":"TIOJ-1600"},{"contents":"\u0026lt;! \u0026ndash; ### Author: Sean Liu \u0026ndash;\u0026gt;\n超大畫框設置 https://tioj.ck.tp.edu.tw/problems/1283\nDescription 在一個「漸進式框架」當中，你想要找到一個最大面積的矩形位置放置你最喜愛的一幅畫。\n當然地，畫框必須掛正，所以矩形的四個邊都必須與框架的邊平行或垂直。\n所謂的「漸進式框架」，指的是任何一個水平線截出的框架區段是連續，並且由上往下該區段只會往右移動，如下圖\nSolution 這個是蕭梓宏在超級久之前講的四邊形優化題目，筆者發現已經過了一年多了還沒AC就想說來寫看看好了！這一題不難想到，對於每一個在下面的線，都計算是哪一條在上面的線和它搭配會有最佳，再取$\\max$就好了。不過，這樣需要$O(MN)$的時間，頗爛。\n不過呢，還可以觀察（且證明）一個性質，就是：倘若$L(x)$為下面的線中第$x$條線所對應到的最佳（面積最大）的上面的線的編號，則$L(x + 1) \\geq L(x)$！有了這個性質，大概就可以維護一個deque，裡面放一堆東西$(L, R, I)$來維護說：上面第$I$條線可以轉移下面第$L$到第$R$的線為最佳。一開始只有一個$(0, M, 0)$，然後每次進來一個上面的線段就開始判斷（假設目前deque中最後面的元素為$(L, R, I)$，且目前我在第$X$條）：\n 若$X$和$L$的矩形比$I$和$L$的矩形還大，這代表$(L, R, I)$這個區間可以完全不要了，pop掉 若$X$和$M - 1$的矩形比$I$和$M - 1$的矩形還小（也就是最後一個），則代表我永遠贏不了那一條線，我就直接break了，反正贏不了 否則，開始二分搜說我到哪裡可以贏$(L, R, I)$，也就是說，找一個最小的$m$使得$m$和$I$的矩形小於或等於$m$和$X$的矩形  維護完之後，再掃一次$M$條線取$\\max$就好了！\nAC code 感覺寫完到AC的時間還不會很久，但是中間有一堆小細節被卡（還有二分搜寫錯、被卡long long、$N, M$要除以二、面積計算出錯等有趣環節），幸好沒有太大的問題！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83  #include \u0026lt;iostream\u0026gt;#include \u0026lt;deque\u0026gt;#define int long long int #define ericxiao ios_base::sync_with_stdio(0);cin.tie(0); using namespace std; const int maxN = 1e5; struct Line{ int h, l, r; Line(){} Line(int h, int l, int r): h(h), l(l), r(r){} } line, ups[maxN], downs[maxN]; struct Seg{ int l, r, id; /* l, r: from 0 ~ M - 1, bottom id: 0 ~ N - 1, top */ Seg(){} Seg(int l, int r, int id): l(l), r(r), id(id){} } current; inline int Abs(int x){ return (x \u0026lt; 0) ? -x : x; } inline int area(Line u, Line d){ return (u.r - d.l) * (d.h - u.h); //Don\u0026#39;t ABS here :( } deque\u0026lt;Seg\u0026gt; trans; int N, M, r, d, cx, cy; signed main(){ ericxiao; cin \u0026gt;\u0026gt; N; N /= 2; cx = cy = 0; for(int i = 0; i \u0026lt; N; i++){ // - | - |  cin \u0026gt;\u0026gt; r \u0026gt;\u0026gt; d; ups[i] = Line(cy, cx, cx + r); cx += r; cy += d; } cin \u0026gt;\u0026gt; M; M /= 2; cx = cy = 0; for(int i = 0; i \u0026lt; M; i++){ // | - | - | - | -  cin \u0026gt;\u0026gt; d \u0026gt;\u0026gt; r; downs[i] = Line(cy + d, cx, cx + r); cx += r; cy += d; } for(int i = 0; i \u0026lt; N; i++){ while(trans.size()){ int id = trans.back().id; if(area(ups[id], downs[trans.back().l]) \u0026lt;= area(ups[i], downs[trans.back().l])) trans.pop_back(); else break; } if(trans.size()){ int id = trans.back().id, L = trans.back().l, R = trans.back().r, MID; if(area(ups[id], downs[M - 1]) \u0026gt; area(ups[i], downs[M - 1])) continue; while(L + 1 \u0026lt; R){ MID = (L + R) / 2; if(area(ups[id], downs[MID]) \u0026lt;= area(ups[i], downs[MID])) R = MID; else L = MID; } trans.back().r = L; trans.push_back(Seg(L, M, i)); } else { trans.push_back(Seg(0, M, i)); } } int ans = 0; for(int i = 0; i \u0026lt; M; i++){ while(trans.size() \u0026amp;\u0026amp; trans.front().r \u0026lt;= i) trans.pop_front(); ans = max(ans, area(ups[trans.front().id], downs[i])); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   ","permalink":"https://omeletwithoutegg.github.io/2020/01/25/TIOJ-1283/","tags":["TIOJ","dp","dp-optimization"],"title":"TIOJ-1283"},{"contents":"2020 IOIC 小記 五天都11點回家 好累喔\n不過聽到很多神奇技巧和神奇題目(?)\nDay 1 早上是常數優化與電腦結構，看到一些毒瘤的東東還有會造成我常數大的一些寫法\n中午有貓貓時間，電仁分享了他競程的心得之後，丟給我們一些題目\n可是我幾乎都不會做QQ\n下午塗大為的DP\u0026amp;圖論，速度超快的www趕火車\n聽到有點快要睡著，超難\n晚上趣味賽有一個隊友還沒來QQ，不過這種類型的題目真棒\n空白、tab和換行不算edit distance的規則沒有想到能讓註解佔了好多除蟲題的名額XD\nDay 2 資料結構初階OwO!\n直接從前一天下午的惡夢變成舒適的溫水浴，於是我決定自己翻講義刷題\n可是圖論超煩躁，DP我也不會SCC我也一直寫爛，搞了快半天AC不了半題WTF\n最後還被卡記憶體，直接怒不寫了QQ\n下午原本是數學被換成根號算法，因為蔣立元有講過蠻多的所以YP這堂還算友善(?)\n聽到很多有趣的題目，不過可惜我前一天自己看講義被捏到一些QQ\n除了2的冪次分層(不知道怎麼用)以外都蠻喜歡的\n因為分塊就是優美的暴力(O)\n第一場個人賽，實在是打的有點差\npA被我擱置，聽到解法之後覺得超顯然QQ為甚麼我賽中不開啊\n開場就碰pF，碰到結尾還AC不了，到底三小\n我已經自認locality很好了欸QAQ而且取模乘法加法都有好好寫啊 早知道就多試一點順序了\npC開的極慢，DP式一直推不出來，有夠爛，還一直亂猜加一減一吃WA吃滿\npE水題太慢看到ww在附中練習賽有寫過所以速速AC\npD樹重心，推導一下式子之後想到二分搜祖先再加上去(題解後感覺這個解超爛QQ)\npG是樹上莫隊裸題，但我不知道為甚麼沒自信寫(X)\n時間全都砸在pB，想到一個實作又臭又長的作法，花了好久實作之後TLE\n到結束沒時間再寫出一題QQ\n結束之後YP跟我說我差一點AC pB，要用degree分塊才不會爛掉(我就爛)\nDay 3 早上字串，幾乎都是聽了n遍之後已經大概知道的東西(?)\nAC前一天pB之後有點不知道要做啥\n於是我試著刻了AC自動機，參考了一下講義上的code之後傳到TIOJ 1306得到SF\n我想說是不是我空間開錯，怎麼開都會SF，看了一下其他人的AC code發現他們都開4e5\n然後我開了還是SF，後來才發現是我有地方寫錯@_@\n後面唯一覺得有興趣的後綴自動機仍然沒有聽懂(?)雖然之前在講師小莫的blog上面看過了不過還是感覺好複雜\n隨機和近似實在是不太容易通靈出來，有些只要直覺的隨便亂做多次一點就足夠AC\n但是竟然有要先自己創造另一個題目的算法XD太難啦\n團體賽總算是有了第三個隊友\npH是裸題，pI是水題，隊友找出來之後我趕緊水掉\n剩下根本找不出來甚麼題目可做XD\npD是簡單DP，可是我一直WA，還好隊友有提醒我一些鬼邊界狀況\n剩下時間花了好多開pJ，結果還漏看一個條件，而且在樹上的想法也是錯的QQ\npB以為是簡單結論題沒想到原來是奇怪的經典題(?)\npC也應該猜一猜在賽中寫出來的，有點可惜\nDay 4 電石的資結進階，除了Pattern以外都有稍微聽過(線段樹優化建圖是在某一次蕭梓宏選的virtual場看到的XD)\nCDQ分治更是直接聽電石本人講過ww\nPattern這東西好神奇喔，我想還要好久我才能通透，感覺題目再一些變化的話我就看不出來了\n下午是數學，但在上課之前出現神秘講師短短的講了Splay和LCT就不見了XD(聽說他是原本FFT的講師?)\n中堂休息之後突然就切換到數學模式，頓時有種我不會數學的感覺，明明聽過那麼多東西卻無法好好應用\n(也許我應該去精進我的數學實力? 要怎麼讀啊?)\n個人賽一開始有想法只有pB，看到Scoreboard上面大家都AC pD就猜是水結論題直接給他猜結論下去XDD\n接著花時間把pB寫掉了，雖然看到一些人在丟pC不過沒什麼想法，反而翻到pE是今天電石上課直接講過的東西XD\n因為印象很深所以想說要自己刻出來，不過最後還是參考了一些講義的細節想法QQ\n幸運的搶到pF首殺之後發現pC其實好水，寫掉之後就沒事做了(?)\nDay 5 正式賽，長達五小時\n看著Dashboard pA pG寫掉\n接著大家都寫出了pM，隊友給我想法之後我一直瘋狂WA，賽中也看不到各個testcase的狀況，根本不知道是全錯還是edge case QQ\n第一筆submission是11:50，到12:40都還在debug，結果是測資出問題，找不到不存在的bug是理所當然QQ\n記分板上大家都寫了pK pL，但我覺得pK構造沒有甚麼想法，pL初步認為是greedy(都列出DP式了還不會算複雜度，我就爛)\npH裸題應該早點開但我沒開\npI不知道為什麼一直吃WA\npE也是前幾天講過的題目，應該要想到的\n營隊最後一場比賽打得不太好真可惜QQ\n一些忘了時間點的事情  披薩好好吃 誰那麼ㄎㄧㄤ在吃披薩的時候放佛教動起來和叫品翔唱附中校歌 每天都有nut，每天都有bug 被張程凱拉去辦了Ubike的帳戶，之後幾天都騎Ubike從捷運站到德田館 Euclidea又被翻回來玩，真的有趣 一個有點心的營隊值得給讚 開一個好的judge感覺好難，沒事就會爆炸XDD 好多人從IOIC得到感冒或流感，怕 大家都喜歡隨機，哪那麼衰 大家都同意塗大為超帥 軟軟超夯，果然可愛就是正義，每次放到桌上的軟軟都會不見qq 看到好多只有聽過的人的面孔(?) 跟國手聊天應該是最大的收穫之一，還聽到有些神奇的演算法  ","permalink":"https://omeletwithoutegg.github.io/2020/01/25/IOICamp-2020/","tags":["experience","IOIC"],"title":"IOICamp-2020"},{"contents":"進階的入門 https://tioj.ck.tp.edu.tw/problems/1168\nDescription 你需要實作五個函式：\n1 2 3 4 5  void pop_big(); void pop_small(); void push(int s); int big(); int small();   其中第一個函式需要將最大的數字移除，第二個函式需要將最小的數字移除，第三個函式需要將一個數加入目前的數字們，第四個函式需要回傳當前的最大值，第五個函式需要回傳當前的最小值。\n假設一開始沒有任何數字，請你實作這五個操作。\n保證當沒有數字的時候只會呼叫 push ，並且加入的數字 $\\leq 10^9$ ，五個函數的總呼叫次數 $\\leq 10^6$ 。\nSolution 好久之前就一直卡這題總算AC了@_@\n最直覺的想法就是開一個multiset或map，但這題的時限超誇張的緊\n可以想到利用 priority_queue 維護最大最小\n然而假如一個數字在最大堆被pop掉，不容易在最小堆裡面把他給刪除\n我一開始的想法是開 unordered_map 之類的紀錄每個數字的個數，想當然而吃了TLE\n後來查了解才發現紀錄插入編號並且維護編號幾的被 pop 了就可以\n於是我就在 priority_queue 裡面存編號，並且自己寫compare函式\n不過這樣寫的locality很差，似乎會讓常數暴增\n改成用struct包住之後剩下最後兩筆TLE，試了好久之後才想到 priority_queue 是用 vector 實作，動態開的空間顯然會浪費很多常數，不如自己靜態開一個大陣列\n注意到 pop 操作最多就是呼叫次數的一半，所以 heap 只要開 5e5 就好了， push 的時候多出去的可以直接丟掉\n至於 popped 陣列應該還是要開到 1e6 ，因為被 pop 的東西有可能編號很大，TIOJ上的測資似乎沒考慮到這個地方所以開 5e5 也能AC\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51  #pragma g++ optimize(\u0026#34;Ofast\u0026#34;) #pragma loop_opt(on) #include \u0026#34;lib1168.h\u0026#34;#define ff first #define ss second  const int N = 500001; struct node { int val, id; bool operator\u0026lt;(const node \u0026amp;b)const{return val\u0026lt;b.val;} }; struct heap { node v[N]; int sz; void push(node x) { v[sz++] = x; std::push_heap(v,v+sz); if(sz \u0026gt;= N) sz = N-1; } node top() {return v[0];} void pop() { std::pop_heap(v,v+sz); --sz; } } mx, mn; int tot; bool popped[N]; // should be N*2? inline void push(int x) { mx.push({x, tot}); mn.push({-x, tot}); ++tot; } inline int big() { while(popped[mx.top().id]) mx.pop(); return mx.top().val; } inline int small() { while(popped[mn.top().id]) mn.pop(); return -mn.top().val; } inline void pop_big() { while(popped[mx.top().id]) mx.pop(); popped[mx.top().id] = 1; mx.pop(); } inline void pop_small() { while(popped[mn.top().id]) mn.pop(); popped[mn.top().id] = 1; mn.pop(); }   ","permalink":"https://omeletwithoutegg.github.io/2020/01/25/TIOJ-1168/","tags":["TIOJ","data-structure"],"title":"TIOJ-1168"},{"contents":"C.幼稚國王的獎賞 https://tioj.ck.tp.edu.tw/problems/1094\nDescription 定義一個非負整數集合的價值是裡面所有數字XOR起來\n給定一些非負整數，問你能選出價值最高的子集價值是多少？\nSolution 經典題 maximum subset xor\n線性基 首先可以把每個數字的二進位看成模2的$k$維向量\nspan 我們說一群向量$S = {\\textbf{v}_ 1, \\textbf{v}_ 2, \\dots, \\textbf{v}_ n}$的線性生成空間是\n$$\n\\textrm{span}(S) = { \\sum _ {i=1}^n\\lambda _ i \\textbf{v} _ i }\n$$\n也就是說$\\textrm{span}(S)$代表的是所有$S$內的元素的有限線性組合\nlinear independent 對於一組向量${\\textbf{v}_ 1, \\textbf{v}_ 2, \\dots, \\textbf{v} _ n}$\n若存在不全為$0$的$\\lambda_1, \\lambda_2, \\dots, \\lambda_n$使得\n$$\n\\sum _ {i=1}^n\\lambda_ i \\textbf{v}_ i = \\textbf{0}\n$$\n則我們說這群向量是線性相關的；反之則稱為線性獨立(linear independent)\n一組線性相關的向量至少有一個向量可以用其他向量表示\n說明: 不失一般性設$\\lambda _ 1 \\neq 0$，則\n$$\n\\textbf{v} _ 1 = \\sum _ {i=2}^n \\frac{-\\lambda _ i}{\\lambda _ 1} \\textbf{v} _ i\n$$\nbasis 一組向量$B={\\textbf{e}_ 1, \\textbf{e}_ 2, \\dots, \\textbf{e}_ n}$是一個向量空間$V$的基底(basis)若且唯若$\\textrm{span}(B) = V$且$B$是一組線性獨立的向量\n由定義可以直接推出，$V$中的所有向量$\\textbf{v}$都可以唯一表示為$B$裡面的向量的線性組合，因為\n$$\n\\textbf{v} = \\sum \\lambda_ i \\textbf{e}_ i = \\sum \\lambda_ i' \\textbf{e}_ i \\Leftrightarrow \\sum (\\lambda_ i - \\lambda_ i') \\textbf{e}_ i = \\textbf{0} \\Leftrightarrow \\forall i, \\lambda_ i = \\lambda_ i'\n$$\n高斯消去 講了那麼多廢話，這題到底要怎麼做呢？\n設給定的數字集合是$V$，可以發現我們要求的就是$S = \\textrm{span}(V)$中的最大值，透過維護$S$的基底集合$B$，我們能夠快速得知是否能夠湊出一個第k位是1的XOR值\n當我們考慮到第k位的時候，我們至多只需要保存一個最高位是第k位的基底，因為假設有兩個基$x,y$其第k位都是1，則可以用$x \\oplus y$來代替$x$\n嘗試加入一個數字$x$到基底時，我們從$x$的最高位k開始看\n假設已經有一個基底$e$的最高位是第k位，我們就可以把$x$替換成$x \\oplus e$，如果此時$x$變為0代表$x$已經可以用前面的一些基底湊出來了，加入$x$會破壞線性獨立的特性；\n反之，若沒有一個基底$e$的最高位是第k位，那我們就直接加入$x$作為提供第k位的1的人\n那麼最後我們要怎麼取最大值呢？同樣從最高位開始看\n如果目前看到第k位，並且答案的第k位是0\n若又剛好存在一個最高位是第k位的基底$e$的話，我們取$e$肯定不會虧嘛\n因為$e$是我們維護唯一一個最高位是第k位的基底，之後不會再考慮到第k位以上的東西了\n如果上面的東東聽不懂的話就努力看code參透吧QQ\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int K = 20; int n,v; int bas[K]; void ins(int x) { for(int i = K-1; i \u0026gt;= 0; i--) if(x \u0026amp; (1\u0026lt;\u0026lt;i)) { if(bas[i]) x ^= bas[i]; else { bas[i] = x; break; } } } int getmax() { int res = 0; for(int i = K-1; i \u0026gt;= 0; i--) { if((res ^ bas[i]) \u0026amp; (1\u0026lt;\u0026lt;i)) res ^= bas[i]; } return res; } signed main() { ios_base::sync_with_stdio(0), cin.tie(0); while(cin \u0026gt;\u0026gt; n \u0026amp;\u0026amp; n) { for(int i = 0; i \u0026lt; K; i++) bas[i] = 0; for(int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; v; ins(v); } cout \u0026lt;\u0026lt; getmax() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } }   ","permalink":"https://omeletwithoutegg.github.io/2020/01/24/TIOJ-1094/","tags":["TIOJ","bitmask","linear-algebra"],"title":"TIOJ-1094"},{"contents":"我很忙 https://tioj.ck.tp.edu.tw/problems/1408\nDescription 給定$n$個時段$[l_i, r_i)$\n問至少有多少單位時間要是忙碌的才能滿足\n「每個時段中都有至少$c_i$單位時間是忙碌的」(每單位時間都不是忙碌就是空閒)\n註: 題目保證有解\nSolution 看到這種很多區間的題目，就會很想把它們照右界從小到大排序\n可以想到一個greedy策略\n按右界遞增排序好之後，遇到一個時段就看是否已經滿足條件\n如果已經滿足了就跳過\n如果還沒有的話就必須選一些時間由空閒變為忙碌，而這些時間依照貪心的原則是從越右邊開始選越好\n(選左邊的不會對之後右界更大的時段有比較多幫助)\n檢查是否滿足條件只要維護區間和\n於是我的作法是用一棵線段樹配上一個 stack\n每次新插入一個時段，先以線段樹查詢這個區間內忙碌的時間總共是多少\n接著對於剩下需要再增加的時間，維持 stack 內是不相交且排序好的一些時段，代表那些時間必須要是忙碌的\n只要看目前最右邊的忙碌時段就能處理好\n這份AC code中我沒有值域壓縮(因為我懶)\n一臉在CF上欠hack\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76  #include \u0026lt;bits/stdc++.h\u0026gt;#define pb emplace_back #define mem(v,x) memset(v, x, sizeof(v)) #define ff first #define ss second  using namespace std; const int N = 100025; int sum[N\u0026lt;\u0026lt;1],tag[N]; void upd(int p, int d, int h) { sum[p] += d * (1\u0026lt;\u0026lt;h); if(p \u0026lt; N) tag[p] += d; } void push(int p) { for(int h = __lg(N); h \u0026gt;= 0; h--) { int i = p\u0026gt;\u0026gt;h; if(!tag[i\u0026gt;\u0026gt;1]) continue; upd(i, tag[i\u0026gt;\u0026gt;1], h); upd(i^1, tag[i\u0026gt;\u0026gt;1], h); tag[i\u0026gt;\u0026gt;1] = 0; } } void pull(int p) { for(int h = 0; p \u0026gt; 1; h++, p\u0026gt;\u0026gt;=1) sum[p\u0026gt;\u0026gt;1] = sum[p]+sum[p^1] + tag[p\u0026gt;\u0026gt;1] * (2\u0026lt;\u0026lt;h); } void modify(int l, int r, int d) { int L = l, R = r, h = 0; for(l+=N, r+=N; l\u0026lt;r; l\u0026gt;\u0026gt;=1, r\u0026gt;\u0026gt;=1, h++) { if(l\u0026amp;1) upd(l++, d, h); if(r\u0026amp;1) upd(--r, d, h); } pull(L+N), pull(R-1+N); } int query(int l, int r) { push(l+N), push(r-1+N); int res = 0; for(l+=N, r+=N; l\u0026lt;r; l\u0026gt;\u0026gt;=1, r\u0026gt;\u0026gt;=1) { if(l\u0026amp;1) res += sum[l++]; if(r\u0026amp;1) res += sum[--r]; } return res; } vector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; stk; void ins(int l, int r, int c) { c -= query(l, r); if(c \u0026lt;= 0) return; int now = r; while(stk.size() \u0026amp;\u0026amp; now - stk.back().ss \u0026lt;= c) { c -= now - stk.back().ss; now = stk.back().ff; modify(stk.back().ff, stk.back().ss, -1); stk.pop_back(); } stk.pb(now-c, r); modify(now-c, r, 1); //for(auto s: stk) cout \u0026lt;\u0026lt; \u0026#39;[\u0026#39; \u0026lt;\u0026lt; s.ff \u0026lt;\u0026lt; \u0026#39;,\u0026#39; \u0026lt;\u0026lt; s.ss-1 \u0026lt;\u0026lt; \u0026#39;]\u0026#39; \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } struct seg { int l, r, c; } v[N]; signed main() { ios_base::sync_with_stdio(0), cin.tie(0); int n; while(cin \u0026gt;\u0026gt; n \u0026amp;\u0026amp; n) { for(int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; v[i].l \u0026gt;\u0026gt; v[i].r \u0026gt;\u0026gt; v[i].c; sort(v,v+n, [](seg \u0026amp;a, seg \u0026amp;b){return a.r\u0026lt;b.r;}); stk.clear(); mem(sum, 0), mem(tag, 0); for(int i = 0; i \u0026lt; n; i++) ins(v[i].l, v[i].r, v[i].c); int sum = 0; for(auto s: stk) sum += s.ss - s.ff; cout \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } }   ","permalink":"https://omeletwithoutegg.github.io/2020/01/14/TIOJ-1408/","tags":["TIOJ","greedy","data-structure"],"title":"TIOJ-1408"},{"contents":"1.銀河帝國旅行社 https://tioj.ck.tp.edu.tw/problems/1152\nDescription 給一棵樹，找最遠的兩個點的距離\nSolution 這裡用類似DP的方法\ndfs(i) 回傳一個 {ans, deepest} 分別表示以$i$為根子樹中的答案和從$i$往下走的最遠距離\n那ans可以分成有經過$i$的和沒經過的，有經過的就看最深的兩個子樹加起來是多少，沒經過的就遞迴下去算\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  #include \u0026lt;bits/stdc++.h\u0026gt;#define pb emplace_back #define ff first #define ss second using namespace std; int n; vector\u0026lt;int\u0026gt; g[N]; pair\u0026lt;int,int\u0026gt; dfs(int i) { vector\u0026lt;int\u0026gt; tmp{0}; int ans = 0; for(int j: g[i]) { auto p = dfs(j); ans = max(ans, p.ff); tmp.pb(p.ss+1); } sort(all(tmp), greater\u0026lt;int\u0026gt;()); if(tmp.size() \u0026gt;= 2) ans = max(ans, tmp[0]+tmp[1]); return {ans, tmp[0]}; } signed main() { ios_base::sync_with_stdio(0), cin.tie(0); cin \u0026gt;\u0026gt; n; for(int i = 0; i \u0026lt; n; i++) { int x; while(cin \u0026gt;\u0026gt; x \u0026amp;\u0026amp; ~x) g[i].pb(x); } cout \u0026lt;\u0026lt; dfs(0).ff \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }   ","permalink":"https://omeletwithoutegg.github.io/2020/01/12/TIOJ-1152/","tags":["TIOJ","dp","tree"],"title":"TIOJ-1152"},{"contents":"這次打跨年CTF應該是我第一次打一個正常的CTF吧（？）\n感覺好多有趣的題目www\nhttps://ctf.bamboofox.cs.nctu.edu.tw/\nSolved Problems Welcome Joy說看題目給的影片就有flag了\nWeb newbie 被作業解掉，好像往source code的註解裡面找就對了\nLand-1 良心題\n直接copy全國模擬賽的code，送我們這些有打的人免費分數\nLand-2碰了好久一直CE，QQ\nI can\u0026rsquo;t see you 給了一個 what.rar ，Joy說不知道密碼不過丟到網路上某個工具就解開了XD(密碼是blind，聽說有人直接猜出來)\n之後會看到一張白底有黑點的圖片，對照盲人點字可以拿到flag\nHow2decompyle 題目給了一個沒有副檔名的檔案\n因為題目名稱裡面有py，嘗試把他丟到google找到的decompyler之類的東西?\n不過因為沒有副檔名他不吃，他只吃.py和.pyc(這時我們才知道我們大概拿到.pyc，是byte code XDD)\n於是改副檔名再丟一樣的地方就得到原始的.py檔了\n讀一下發現怎麼讓他跑出flag之後跑一跑就AC了(?)\nHappy New Year 賽中新增的題目，直接給flag ww\nTree 作業丟給我的(?)\n解壓縮他給的檔案之後發現看起來很欠DFS，確定葉節點是檔案可以直接讀之後就想寫個DFS\n不過shell的遞迴我不會，想說用python，不過還是要查套件:(，爛死\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  from os import chdir from glob import glob def dfs(s): s = s[0] #print(\u0026#39;s = \u0026#39;, s) typ = s[-1] #print(typ) if typ == \u0026#39;+\u0026#39;: return dfs(glob(s+\u0026#34;/0_*\u0026#34;)) + dfs(glob(s+\u0026#34;/1_*\u0026#34;)) if typ == \u0026#39;x\u0026#39;: return dfs(glob(s+\u0026#34;/0_*\u0026#34;)) * dfs(glob(s+\u0026#34;/1_*\u0026#34;)) if typ == \u0026#39;r\u0026#39;: #print(\u0026#39;path = \u0026#39;, s) return int(open(s).read()) for i in range(37): chdir(\u0026#34;flag[\u0026#34;+str(i)+\u0026#34;]/\u0026#34;) print(chr(dfs(glob(\u0026#34;0_*\u0026#34;))), end = \u0026#39;\u0026#39;) chdir(\u0026#34;..\u0026#34;)   AlphaGO 題目給了一張圖片，是一張棋盤，上面有一些位置有不同字元\n還有一個奇怪的Hint，不過看不懂\n和Joy討論之後我丟出是不是「依照AlphaGo某場比賽下子順序看棋盤上的字元」的想法\nJoy就把他給AC了XD，通靈死\noracle 蠻早看這題的，不過靠自己真的想不出來QQ\n他有給server.py，所以我們知道他server跑的東西是RSA\n可以做兩件詢問: 問flag加密後的東西和n、問一個密文C解密之後的明文mod 3的餘數\n並且每次連線的n都會是固定的\n解法蠻數學的，參考\nhttps://ctf-wiki.github.io/ctf-wiki/crypto/asymmetric/rsa/rsa_chosen_plain_cipher-zh/#rsa-byte-oracle\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  #!/usr/bin/env python3 from Crypto.Util.number import * import os import sys import socket from fractions import Fraction host = \u0026#34;34.82.101.212\u0026#34; port = 20001 s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((host, port)) print(\u0026#39;connect success\u0026#39;) def ask(C): s.send(bytes(\u0026#39;2\\n\u0026#39;,\u0026#39;utf-8\u0026#39;)) _ = s.recv(1024) s.send(bytes(f\u0026#39;{C}\\n\u0026#39;,\u0026#39;utf-8\u0026#39;)) raw = s.recv(1024).split() #print(raw) return int(raw[2]) def main(): print(\u0026#39;main start\u0026#39;) _ = s.recv(1024) s.send(bytes(\u0026#39;1\\n\u0026#39;,\u0026#39;utf-8\u0026#39;)) raw = s.recv(1024).split() C = int(raw[2]); N = int(raw[5]) #exit() mp = {} for i in range(3): mp[-N * i % 3] = i ciph3 = pow(3, 65537, N) L = Fraction(0, 1) R = Fraction(N, 1) while R-L \u0026gt; 0.01: C = C * ciph3 % N K = mp[ask(C)] I = (R-L)/3 L = L + I*K R = L + I print(L, R) print(round(L)) print(round(R)) # L,R is plain text main()   這樣就可以得到一個整數\n6345976407505107785691848974596122250401442742754095997\n然後這邊有三個蠢錯誤\n 不會用python的os套件，而且忽略了UX的輸出 一開始用浮點數搜尋，搜出來好幾次都不一樣XDD(而且每次都超久，要詢問近700次左右)，後來發現大家都寫分數就直接用分數了\u0026hellip;天真的以為python的浮點數能處理300多位 本來丟到網路上轉hex的東西是爛的QQ，用python才得到  1 2  \u0026gt;\u0026gt; hex(6345976407505107785691848974596122250401442742754095997) = \u0026#39;0x42414d424f4f464f587b53696d506c45305241436c337d\u0026#39;   然後就很明顯是兩個一組的ascii了，丟到網路上轉ascii的東西得到flag\n心得 好多用google的題目(X\n而且也好多部分應該要是先備知識的我也一直google XDD\n不過有解出題目感覺好有成就感（？）\n最後三個人的成績是27名\u0026gt;w\u0026lt;開心\n","permalink":"https://omeletwithoutegg.github.io/2020/01/02/bamboofox-ctf/","tags":["CTF","experience"],"title":"bamboofox-ctf"},{"contents":"警力配置 https://tioj.ck.tp.edu.tw/problems/2037\nDescription 裸的二分圖匹配\nSolution 這邊給匈牙利算法\n有一個subtask是給一個點數很多的樹\n特判用dp即可\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114  // __________________ // | ________________ | // || ____ || // || /\\ | || // || /__\\ | || // || / \\ |____ || // ||________________|| // |__________________| // \\###################\\ // \\###################\\ // \\ ____ \\ // \\_______\\___\\_______\\ // An AC a day keeps the doctor away.  #pragma g++ optimize(\u0026#34;Ofast\u0026#34;) #pragma loop_opt(on) #include \u0026lt;bits/extc++.h\u0026gt;#ifdef local #define debug(x) (cerr\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;) #else #define debug(x) ((void)0) #endif // local #define all(v) begin(v),end(v) #define siz(v) (ll(v.size())) #define get_pos(v,x) (lower_bound(all(v),x)-begin(v)) #define sort_uni(v) sort(begin(v),end(v)),v.erase(unique(begin(v),end(v)),end(v)) #define pb emplace_back #define ff first #define ss second #define mem(v,x) memset(v,x,sizeof v)  using namespace std; using namespace __gnu_pbds; typedef int64_t ll; typedef long double ld; typedef pair\u0026lt;ll,ll\u0026gt; pll; typedef pair\u0026lt;ld,ld\u0026gt; pld; template \u0026lt;typename T\u0026gt; using max_heap = __gnu_pbds::priority_queue\u0026lt;T,less\u0026lt;T\u0026gt; \u0026gt;; template \u0026lt;typename T\u0026gt; using min_heap = __gnu_pbds::priority_queue\u0026lt;T,greater\u0026lt;T\u0026gt; \u0026gt;; template \u0026lt;typename T\u0026gt; using rbt = tree\u0026lt;T,null_type,less\u0026lt;T\u0026gt;,rb_tree_tag,tree_order_statistics_node_update\u0026gt;; constexpr ld PI = acos(-1), eps = 1e-5; constexpr ll N = 2025, INF = 1e18, MOD = 998244353, K = 11, inf = 1e9; constexpr ll modpow(ll e,ll p,ll m=MOD) {ll r=1; for(;p;p\u0026gt;\u0026gt;=1,e=e*e%m) if(p\u0026amp;1) r=r*e%m; return r;} constexpr inline ll cdiv(ll x, ll m) { return (x+m-1)/m; } // ceiling divide, x/m for flooring divide  struct BipartiteMatching { vector\u0026lt;int\u0026gt; G[N]; int mx[N],my[N],vis[N],now,n; void init(int _n) { n = _n; for(int i = 1; i \u0026lt;= n; i++) G[i].clear(); } void addEdge(int x,int y) { G[x].pb(y); } bool dfs(int x) { if(vis[x] == now) return false; vis[x] = now; for(int y:G[x]) if(my[y]==-1 || dfs(my[y])) return my[mx[x]=y]=x, true; return false; } int solve() { int ans = 0; for(int i = 1; i \u0026lt;= n; i++) vis[i] = 0, mx[i] = -1, my[i] = -1; for(int i = 1; i \u0026lt;= n; i++) if(mx[i] == -1) for(int j:G[i]) if(my[j]==-1) { my[mx[i]=j]=i; ans++; break; } for(now = 1; now \u0026lt;= n; now++) if(mx[now] == -1 \u0026amp;\u0026amp; dfs(now)) ans++; return ans; } } sv; signed main() { ios_base::sync_with_stdio(0), cin.tie(0); int t; cin \u0026gt;\u0026gt; t; while(t--) { int p,q,m; cin \u0026gt;\u0026gt; p \u0026gt;\u0026gt; q \u0026gt;\u0026gt; m; if(max(p,q) \u0026lt; N) { sv.init(max(p,q)); for(int i = 0; i \u0026lt; m; i++) { int a,b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; sv.addEdge(a,b); } cout \u0026lt;\u0026lt; sv.solve() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }else { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; tr(p+q+1); vector\u0026lt;array\u0026lt;int,2\u0026gt;\u0026gt; dp(p+q+1); //assert(m == p+q-1);  for(int i = 0; i \u0026lt; m; i++) { int a,b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; tr[a].pb(b+p); tr[b+p].pb(a); } function\u0026lt;void(int,int)\u0026gt; dfs = [\u0026amp;](int i, int p) { dp[i][1] = (p != 0); int mx = 0; for(int j:tr[i]) if(j!=p) { dfs(j,i); dp[i][1] += dp[j][0]; dp[i][0] += dp[j][0]; mx = max(mx, dp[j][1] - dp[j][0]); } dp[i][0] += mx; }; dfs(1,0); cout \u0026lt;\u0026lt; max(dp[1][0],dp[1][1]) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } }   ","permalink":"https://omeletwithoutegg.github.io/2019/12/31/TIOJ-2037/","tags":["TIOJ","dp","matching"],"title":"TIOJ-2037"},{"contents":"萬里長城 https://tioj.ck.tp.edu.tw/problems/1441\nDescription 給定一個序列，找出最長的「長城」子序列\n一個序列$\u0026lt; a_1,a_2,\\dots,a_n \u0026gt;$必須符合下列幾點才算是「長城」\n n是奇數 若$i$是偶數，則$a_i$必須小於相鄰的項 若$i$是奇數，則$a_i$必須大於相鄰的項  Solution 貪心法\n維護一個tail表示前$i$項滿足點2. 3.的最佳解，其結尾是多少\n假設下一個項h必須比tail大\n若h比tail大，那就直接接上去(並更新tail)，否則就把tail替換成h\n反之亦然\n證明大概可以用數歸吧(?)我也不太會說明QQ\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14  #include \u0026lt;iostream\u0026gt;signed main() { ios_base::sync_with_stdio(0), cin.tie(0); int n, tail = -1, inc = 1, ans = 0; cin \u0026gt;\u0026gt; n; while(n--) { cin \u0026gt;\u0026gt; h; if(h == tail) continue; if(h \u0026lt; tail ^ inc) ++ans, inc = !inc; tail = h; } if(inc) --ans; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }   ","permalink":"https://omeletwithoutegg.github.io/2019/12/31/TIOJ-1441/","tags":["TIOJ","greedy"],"title":"TIOJ-1441"},{"contents":"同餘算數 定義 $$m | (a-b) \\Leftrightarrow a \\equiv b \\pmod m$$\n或者說$a,b$同餘於$m$\n基本性質 當一個題目要求答案模一個數字$m$時\n通常我們都可以不用先算出一個很大的答案再取模\n利用下面的規則能夠在計算的過程中一邊取模(加減乘不會改變等價關係)\n設\n$$\n\\left \\{\n\\begin{matrix}\na_0 \\equiv a_1 \\pmod m\\newline\nb_0 \\equiv b_1 \\pmod m\n\\end{matrix}\n\\right .\n$$\n則易得到\n$$\n\\left \\{\n\\begin{matrix}\na_0 \\pm b_0 \\equiv a_1 \\pm b_1 \\pmod m\\newline\na_0b_0 \\equiv a_1b_1 \\pmod m\n\\end{matrix}\n\\right .\n$$\n模逆元 在一般實數的除法時，如果我們想知道除以$a$的結果，可以看成乘上倒數$1/a$\n也就是說找一個$x$使得$ax = 1$\n而在模$m$的情況下，我們同樣也可以用一個使得$ax \\equiv 1$的$x$來代替除以$a$的運算，稱為模逆元\n(如果常常打CF的話應該常常看見上面模逆元的敘述)\n求取模逆元$x = a^{-1}$只要把同餘關係改寫成$ax = my+1$就可以用擴展歐幾里得求解了\n注意$a,m$必須互質才會有模逆元\n例: 如果要求\n$$\n\\frac{a}{b} + \\frac{c}{d} = \\frac{ad+bc}{bd}\n$$\n由於\n$$\n(ab^{-1} + cd^{-1}) \\cdot bd \\equiv ad+bc \\pmod m\n$$\n也就是說$ab^{-1} + cd^{-1}$是和$\\frac{ad+bc}{bd}$等價的東西\n冪次們 從$a \\equiv b \\pmod m$不可推出$k^a \\equiv k^b \\pmod m$！\n不過依照歐拉定理可以化簡冪次上的東西\n由歐拉定理\n$$\n(a, n) = 1 \\Leftrightarrow a ^ {\\varphi(n)} \\equiv 1 \\pmod n\n$$\n可以知道\n$$\na \\equiv b \\pmod {\\varphi(n)} \\Leftrightarrow k^a \\equiv k^b \\pmod n\n$$\n假如$n$是質數的話還可以用來求模逆元\n因為對質數$p$來說$\\varphi(p) = p-1$，$a^{p-1} \\equiv 1 \\pmod p$\n故$a^{-1} \\equiv a^{p-2}$(注意0還是沒有模逆元)\n","permalink":"https://omeletwithoutegg.github.io/2019/12/30/Modulo-Arithmetic/","tags":["tutorial","math"],"title":"Modulo-Arithmetic"},{"contents":"黑色騎士團的飛彈野望 https://tioj.ck.tp.edu.tw/problems/1567\nDescription 給定平面上$n$個點，求至少要用幾個圓心在$x$軸上、半徑為$r$的圓才能覆蓋所有點\n若不可行輸出-1\nSolution 首先我們對每個點都可以知道包覆它的圓的圓心範圍在$x$軸的哪段區間\n那題目就轉換成在$x$軸上放一些圓心，使得每個點對應的區間內都至少有一個點被選到\n此為greedy經典題，按照右界排序後，由小到大檢查若某個區間還沒有放東西就放一個在它的右界\n證明很簡單，右界最小的區間內一定至少要選一個點放\n假設沒有選右界$r$而選了某個點$i$放，則改選右界，不會有其他右界更大的區間$I$包含$i$卻不包含$r$\n故選右界最小的區間的右界不會錯過最佳解\n無解的判斷就是只要有一個點和$x$軸距離超過$r$就不可行，否則顯然至多用$n$個圓可以覆蓋所有點\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65  // __________________ // | ________________ | // || ____ || // || /\\ | || // || /__\\ | || // || / \\ |____ || // ||________________|| // |__________________| // \\###################\\ // \\###################\\ // \\ ____ \\ // \\_______\\___\\_______\\ // An AC a day keeps the doctor away.  #pragma g++ optimize(\u0026#34;Ofast\u0026#34;) #pragma loop_opt(on) #include \u0026lt;bits/extc++.h\u0026gt;#ifdef local #define debug(x) (cerr\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;) #else #include \u0026lt;bits/stdc++.h\u0026gt;#define debug(x) ((void)0) #endif // local #define all(v) begin(v),end(v) #define siz(v) (ll(v.size())) #define get_pos(v,x) (lower_bound(all(v),x)-begin(v)) #define sort_uni(v) sort(begin(v),end(v)),v.erase(unique(begin(v),end(v)),end(v)) #define pb emplace_back #define ff first #define ss second #define mem(v,x) memset(v,x,sizeof v)  using namespace std; using namespace __gnu_pbds; typedef int64_t ll; typedef long double ld; typedef pair\u0026lt;ll,ll\u0026gt; pll; typedef pair\u0026lt;ld,ld\u0026gt; pld; template \u0026lt;typename T\u0026gt; using max_heap = __gnu_pbds::priority_queue\u0026lt;T,less\u0026lt;T\u0026gt; \u0026gt;; template \u0026lt;typename T\u0026gt; using min_heap = __gnu_pbds::priority_queue\u0026lt;T,greater\u0026lt;T\u0026gt; \u0026gt;; template \u0026lt;typename T\u0026gt; using rbt = tree\u0026lt;T,null_type,less\u0026lt;T\u0026gt;,rb_tree_tag,tree_order_statistics_node_update\u0026gt;; constexpr ld PI = acos(-1), eps = 1e-8; constexpr ll N = 1000025, INF = 1e18, MOD = 998244353, K = 256, inf = 1e9; constexpr inline ll cdiv(ll x, ll m) { return x/m + (x\u0026lt;0 ^ m\u0026gt;0) \u0026amp;\u0026amp; (x%m); } // ceiling divide constexpr ll modpow(ll e,ll p,ll m=MOD) {ll r=1; for(e%=m;p;p\u0026gt;\u0026gt;=1,e=e*e%m) if(p\u0026amp;1) r=r*e%m; return r;} ll n,r,x,y,ans; pld seg[N]; signed main() { ios_base::sync_with_stdio(0), cin.tie(0); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; r; for(int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; if(abs(y) \u0026gt; r) return cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;, 0; ld d = sqrt(r*r-y*y); seg[i] = {x+d, x-d}; // {r, l}  } sort(seg, seg+n); ld last = -INF; for(int i = 0; i \u0026lt; n; i++) if(seg[i].ss \u0026gt; last) { ++ans; last = seg[i].ff; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }   ","permalink":"https://omeletwithoutegg.github.io/2019/12/29/TIOJ-1567/","tags":["TIOJ","greedy"],"title":"TIOJ-1567"},{"contents":"捲積方法 OAO 本篇的重點應該是放在理解與使用與競程相關的捲積，其中會利用到FFT或NTT加速\n這邊先定義一下捲積$ * $是什麼\n$$\n(a * b) _ x = \\sum _ {i+j=x} a_i b_j\n$$\n實際上就等價於我們常見的多項式乘法\nnaive的做法是$\\mathcal{O}(n^2)$，顯然不夠令人滿意\n1 2 3 4 5  for(int i = 0; i \u0026lt; A.size(); i++) { for(int j = 0; j \u0026lt; B.size(); j++) { res[i+j] += A[i] * B[j]; } }   DFT 先假設我們有兩個多項式\n$$\nA(x) = \\sum a_i x^i, B(x) = \\sum b_i x^i\\newline\nC(x) = A(x)B(x)\n$$\n除了上述利用分配律乘開以外\n因為$C$的次數已經可以確定\n我們也可以在$A(x)$和$B(x)$找出$n$個相異的點，相乘之後再利用插值法代入得到$C$\n其中$n = \\deg C + 1$\n也就是\n$$\n\\begin{bmatrix}\n1 \u0026amp; x_0 \u0026amp; x_0^2 \u0026amp; \\cdots \u0026amp; x_0^{n-1}\\newline\n1 \u0026amp; x_1 \u0026amp; x_1^2 \u0026amp; \\cdots \u0026amp; x_1^{n-1}\\newline\n\\vdots \u0026amp; \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots\\newline\n1 \u0026amp; x _ {n-1} \u0026amp; x _ {n-1}^2 \u0026amp; \\cdots \u0026amp; x _ {n-1}^{n-1}\n\\end{bmatrix}\n\\begin{bmatrix}\na_0\\newline a_1\\newline \\vdots\\newline a _ {n-1}\n\\end{bmatrix} =\n\\begin{bmatrix}\nA(x_0)\\newline A(x_1)\\newline \\vdots\\newline A(x _ {n-1})\n\\end{bmatrix}\n$$\n$$\n\\begin{bmatrix}\n1 \u0026amp; x_0 \u0026amp; x_0^2 \u0026amp; \\cdots \u0026amp; x_0^{n-1}\\newline\n1 \u0026amp; x_1 \u0026amp; x_1^2 \u0026amp; \\cdots \u0026amp; x_1^{n-1}\\newline\n\\vdots \u0026amp; \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots\\newline\n1 \u0026amp; x _ {n-1} \u0026amp; x _ {n-1}^2 \u0026amp; \\cdots \u0026amp; x _ {n-1}^{n-1}\n\\end{bmatrix}\n\\begin{bmatrix}\nb_0\\newline b_1\\newline \\vdots\\newline b _ {n-1}\n\\end{bmatrix} =\n\\begin{bmatrix}\nB(x_0)\\newline B(x_1)\\newline \\vdots\\newline B(x _ {n-1})\n\\end{bmatrix}\n$$\n$$\n\\begin{bmatrix}\n1 \u0026amp; x_0 \u0026amp; x_0^2 \u0026amp; \\cdots \u0026amp; x_0^{n-1}\\newline\n1 \u0026amp; x_1 \u0026amp; x_1^2 \u0026amp; \\cdots \u0026amp; x_1^{n-1}\\newline\n\\vdots \u0026amp; \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots\\newline\n1 \u0026amp; x _ {n-1} \u0026amp; x _ {n-1}^2 \u0026amp; \\cdots \u0026amp; x _ {n-1}^{n-1}\n\\end{bmatrix}\n^{-1}\n\\begin{bmatrix}\nA(x_0)B(x_0)\\newline A(x_1)B(x_1)\\newline \\vdots\\newline A(x _ {n-1})B(x _ {n-1})\n\\end{bmatrix} =\n\\begin{bmatrix}\nc_0\\newline c_1\\newline \\vdots\\newline c _ {n-1}\n\\end{bmatrix}\n$$\n最後一步直接高斯消去或用拉格朗日/牛頓插值法可以做到$\\mathcal{O}(n^2)$\n上述步驟稱為DFT(對序列的版本叫離散傅立葉變換，與使用積分的連續傅立葉變換相對)和IDFT\n但是這樣根本沒有改進多少複雜度啊？\n邁向快速傅立葉變換的鑰匙是利用複數，取特定的某些$x$讓我們能夠分治\nRoot of Unity 首先先來介紹單位根$\\omega$是使得\n$$\n\\omega ^ n = 1\\newline\n\\forall 0 \\leq i \u0026lt; j \u0026lt; n, \\omega^i \\neq \\omega^j\n$$\n的數\n複習一下歐拉公式$$e^{ix} = \\cos x + i\\sin x$$\n習慣上可以取$\\omega_n = e^{-\\frac{2\\pi i}{n}}$(下標是表示$n$是最小的$i$使$\\omega^i = 1$，或者說$\\operatorname{ord}(\\omega_n) = n$)\n推薦觀賞3B1B系列\nhttps://youtu.be/v0YEaeIClKY\nhttps://youtu.be/mvmuCPvRoWQ\n引理們 Lemma a. $$\n\\omega _ {dn}^{dk} = (e^{\\frac{2\\pi i}{dn}})^{dk} = (e^{\\frac{2\\pi i}{n}})^k = \\omega_n^k\n$$\nLemma b. $$\n\\omega_n^{\\frac{n}{2}} = \\omega_2 = e^{i\\pi} = -1\n$$\nCooley-Tukey FFT algorithm 先假設$n$是2的冪次，然後下面提到的$i$都只是index\n將DFT中的$x_i$取值為$\\omega_n^i$，可以知道我們要算的就是對$i \\in [0, n-1]$求\n$$\ny_i = \\sum _ {j=0}^{n-1} a_j (\\omega_n^i)^j\n$$\n把右式的奇數項和偶數項分開處理(這邊是原理的精華)\n$$\n\\begin{align}\ny_i = \\sum _ {j=0}^{n-1} a_j (\\omega_n^i)^j\n\u0026amp;= \\sum _ {j=0}^{\\frac{n}{2}-1} a _ {2j} (\\omega_n^i)^{2j} + \\sum _ {j=0}^{\\frac{n}{2}-1} a _ {2j+1} (\\omega_n^i)^{2j+1}\\newline\n\u0026amp;= \\sum _ {j=0}^{\\frac{n}{2}-1} a _ {2j} (\\omega _ {\\frac{n}{2}}^i)^j + \\omega_n^i \\sum _ {j=0}^{\\frac{n}{2}-1} a _ {2j+1} (\\omega _ {\\frac{n}{2}}^i)^j\\newline\n\u0026amp;= F _ {even}(i) + \\omega_n^i F _ {odd}(i)\n\\end{align}\n$$\n其中$F _ {even}, F _ {odd}$分別是以奇數和偶數項FFT得到的東西，可以遞迴求解\n雖然以$\\frac{n}{2}$的長度遞迴只能得到$i \\in [0, \\frac{n}{2}-1]$的答案\n不過$F _ {even}$和$F _ {odd}$都有週期$\\frac{n}{2}$，再由Lemma b.可以簡化成\n$$\n\\text{for } 0 \\leq i \u0026lt; \\frac{n}{2},\n\\left\\{\\begin{matrix}\ny _ i \u0026amp;= F _ {even}(i) + \\omega_n^i F _ {odd}(i) \\newline\ny _ {i+\\frac{n}{2}} \u0026amp;= F _ {even}(i) - \\omega_n^i F _ {odd}(i)\n\\end{matrix}\\right.\n$$\n時間複雜度有$T(n) = 2T(n/2) + \\mathcal{O}(n)$，由主定理可知$T(n) = \\mathcal{O}(n\\log n)$\n要將FFT一言以概之，大概就是利用分治法將多項式轉換成點值表示吧\n附上遞迴版的參考程式碼，雖然迭代版通常效率較好不過遞迴版有助於理解\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  const double PI = acos(-1); typedef complex\u0026lt;double\u0026gt; cd; vector\u0026lt;cd\u0026gt; FFT(const vector\u0026lt;cd\u0026gt; \u0026amp;F) { // assume F.size() == 2^k \tif(F.size() == 1) return F; // base case (important) \tvector\u0026lt;cd\u0026gt; rec[2], ans; for(int i = 0; i \u0026lt; F.size(); i++) rec[i\u0026amp;1].push_back(F[i]); rec[0] = FFT(rec[0]); rec[1] = FFT(rec[1]); double theta = -2*PI / F.size(); cd now = 1, omega(cos(theta), sin(theta)); ans.resize(F.size()); for(int i = 0; i \u0026lt; F.size()/2; i++) { ans[i] = rec[0] + now * rec[1]; ans[i+F.size()/2] = rec[0] - now * rec[1]; } return ans; }   Inverse-FFT 那麼要怎麼做IFFT(傅立葉變換的逆變換)，也就是把點值表示轉換回係數呢？\nFFT可以寫成矩陣的形式，也就是\n$$\n\\begin{bmatrix}\n1 \u0026amp; 1 \u0026amp; 1 \u0026amp; \\cdots \u0026amp; 1\\newline\n1 \u0026amp; \\omega \u0026amp; \\omega^2 \u0026amp; \\cdots \u0026amp; \\omega^{n-1}\\newline\n\\vdots \u0026amp; \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots\\newline\n1 \u0026amp; \\omega^{n-1} \u0026amp; (\\omega^{n-1})^2 \u0026amp; \\cdots \u0026amp; (\\omega^{n-1})^{n-1}\n\\end{bmatrix}\n\\begin{bmatrix}\nc_0\\newline c_1\\newline \\vdots\\newline c _ {n-1}\n\\end{bmatrix} =\n\\begin{bmatrix}\nC(1)\\newline C(\\omega)\\newline \\vdots\\newline C(\\omega^{n-1})\n\\end{bmatrix}\n$$\n左項有一個范德蒙矩陣$V = [\\omega^{ij}]$ (0-base)\n事實上其反矩陣就是$V' = [\\frac{1}{n}\\omega^{-ij}]$\n說明:\n$$\n[V * V'] _ {i,j} = \\sum _ {k=0}^{n-1} V _ {i,k} V' _ {k,j} = \\frac{1}{n}\\sum _ {k=0}^{n-1} \\omega^{k(i-j)}\n$$\n$i=j$時顯然為1\n當$i \\neq j$利用等比級數公式可以知道總和為$0$\n故相乘的結果是單位矩陣\n可以發現我們只需要把FFT的$\\omega$改成倒數，最後再除上$n$就是IFFT所需要的\n因為FFT和IFFT的相似性，我們可以將程式碼整合如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  const double PI = acos(-1); typedef complex\u0026lt;double\u0026gt; cd; vector\u0026lt;cd\u0026gt; FFT(const vector\u0026lt;cd\u0026gt; \u0026amp;F, bool inv) { // assume F.size() == 2^k \tif(F.size() == 1) return F; // base case (important) \tvector\u0026lt;cd\u0026gt; rec[2]; for(int i = 0; i \u0026lt; F.size(); i++) rec[i\u0026amp;1].push_back(F[i]); rec[0] = FFT(rec[0],inv); rec[1] = FFT(rec[1],inv); double theta = (inv ? 1 : -1) * 2 * PI / F.size(); cd now = 1, omega(cos(theta), sin(theta)); vector\u0026lt;cd\u0026gt; ans(F.size()); for(int i = 0; i \u0026lt; F.size()/2; i++) { ans[i] = rec[0][i] + now * rec[1][i]; ans[i+F.size()/2] = rec[0][i] - now * rec[1][i]; now *= omega; } if(inv) for(int i = 0; i \u0026lt; ans.size(); i++) ans[i] /= 2; return ans; }   Convolution 有了FFT和IFFT兩個工具，我們要做捲積就很簡單了\n 確定兩個多項式相乘的次數，並且選擇一個足夠大的$n = 2^k$(後面可以補0) 利用Cooley-Tukey演算法求出$A,B$的傅立葉變換$\\hat A, \\hat B$ 將$\\hat A, \\hat B$在對應位置兩兩相乘得到$\\hat C$(可能叫Hadamard Product吧) 再利用Cooley-Tukey演算法求出$C$  1 2 3 4 5 6 7 8 9 10 11 12 13  vector\u0026lt;cd\u0026gt; A{1,3,4}; vector\u0026lt;cd\u0026gt; B{1,2,5}; signed main() { int n = 1\u0026lt;\u0026lt;__lg(A.size()+B.size())+1; A.resize(n); B.resize(n); A = FFT(A,0); B = FFT(B,0); vector\u0026lt;cd\u0026gt; C(n); for(int i = 0; i \u0026lt; n; i++) C[i] = A[i]*B[i]; C = FFT(C,1); for(int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; C[i].real() \u0026lt;\u0026lt; \u0026#34; \\n\u0026#34;[i==n-1]; }   Iterative Version 迭代的版本不但簡單執行時間又快，值得記一下\n觀察遞迴的情況\n可以看到我們每次都是將一個序列的偶數項放前面做，奇數項放後面做再合併\n這可以想成將最低位的0/1移到最高位，例如\n$$\n100010\\textbf{1} \\rightarrow \\textbf{1}100010\\newline\n111110\\textbf{1} \\rightarrow \\textbf{1}111110\\newline\n101010\\textbf{0} \\rightarrow \\textbf{0}101010\n$$\n重複執行了把最低位移到最高位的動作$k = \\log_2{n}$次之後\n原本放在$i$的位置的數字的index最後會被放到$j$的地方，其中$j$是$i$在$k$位二進位數的反轉\n也就是說我們可以一開始就把所有數字放到他在遞迴樹中對應的位置，再一層一層往上合併\n那要拿哪些合併呢？其實每個相鄰的兩塊的相同位置對應的就是$F _ {even}$和$F _ {odd}$，組合算出$y_i$之後要填的地方也是那兩格\n剩下的就是看code理解了吧\u0026hellip;OwO?\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  typedef complex\u0026lt;double\u0026gt; cd; void FFT(cd F[], int n, bool inv) { // in-place FFT, also assume n = 2^k \tfor(int i = 0, j = 0; i \u0026lt; n; i++) { if(i \u0026lt; j) swap(F[i], F[j]); // magic! (maintain j to be the bit reverse of i) \tfor(int k = n\u0026gt;\u0026gt;1; (j^=k) \u0026lt; k; k\u0026gt;\u0026gt;=1); } for(int step = 1; step \u0026lt; n; step \u0026lt;\u0026lt;= 1) { double theta = (inv ? 1 : -1) * PI / step; cd omega(cos(theta), sin(theta)); for(int i = 0; i \u0026lt; n; i += step*2) { cd now(1,0); for(int j = 0; j \u0026lt; step; j++) { cd a = F[i+j]; cd b = F[i+j+step] * now; F[i+j] = a+b; F[i+j+step] = a-b; now *= omega; } } } if(inv) for(int i = 0; i \u0026lt; n; i++) F[i] /= n; }   NTT 注意到我們可以實行分治的關鍵就是存在一個$\\omega$使得\n$$\n\\omega ^ n = 1 \\wedge\n\\forall 0 \\leq i \u0026lt; j \u0026lt; n, \\omega^i \\neq \\omega^j\n$$\n現在我們想要在模一個質數$p$下做類似的事\n費馬小定理表明\n$$\n\\forall (a,p) = 1, a^{\\varphi(p)} \\equiv 1 \\pmod p\n$$\n如果有原根$g$使得\n$$\n\\forall 0 \\leq i \u0026lt; j \u0026lt; \\varphi(p), g^i \\not \\equiv g^j \\pmod p\n$$\n那麼$\\omega$的選擇就很簡單了，也就是$\\omega_n \\equiv g ^ {\\frac{\\varphi(p)}{n}}$\n容易驗證$\\omega_n$滿足上面的性質\n這樣做必須滿足$n | \\varphi(p)$，而若使用Cooley-Tukey演算法的話$n$會是2的冪次\n也就是說若$\\varphi(p) = p-1 = t \\cdot 2^k$，其中$t$是奇數\n那對這個$p$來說可行的$n$的範圍最多就是$2^k$了\n這也是為什麼NTT的模數常常都是那些數字的原因\n因為$p-1$必須在二進位下有很多個後綴0\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  const int64_t MOD = 998244353, G = 3; int64_t modpow(int64_t e, int64_t p, int64_t m) { int64_t r = 1; for(; p; p\u0026gt;\u0026gt;=1) { if(p\u0026amp;1) r = r*e%m; e = e*e%m; } return r; } void NTT(int64_t F[], int n, bool inv) { // assume n = 2^k! \tfor(int i = 0, j = 0; i \u0026lt; n; i++) { if(i \u0026lt; j) swap(F[i], F[j]); for(int k = n\u0026gt;\u0026gt;1; (j^=k) \u0026lt; k; k\u0026gt;\u0026gt;=1); } for(int step = 1; step \u0026lt; n; step \u0026lt;\u0026lt;= 1) { //may preprocess to boost \tint64_t omega = modpow(G, (MOD-1) / (step*2), MOD); if(inv) omega = modpow(omega, MOD-2, MOD); for(int i = 0; i \u0026lt; n; i += step*2) { int64_t now = 1; for(int j = 0; j \u0026lt; step; j++) { cd a = F[i+j]; cd b = F[i+j+step] * now % MOD; // reduce the use of % operator \tF[i+j] = (a+b \u0026lt; MOD ? a+b : a+b-MOD); F[i+j+step] = (a-b\u0026lt;0 ? a-b+MOD : a-b); now = now*omega%MOD; } } } if(inv) { int64_t invn = modpow(n, MOD-2, MOD); for(int i = 0; i \u0026lt; n; i++) F[i] = F[i]*invn%MOD; } }   →NTT模數表←\n中國剩餘? 一個模數合不合適取決於最後答案的大小\n兩個值域$c$、長度$n$的多項式相乘，得出來的乘積的值域最多會是$nc^2$\n如果不會超過模數的話就可以直接使用\n但如果會超過怎麼辦？\n挑選更大的模數沒什麼用，因為相乘起來可能就超過long long了\n這時我們就必須做多次NTT再用中國剩餘定理合併\n如果真實的答案不是指數或階乘那種直接爆炸的數值\n甚至還可以用來對任意數字取模(?)\nEnd FFT與NTT的利用其實滿少的，大部分不是大數乘法就是生成函數，以後有時間再放一篇講好了\n","permalink":"https://omeletwithoutegg.github.io/2019/12/25/FFT-NTT/","tags":["tutorial","FFT"],"title":"FFT-NTT"},{"contents":"!待補QQ\n質數篩與快樂的積性函數 想必大家都精通各種質數篩法，最簡單的$\\mathcal{O}(n\\sqrt{n})$就不提啦\n$n\\log n$篩 1 2 3 4 5  for(int i = 2; i \u0026lt;= n; i++) { for(int j = i*2; j \u0026lt;= n; j+=i) { sieve[j] = 1; } }   $\\sum \\frac{1}{i}$的調和級數是$\\mathcal{O}(\\log n)$量級的，故複雜度為$\\mathcal{O}(n\\log n)$\n這個寫法也可以很簡單的統計每個數字的因數個數\n1  for(int i = 1; i \u0026lt;= n; i++) for(int j = i; j \u0026lt;= n; j+=i) ++d[j];   其中 d[i] 代表 i 的因數個數\n容易發現$\\sum\\limits _ {i=1}^n d[i]$也是$\\mathcal{O}(n\\log n)$量級的\n埃式篩 1 2 3 4 5  for(int i = 2; i \u0026lt;= n; i++) if(!sieve[i] \u0026amp;\u0026amp; 1LL*i*i \u0026lt;= n) { for(int j = i*2; j \u0026lt;= n; j += i) { sieve[i] = 1; } }   所有質數的倒數和是$\\mathcal{O}(\\log\\log n)$，因此複雜度是$\\mathcal{O}(n\\log\\log n)$，而且常數頗小\n另外對所有是合數的$n$來說，$n$的最小質因數$p$都不大於$\\sqrt{n}$，因此只要從$p^2$開始篩就能保證所有合數被篩到\n線性篩 線性篩的想法是想辦法讓範圍內的合數都只被其最小質因數篩到恰好一次\n1 2 3 4 5 6 7 8 9  vector\u0026lt;int\u0026gt; primes; for(int i = 2; i \u0026lt;= n; i++) { if(!sieve[i]) primes.push_back(i); for(long long p: primes) { if(i*p \u0026gt; n) break; sieve[i*p] = 1; if(i%p == 0) break; } }   若$i \\cdot p$的最小質因數不是$p$而是$q$，則$q | i$，由code可以發現一定在更之前的迴圈就跳出了\n故這樣複雜度能夠保證是$\\mathcal{O}(n)$\n積性函數 !待補QQ\n","permalink":"https://omeletwithoutegg.github.io/2019/12/24/Sieving-Method/","tags":["WIP"],"title":"Sieving-Method"},{"contents":"Dice Wars https://tioj.ck.tp.edu.tw/problems/1726\nDescription Dice Wars是一款兼具謀略和運氣的遊戲。\n遊戲中你扮演紫色的骰子，要攻下其他顏色的骰子的城池，進而統一全地圖。\n如今你選到了一張看起來不錯的地圖: 整張地圖呈一條直線，每個位置都有一個顏色勢力佔領。\n由於每次移動到相鄰異色的城池都必須經歷一場鏖戰，你想先經過程式計算後再進行遊戲。\n你想要每次詢問一個顏色對$(S, T)$，問從任何一個$S$的城池到任一個$T$的城池至少要經過幾場戰鬥。\n如果$S$或$T$已經滅亡(地圖中沒有任何一個該勢力)，就輸出$-1$。\nSolution 題敘裡面附上的遊戲好好玩www\n題目要問的其實就是$\\min\\limits _ {c_i=S,c_j=T}(|i-j|)$\n可以想到對每種顏色開一個 vector 紀錄他們的index\n一種naive$\\mathcal{O}(nq)$的方法是每次詢問都直接把兩種顏色的兩個 vector merge $\\mathcal{O}(n)$合併並計算答案\n而另一種naive的算法則是先針對每一種顏色$\\mathcal{O}(n)$預處理其對其他顏色的答案，複雜度$\\mathcal{O}(n^2+q)$\n前者拉低複雜度的關鍵是某種顏色出現很多次\n而後者則是會因為太多種顏色而複雜度爛掉\n怎麼辦呢？可以不要全部預處理，只針對出現次數超過$k$的顏色做預處理，這些顏色的種類數不會超過$\\frac{n}{k}$種\n故預處理需要$\\mathcal{O}(\\frac{n^2}{k})$\n而對於詢問的兩個顏色的出現次數都沒有超過$k$的情況，可以直接用上面第一個算法處理\n複雜度$\\mathcal{O}(qk)$\n根據算幾不等式可取$k=\\frac{n}{\\sqrt{q}}$有複雜度$\\mathcal{O}(n\\sqrt{q})$\n註: 這題我寫的時候 ans 開原生陣列MLE，不知為何用vector陣列會是好的\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75  #include \u0026lt;bits/stdc++.h\u0026gt;#ifdef local #define debug(x) (cerr\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;) #else #define debug(x) ((void)0) #endif // local #define pb emplace_back  using namespace std; constexpr int N = 60025, K = 300, inf = 1e8; vector\u0026lt;int\u0026gt; id[N],ans[K]; int big[N],totb,n,q,v[N]; void precalc(int k) { ans[k].resize(n+1,inf); //for(int i = 1; i \u0026lt;= n; i++) ans[k][i] = inf;  int last; last = -inf; for(int i = 0; i \u0026lt; n; i++) { if(big[v[i]] == k) last = i; else ans[k][v[i]] = min(ans[k][v[i]], i - last); } last = inf; for(int i = n-1; i \u0026gt;= 0; i--) { if(big[v[i]] == k) last = i; else ans[k][v[i]] = min(ans[k][v[i]], last - i); } } signed main() { ios_base::sync_with_stdio(0), cin.tie(0); // small - small -\u0026gt; brute every time  // big - other -\u0026gt; precalc  cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; int S = 400; for(int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; v[i]; for(int i = 0; i \u0026lt; n; i++) id[v[i]].pb(i); for(int i = 1; i \u0026lt;= n; i++) if(id[i].size() \u0026gt;= S) { big[i] = ++totb; precalc(big[i]); } while(q--) { int a,b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; if(id[a].empty() || id[b].empty()) cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; else if(a == b) cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; else { if(id[a].size() \u0026lt; S \u0026amp;\u0026amp; id[b].size() \u0026lt; S) { vector\u0026lt;int\u0026gt; A = id[a]; vector\u0026lt;int\u0026gt; B = id[b]; int i = 0, j = 0, lastA = -inf, lastB = -inf, res = inf; while(i \u0026lt; A.size() || j \u0026lt; B.size()) { if(j==B.size() || (i\u0026lt;A.size() \u0026amp;\u0026amp; A[i]\u0026lt;B[j])) { int t = A[i++]; res = min(res, t - lastB); lastA = t; }else { int t = B[j++]; res = min(res, t - lastA); lastB = t; } } cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }else { if(big[a]) cout \u0026lt;\u0026lt; ans[big[a]][b] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; else cout \u0026lt;\u0026lt; ans[big[b]][a] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } } }   ","permalink":"https://omeletwithoutegg.github.io/2019/12/23/TIOJ-1726/","tags":["TIOJ","sqrt-decomposition"],"title":"TIOJ-1726"},{"contents":"新專輯 https://tioj.ck.tp.edu.tw/problems/1674\nDescription 最近你打算訂購$N^2$張水樹奈奈的專輯《極限魅惑IMPACT EXCITER》。\n由於份量實在是太多了，你決定分散成$N$份訂單。\n然而，不幸的，依據博客來新的訂貨規定，每一位顧客第$k$次下訂單所訂的CD張數必頇是$k$的正整數倍。\n換句話說，一位顧客第$5$次訂的CD張數只可能是$5$張、$10$張、$15$張、…依此類推。\n當然，原先你把$N^2$張CD分散在$N$份訂單的目的就是為了讓一張訂單中最多只會有$N$張CD。\n即使博客來多了這項奇怪的規定，你仍然不打算捨棄你的原則，只是這樣每份訂單訂的數量可能會達不到你原來的期望。\n無論如何，你還是下了訂單。為了估計你實際訂下的CD數與你期望訂下的CD數的差別，你決定把每次你少訂的數量加起來。\n可是，因為你可能少訂非常多張CD，所以你希望算出少訂的總數量除以$10^9+9$的餘數。\n也就是說，如果你總共要訂$3^2$張CD，分成三次訂的話，\n那你第一、第二、第三次分別可以訂$3$、$2$、$3$張CD，分別會少訂是$0＋1＋0＝1$張CD。\nSolution 仔細讀懂題目之後可以發現題目要求的就是\n$$\n\\sum _ {i=1}^n n\\%i\n$$\n不過$n$可以到$10^{13}$不能直接$\\mathcal{O}(n)$跑過去\n數論分塊 數論分塊的精神很簡單，不同的$\\lfloor n/i \\rfloor$數量只有$\\mathcal{O}(\\sqrt{n})$種\n說明:\n對於$i \\leq \\sqrt{n}$，最多只有$\\sqrt{n}$種不同的值\n對於$i \u0026gt; \\sqrt{n}$，$\\lfloor n/i \\rfloor \u0026lt; \\sqrt{n}$最多也只有$\\sqrt{n}$種不同的值\n怎麼快速枚舉可能的$\\lfloor n/i \\rfloor$？\n1 2 3 4 5 6  for(int i = 1,j,x; i \u0026lt;= n; i = j+1) { x = n/i; j = n/x; // j是最大的數字使得j*x \u0026lt;= n，意即[i,j]區間內正好是所有n/k=x的數字 \t// use n/i here }   回到剛剛的式子，把他改寫成\n$$\n\\sum _ {i=1}^n n - i \\cdot \\lfloor \\frac{n}{i} \\rfloor\n$$\n後面那項等價於算區間$\\sum _ {k=i}^j k \\cdot x$\n其中區間$[i,j]$是所有$\\lfloor n/k \\rfloor = x = \\lfloor n/i \\rfloor$的$k$\n小學數學算一算就可以知道這是$x \\cdot (\\frac{j(j+1)}{2} - \\frac{(i-1)i}{2})$的啦\n記得小心處理模$10^9+9$的部分，尤其因為$n$可以到$10^{13}$，兩個數字乘起來的時候都要先模一次\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  #include \u0026lt;iostream\u0026gt;using namespace std; typedef long long ll; const ll MOD = 1000000009; ll modpow(ll e, ll p) { ll r = 1; while(p) (p\u0026amp;1)\u0026amp;\u0026amp;(r=r*e%MOD), e=e*e%MOD, p\u0026gt;\u0026gt;=1; return r; } signed main() { ios_base::sync_with_stdio(0), cin.tie(0); ll n,sum = 0; cin \u0026gt;\u0026gt; n; for(ll i = 1,j; i \u0026lt;= n; i = j+1) { j = n/(n/i); ll x = (n/i)%MOD; ll sr = (j%MOD)*((j+1)%MOD)%MOD; ll sl = (i%MOD)*((i-1)%MOD)%MOD; sum = (sum + x * (sr - sl + MOD))%MOD; } ll s = (n%MOD)*(n%MOD)%MOD; cout \u0026lt;\u0026lt; (s - sum * modpow(2, MOD-2) % MOD + MOD) % MOD \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }   ","permalink":"https://omeletwithoutegg.github.io/2019/12/19/TIOJ-1674/","tags":["TIOJ","math"],"title":"TIOJ-1674"},{"contents":"通關密語 https://tioj.ck.tp.edu.tw/problems/1035\nDescription 給定兩個長度小於 $5 \\times 10^4$ 的小寫英文字母字串 $S,T$\n定義「最佳擬合」，就是將 $S$ 經過平移後和 $T$ 比對，同樣的字元數最多的那一種方法。\n請輸出一個正整數，代表最佳擬合的方案下，相同的字元有幾個。\nex.\n對於\n ababa\nbabab\n 來說，\n ababa\n=babab\n 這是一種最佳擬合的方法，$S$經過向左平移之後$S,T$有四個位置的字元相同\nSolution naive的$n^2$做法可以AC本題，只要妥當控制常數即可\n不過這裡提供一個NTT的$\\mathcal{O}(C\\cdot n\\log n)$解\n假設$S$對$T$的平移量是$x$(可以為負的)，題目所求為\n$$\n\\sum _ {i-j = x} [S_i = T_j]\n$$\n的最大值\n那我們枚舉26種英文字母，可以寫成\n$$\n\\sum _ {c \\in \\sigma} \\sum _ {i-j = x} [S_i = c] \\cdot [T_j = c]\n$$\n令$F_i = [S_i = c], G_j = [T _ {-j} = c]$\n答案便是\n$$\nR_x = \\sum _ {i+j = x} F_i G_j = F * G\n$$\n最後取$R$的最大值就好了，答案不會大於字串長度所以模數只要不要超小就不用關心答案被mod到\n每次捲積交給NTT可以$\\mathcal{O}(n\\log n)$做完\n索引值取負號可以用直接反轉字串取代，因為本題不關心偏移量$x$是多少\n另外這題用FFT好像比較快，模的常數真的有點大\n有一個常數優化是沒有出現過的字母就不需要NTT\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57  #pragma g++ optimize(\u0026#34;Ofast\u0026#34;) #pragma loop_opt(on) #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; const int64_t m = 998244353, g = 3, N = 1\u0026lt;\u0026lt;17; int rev[N]; int64_t modpow(int64_t e,int64_t p) { int64_t r = 1; while(p) (p\u0026amp;1)\u0026amp;\u0026amp;(r=r*e%m), e=e*e%m, p\u0026gt;\u0026gt;=1; return r; } void NTT(int64_t F[],int n,bool inv) { for(int i = 0, L = __lg(n); i \u0026lt; n; i++) { rev[i] = (rev[i\u0026gt;\u0026gt;1]\u0026gt;\u0026gt;1) | ((i\u0026amp;1)\u0026lt;\u0026lt;L-1); if(i \u0026lt; rev[i]) swap(F[i],F[rev[i]]); } for(int step = 1; step \u0026lt; n; step *= 2) { int64_t root = modpow(g,(m-1)/(step*2)); if(inv) root = modpow(root,m-2); for(int i = 0; i \u0026lt; n; i += step*2) { int64_t now = 1; for(int j = 0; j \u0026lt; step; j++) { int64_t a = F[i+j]; int64_t b = F[i+j+step]*now%m; F[i+j] = (a+b)%m; F[i+j+step] = (a-b+m)%m; now = now*root%m; } } } if(inv) { int64_t in = modpow(n,m-2); // inv of n  for(int i = 0; i \u0026lt; n; i++) F[i] = F[i]*in%m; } } void mul(int64_t A[],int64_t B[],int64_t C[],int n) { NTT(A,n,0); NTT(B,n,0); for(int i = 0; i \u0026lt; n; i++) C[i] = A[i]*B[i]%m; NTT(C,n,1); } int64_t A[N],B[N],C[N],ans[N]; signed main() { ios_base::sync_with_stdio(0), cin.tie(0); string s,t; cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t; int n = 1\u0026lt;\u0026lt;__lg(s.size()+t.size())+1; for(int c = 0; c \u0026lt; 26; c++) { for(int i = 0; i \u0026lt; n; i++) { A[i] = (i \u0026lt; s.size() \u0026amp;\u0026amp; s[i]-\u0026#39;a\u0026#39;==c); B[i] = (i \u0026lt; t.size() \u0026amp;\u0026amp; t[t.size()-1-i]-\u0026#39;a\u0026#39;==c); } mul(A,B,C,n); for(int i = 0; i \u0026lt; n; i++) ans[i] += C[i]; } cout \u0026lt;\u0026lt; *max_element(ans,ans+n) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }   ","permalink":"https://omeletwithoutegg.github.io/2019/12/18/TIOJ-1035/","tags":["TIOJ","FFT"],"title":"TIOJ-1035"},{"contents":"動態樹的奮鬥 為了這題的Link-Cut-Tree解我花了不只一整天XD\n壓常實在是神奇的事，把 long long 改成 int 再加上幾個 pragma 終於成功壓過唯一奇怪的那筆= =\n而且 push 竟然還不能用遞迴寫，到底三小\nLCT怎麼這麼可撥XD\n不過壓過去那筆之後其他筆的執行時間加起來超少，值得了\n註: 模板是參考日月卦長那裡的，大概不會有時間會為這篇補上解說吧，大家自己google\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123  #pragma g++ optimize(\u0026#34;Ofast\u0026#34;) #pragma loop_opt(on) #include \u0026lt;cstdio\u0026gt;#include \u0026lt;bitset\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; typedef long long ll; const int N = 100025; inline char readchar() { const static int B = 1\u0026lt;\u0026lt;20; static char buf[B], *p, *q; // p,q would be initialized with nullptr  if(p == q \u0026amp;\u0026amp; (q=(p=buf)+fread(buf,1,B,stdin)) == buf) return EOF; return *p++; } inline int nextint() { int x = 0, c = readchar(); while(\u0026#39;0\u0026#39;\u0026gt;c || c\u0026gt;\u0026#39;9\u0026#39;) c = readchar(); while(\u0026#39;0\u0026#39;\u0026lt;=c\u0026amp;\u0026amp;c\u0026lt;=\u0026#39;9\u0026#39;) x = x*10 + (c^\u0026#39;0\u0026#39;), c = readchar(); return x; } // \\sum{cnt[p] * w[p]} struct LinkCutTree { // Splay  struct node { ll ws, sum; int laz, cnt, w; int ch[2], pa; } S[N]; bool isroot(int x) { // is the root of the splay tree  return S[S[x].pa].ch[0]!=x \u0026amp;\u0026amp; S[S[x].pa].ch[1]!=x; } void add(int i, int d) { if(!i) return; S[i].laz += d; S[i].cnt += d; S[i].sum += S[i].ws * d; } void down(int i) { if(!i || !S[i].laz) return; add(S[i].ch[0],S[i].laz); add(S[i].ch[1],S[i].laz); S[i].laz = 0; } int stk[N]; void push(int i) { int p = 0; stk[p++] = i; while(!isroot(i)) stk[p++] = i = S[i].pa; while(p) down(stk[--p]); //if(!isroot(i)) push(S[i].pa);  //down(i);  } void pull(int i) { S[i].ws = S[S[i].ch[0]].ws + S[S[i].ch[1]].ws + S[i].w; S[i].sum = S[S[i].ch[0]].sum + S[S[i].ch[1]].sum + ll(S[i].cnt) * S[i].w; } void rot(int x) { int y = S[x].pa, z = S[y].pa; int d = (S[y].ch[1] == x); S[x].pa = z; if(!isroot(y)) S[z].ch[S[z].ch[1]==y] = x; S[y].ch[d] = S[x].ch[!d]; if(S[y].ch[d]) S[S[y].ch[d]].pa = y; S[x].ch[!d] = y, S[y].pa = x; pull(y), pull(x); } void splay(int x) { push(x); while(!isroot(x)) { int y = S[x].pa; if(!isroot(y)) { int z = S[y].pa; if(S[z].ch[0]==y ^ S[y].ch[0]==x) rot(x); else rot(y); } rot(x); } } // LCT  int access(int x) { int last = 0; while(x) { splay(x); S[x].ch[1] = last; pull(x); last = x; x = S[x].pa; } return last; } ll query(int v){ return S[access(v)].sum; } void modify(int v,int d) { add(access(v),d); } } LCT; bitset\u0026lt;N\u0026gt; color; ll sumd,sumc; ll dis[N]; signed main() { int n = nextint(), q = nextint(); for(int i = 1; i \u0026lt; n; i++) { int a = nextint()+1; int b = nextint()+1; int w = nextint(); //LCT.addEdge(a,b,w);  //LCT.addEdge(b,a,w);  dis[b] = dis[a] + w; LCT.S[b] = {w,0,0,0,w,0,0,a}; //LCT.pull(b);  } while(q--) { int t = nextint(); int x = nextint()+1; if(t == 2) { printf(\u0026#34;%lld\\n\u0026#34;, sumd + sumc*dis[x] - 2*LCT.query(x)); }else if(!color[x]) { color[x] = true, LCT.modify(x,1), sumc++, sumd += dis[x]; } } }   ","permalink":"https://omeletwithoutegg.github.io/2019/12/14/TIOJ-1171-LCT/","tags":["template","tree","link-cut-tree"],"title":"TIOJ-1171-LCT"},{"contents":"小向的試煉 2-3：轉！(Rotate!) https://tioj.ck.tp.edu.tw/problems/1950\nDescription 給定長度$N$的排列，問「以交換任意兩個數字的方式排序這個序列需要多少次數」\n另外有$M$次修改，每次修改會交換數字$i$和數字$j$的位置，請輸出$M+1$行代表一開始和每次修改過後的答案\nSolution 已經知道每個數字應該被放到哪裡了，所以我們可以想到一個排序方法\n每次看某個位置$i$的數字$x$，如果和$i$不同的話就把$x$放到位置$x$的地方，再繼續對原本放在位置$x$的地方的數字做同樣的事\n可以發現這樣會形成好幾個「環」，例如範測的$(1, 4, 2, 5, 3)$會形成兩個環\n$$\n\\begin{pmatrix}\n1\n\\end{pmatrix}\n\\begin{pmatrix}\n4 \u0026amp; 5 \u0026amp; 3 \u0026amp; 2\n\\end{pmatrix}\n$$\n或是$(1, 6, 4, 5, 3, 2)$會形成三個環\n$$\n\\begin{pmatrix}\n1\n\\end{pmatrix}\n\\begin{pmatrix}\n6 \u0026amp; 2\n\\end{pmatrix}\n\\begin{pmatrix}\n4 \u0026amp; 5 \u0026amp; 3\n\\end{pmatrix}\n$$\n也就是說，每個環代表第一個元素要放到第二個元素的位置，第二個元素要放到第三個元素的位置\u0026hellip;以此類推\n一個大小$L$的環需要的交換次數是$L-1$，所以把$1\\dots n$的排列排序好所需的時間就是$n-($環的個數$)$\n用數學一點的講法就是一個置換可以分解成好多不相交的輪換(?)而且方法是唯一的喔\n考慮一下交換了兩個數字會發生什麼事:\n如果他們在同一個「環」裡面，那那個環就會被切成兩個環\n反之則會讓兩個環合在一起，變成一個「環」\n示意圖大概就是這樣\n要怎麼辦到這件事呢？快速把元素之間連接或者切斷，我們會想到使用鏈結串列，但是這樣無法判斷他們是否在同一個環裡面\n退而求其次可以使用二元樹來維護，用$\\mathcal{O}(\\log n)$獲得可以剪切又可以黏貼序列的神力(?)\n我選擇用splay來實作，詳細的原理自己google OwO\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134  // __________________ // | ________________ | // || ____ || // || /\\ | || // || /__\\ | || // || / \\ |____ || // ||________________|| // |__________________| // \\###################\\ // \\###################\\ // \\ ____ \\ // \\_______\\___\\_______\\ // An AC a day keeps the doctor away.  #pragma g++ optimize(\u0026#34;Ofast\u0026#34;) #pragma loop_opt(on) #include \u0026lt;bits/extc++.h\u0026gt;#ifdef local #define debug(x) (cerr\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;) #else #define debug(x) ((void)0) #endif // local  using namespace std; typedef int64_t ll; constexpr ll N = 100025, INF = 1e18, MOD = 998244353, K = 64, inf = 1e9; struct Splay { struct node { int ch[2],pa; int lf[2]; // lf[0] is the leftmost element of this splay, lf[1] is the rightmost  } T[N]; void pull(int i){ T[i].lf[0] = T[i].ch[0] ? T[T[i].ch[0]].lf[0] : i; T[i].lf[1] = T[i].ch[1] ? T[T[i].ch[1]].lf[1] : i; } bool isroot(int x){return T[x].pa==0;} bool dir(int x){return T[T[x].pa].ch[1] == x;} void rot(int x) { int y = T[x].pa, z = T[y].pa, d = dir(x); T[x].pa = z; if(!isroot(y)) T[z].ch[dir(y)] = x; T[T[x].ch[!d]].pa = y, T[y].ch[d] = T[x].ch[!d]; T[x].ch[!d] = y, T[y].pa = x; } int splay(int x) { while(!isroot(x)) { int y = T[x].pa; if(!isroot(y)) { if(dir(x) ^ dir(y)) rot(x); else rot(y); } rot(x); } return T[x].lf[0]; //like DSU, present a tree with unique element(leftmost)  } // (A..., x, B...) -\u0026gt; (A...) + (x, B...)  int cut(int x) { splay(x); int res = T[x].ch[0]; T[T[x].ch[0]].pa = 0, T[x].ch[0] = 0, T[x].lf[0] = x; return res; } // (A..., x, B...) + (C..., y, D...) -\u0026gt; (x, B...C..., y, D...A...)  void link(int x, int y) { if(!x || !y || splay(x) == splay(y)) return; x = T[x].lf[1], y = T[y].lf[0]; splay(x), splay(y); T[y].pa = x, T[x].ch[1] = y; splay(y); } int poke(int x,int y) { if(splay(x) == splay(y)) { // (A..., x, B..., y, C...) -\u0026gt; (x, B...) + (y, C...A...)  int a = cut(x); link(x,a); cut(y); return -1; }else { // (A..., x, B...) + (C..., y, D...) -\u0026gt; (x, B...A..., y, D...C...)  int a = cut(x); int b = cut(y); link(x,a); link(y,b); link(x,y); return 1; } } void init(int n) { for(int i = 1; i \u0026lt;= n; i++) T[i].lf[0] = T[i].lf[1] = i, T[i].pa = T[i].ch[0] = T[i].ch[1] = 0; } /*void dfs(int i) { if(!i) return; dfs(T[i].ch[0]); cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; dfs(T[i].ch[1]); } void dbg(int n) { //return; cout \u0026lt;\u0026lt; \u0026#34;===\\n\u0026#34;; for(int i = 1; i \u0026lt;= n; i++) if(isroot(i)) dfs(i), cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; cout \u0026lt;\u0026lt; \u0026#34;===\\n\\n\u0026#34;; }*/ } cycles; int n,q,v[N],vis[N],pos[N],ans; signed main() { ios_base::sync_with_stdio(0), cin.tie(0); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; cycles.init(n); for(int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; v[i], pos[v[i]] = i; for(int i = 1; i \u0026lt;= n; i++) if(!vis[i]) { int last = 0; for(int x = i; !vis[x]; x = pos[x]) { if(last) ans += cycles.poke(v[last],v[x]); vis[x] = 1; last = x; } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; //tr.dbg(n);  //return 0;  while(q--) { int a,b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; ans += cycles.poke(a,b); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; //tr.dbg(n);  } }   ","permalink":"https://omeletwithoutegg.github.io/2019/12/13/TIOJ-1950/","tags":["TIOJ","binary-tree","splay-tree"],"title":"TIOJ-1950"},{"contents":"黑色騎士團的逆襲野望 https://tioj.ck.tp.edu.tw/problems/1394\nDescription 自從黑色騎士團上次的最終野望被白色騎士豬殺苦破滅之後，黑色騎士團銷聲滅跡了一陣子，不過他們仍繼續計畫著侵略神聖的大不列顛帝國。\n終於他們發現了一個機會：原來大不列顛帝國的命脈就是對外輸出的藥品\u0026quot;REBRAIN\u0026quot;，只要能控制住它所有的運輸與加工途徑，那大不列顛帝國就完了！\n與之前一樣，他們只要佔領一個據點就可以控制與他相鄰的運輸途徑了！\n\u0026ldquo;REBRAIN\u0026quot;的運輸過程十分有趣，他有一個總工廠來製造\u0026quot;REBRAIN\u0026quot;的一些半成品，再依序經過幾個有向道路到下個加工地點進行加工，就這樣一直到完成成品，並且為了不讓產品流程出問題，他們的運輸路徑不會出現環狀或逆向的情況。\n不過黑色騎士團的人手有限，所以他們希望佔據最少的據點就可以完全控制整個運輸與加工途徑。\n註: 雖然是有向邊，不過相鄰的關係依然是互相的；另外雖然沒有講的很清楚，題目是有保證0號節點可以走到所有其他節點\nSolution 題目所求是最小點覆蓋，也就是在給定圖上要選幾個點才能保證所有邊都有一個端點被選到\n因為這題給的是DAG，所以我們可以考慮用DP的方式做\n狀態$dp[i][s]$代表$i$往子孫走的邊都已經保證有端點被選到的答案，若$s=1$代表有選$i$這個點，反之沒有\n可以知道如果沒有選$i$這個點，那他的子節點都一定要選，所以\n$$dp[i][0] = \\sum\\limits _ {j\\in son(i)} dp[j][1]$$\n如果選了$i$這個點，那他的子節點可選可不選，我們就取比較小的那個，有\n$$dp[i][1] = 1 + \\sum\\limits _ {j\\in son(i)} \\min(dp[j][0],dp[j][1])$$\n最後取的答案是0號節點選或不選取$\\min$\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; const int N = 33001; int dp[N][2], vis[N]; vector\u0026lt;int\u0026gt; g[N]; void dfs(int i) { if(vis[i]) return; vis[i] = true; dp[i][0] = 0; dp[i][1] = 1; for(int j:g[i]) { dfs(j); dp[i][0] += dp[j][1]; dp[i][1] += min(dp[j][0],dp[j][1]); } } signed main() { ios_base::sync_with_stdio(0), cin.tie(0); int n,k; cin \u0026gt;\u0026gt; n; for(int i = 0,k; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; k; g[i].resize(k); for(int \u0026amp;j:g[i]) cin \u0026gt;\u0026gt; j; } dfs(0); cout \u0026lt;\u0026lt; min(dp[0][0], dp[0][1]) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }   ","permalink":"https://omeletwithoutegg.github.io/2019/12/13/TIOJ-1394/","tags":["TIOJ","dp","DAG"],"title":"TIOJ-1394"},{"contents":"[APIO \u0026lsquo;08] Beads [Interactive] https://tioj.ck.tp.edu.tw/problems/1739\nDescription 有一個長度$n$的序列$a$，一開始$a_i = i$\n接下來有$m$個操作，每個操作只會交換相鄰的兩個數字\n接著有$q$個詢問，每次會詢問：第$t$個操作之後，數字$x$被放到哪個位置？\n$n,m,q \\leq 3 \\times 10^5; 1 \\leq x \\leq n; 1 \\leq t \\leq m$\nSolution 對序列保存不同的版本，當然持久化資料結構砸下去就對啦\n是說本來想寫treap不過我實作能力好差QQ\n什麼？你想問什麼是持久化？\n反正就是用樹來存一個序列啦，然後因為改一個數字時只要改他到根的那條鏈就好了啦，這樣每次修改新增的點數會和樹高一樣\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85  // __________________ // | ________________ | // || ____ || // || /\\ | || // || /__\\ | || // || / \\ |____ || // ||________________|| // |__________________| // \\###################\\ // \\###################\\ // \\ ____ \\ // \\_______\\___\\_______\\ // An AC a day keeps the doctor away.  #pragma g++ optimize(\u0026#34;Ofast\u0026#34;) #pragma loop_opt(on) #include \u0026lt;bits/stdc++.h\u0026gt;#ifdef local #define debug(x) (cerr\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;) #else #define debug(x) ((void)0) #endif // local  using namespace std; typedef int64_t ll; constexpr ll N = 300025, K = 64; #include \u0026#34;lib1739.h\u0026#34; struct segtree { struct node { int l,r,val; } S[N*K]; int tot; int newnode(int v) { return S[++tot] = {0,0,v}, tot; } int newnode(int l,int r) { return S[++tot] = {l,r,0}, tot; } int build(int l, int r) { if(l+1 == r) return newnode(l); int m = l+(r-l\u0026gt;\u0026gt;1); return newnode(build(l,m),build(m,r)); } int modify(int root, int p, int k, int l, int r) { if(l+1 == r) return newnode(k); int m = l+(r-l\u0026gt;\u0026gt;1); if(p \u0026lt; m) return newnode(modify(S[root].l,p,k,l,m), S[root].r); else return newnode(S[root].l, modify(S[root].r,p,k,m,r)); } int query(int root, int p, int l, int r) { while(l+1 \u0026lt; r) { int m = l+(r-l\u0026gt;\u0026gt;1); if(p \u0026lt; m) r = m, root = S[root].l; else l = m, root = S[root].r; } return S[root].val; } } sgt; int n,m; int root[N],chg[N],v[N],pos[N]; void init() { root[0] = sgt.build(1,n+1); for(int i = 1; i \u0026lt;= n; i++) v[i] = pos[i] = i; for(int i = 1; i \u0026lt;= m; i++) { int a = chg[i], b = chg[i]+1; int r = sgt.modify(root[i-1],v[a],pos[v[b]],1,n+1); root[i] = sgt.modify(r,v[b],pos[v[a]],1,n+1); swap(pos[v[a]], pos[v[b]]); swap(v[a], v[b]); } } signed main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for(int i = 1; i \u0026lt;= m; i++) scanf(\u0026#34;%d\u0026#34;, chg+i); init(); int q = getNumQuestions(); while(q--) { int A,B; getQuestion(A, B); answer(sgt.query(root[B],A,1,n+1)); } }   ","permalink":"https://omeletwithoutegg.github.io/2019/12/11/TIOJ-1739/","tags":["TIOJ","data-structure"],"title":"TIOJ-1739"},{"contents":"小向的試煉 2-1：洞穴(Cave) https://tioj.ck.tp.edu.tw/problems/1948\nDescription 小向在洞穴裡偵察到了$N$個烏龍，不知道是本尊還是分身。不過他們在洞穴中都是以每秒1公分的速度前進，只是有的朝著左邊的入口前進，而有的朝著右邊的入口前進。而由於洞穴相當狹窄，兩個相向的烏龍相撞時會回頭。小向大膽猜測，本尊一定會在所有分身都出洞穴被小向打敗後才出洞穴，瞄準小向用盡魔力的那剎那攻擊小向。不過她也沒那麼多時間等所有分身慢慢走出來再找到本尊，所以小向希望能直接用她剛剛偵察到的資訊判斷哪個是本尊。($N\\leq10^6$，洞穴的長度$L\\leq10^9$)\n注意：離開洞穴的定義是從左邊的入口往左走一步或從右邊的入口往右走一步。保證答案唯一，並且所有烏龍都在不同位置。\nSolution 首先若不管烏龍的編號，只想知道烏龍最後的位置，兩個烏龍相撞並回頭時可以當作穿過去\n顯然地，我們可以知道所有烏龍最晚離開洞穴的時刻，就等於每隻烏龍單獨放在洞穴內離開洞穴的時刻的最大值，我們也能知道最後一隻離開洞穴的烏龍是向左還是向右\n接著可以發現在烏龍相撞的過程中，左右順序一定不會變，意思是如果某個編號$i$的烏龍一開始是x座標第$k$大的，那不管經過多少次的相撞，他仍然會是x座標第$k$大的\n同時向左的烏龍數量與向右的烏龍數量也不會變\n所以，我們可以知道最後一隻烏龍離開洞穴時，一定是左邊全部向左，右邊全部向右，而那隻最後離開的烏龍一定是「向左的烏龍中最右邊的或者向右的烏龍中最左邊的」，也就知道了最後離開的烏龍是x座標第幾大的了\n用 nth_element 可以快速找出x座標第$k$大的編號，注意一開始他給的編號沒有按照x座標排序，上述推論必須先照x座標排序才會是對的= =\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  #pragma g++ optimize(\u0026#34;Ofast\u0026#34;) #pragma loop_opt(on) #include \u0026lt;cstdio\u0026gt;#include \u0026lt;algorithm\u0026gt;const int N = 1000001; int n,L,x[N],id[N],cnt; signed main() { int t = -1e9, dir, pos; scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;n,\u0026amp;L); for(int i = 0,d; i \u0026lt; n; i++) { scanf(\u0026#34;%d%d\u0026#34;,x+i,\u0026amp;d); int dis = d ? L-x[i] : x[i]; if(t \u0026lt; dis) t = dis, dir = d; if(!d) cnt++; } pos = cnt+dir-1; for(int i = 0; i \u0026lt; n; i++) id[i] = i; std::nth_element(id,id+pos,id+n,[](int a,int b){return x[a]\u0026lt;x[b];}); printf(\u0026#34;%d\\n\u0026#34;, id[pos]); }   ","permalink":"https://omeletwithoutegg.github.io/2019/12/11/TIOJ-1948/","tags":["TIOJ","math"],"title":"TIOJ-1948"},{"contents":"迭代式線段樹 先備知識: 線段樹(帶懶標) + 位元運算(吧)\n如果讀者還不知道線段樹的原理最好看遞迴的(?)\n單點修改 例題仍然是萬年RMQ\n 給定一個長度$n$的序列，請支援以下操作\n 將位置$p$的值改為$x$ 查詢區間$[l,r)$的最大值   完美二元樹 首先假定$n$是2的冪次，思考可能可以簡單一些\n我們一樣用1當根，並且節點i的左右子樹會是i*2和i*2+1或寫成i\u0026lt;\u0026lt;1, i\u0026lt;\u0026lt;1|1\n1 2  const int N = 1\u0026lt;\u0026lt;18; int tr[N\u0026lt;\u0026lt;1], n;   對於初始化來說，可以發現葉子節點對應的都是長度$1$的區間，正好是原序列的值，所以可以直接讀入或另外傳入賦值給 tr[i+n]，接著可以用遞減的順序把其他長度的區間的答案算好\n1 2 3 4  void build(int v[]) { for(int i = 0; i \u0026lt; n; i++) tr[i+n] = v[i]; for(int i = n-1; i \u0026gt; 0; i--) tr[i] = max(tr[i\u0026lt;\u0026lt;1], tr[i\u0026lt;\u0026lt;1|1]); }   更新一個節點$p$，那麼只有$p$的所有祖先的答案會被影響到\n注意 p^1 代表 p 的兄弟節點，也就是 p 父親的另一個兒子\n1 2 3 4  void modify(int p, int x) { for(tr[p+=n] = x; p \u0026gt; 1; p\u0026gt;\u0026gt;=1) tr[p\u0026gt;\u0026gt;1] = max(tr[p],tr[p^1]); }   至於區間的查詢就沒有那麼顯然了，我們一樣必須把詢問的區間拆分成線段樹上的一些區間，而且數量不能超過$\\mathcal{O}(\\log n)$\n事實上，每一層我們至多只會拿前後兩個節點，並且拿完了之後就把左界增加或右界減少，越往上待選節點所代表區間會越短\n如果採用左閉右開的話規則可以歸納如下:\n 首先 l+=n, r+=n 從最下面那層開始 重複執行直到區間為空(l\u0026gt;=r)  如果 l 是他父親的右子樹，則必須取走編號 l 的節點，並將 l 在該層往右一格 如果 r-1 是他父親的左子樹，則必須取走編號 r-1 的節點，並將 r 在該層往左一格 把 l,r 都往上提升一層    1 2 3 4 5 6 7 8  int query(int l, int r) { // [l,r)  int res = -1e9; for(l+=n,r+=n; l\u0026lt;r; l\u0026gt;\u0026gt;=1,r\u0026gt;\u0026gt;=1) { if(l\u0026amp;1) res = max(res, tr[l++]); if(r\u0026amp;1) res = max(res, tr[--r]); } return res; }   嗯\u0026hellip;如果看不懂的話也可以接受這就是把$[l,r)$區間拆成線段樹上$2\\log n$個節點就好\n和那些噁心的遞迴參數say goodbye吧! \\迭代式線段樹/\n如果n不是2的冪次? 如果題目需要的運算有單位元素的話，可以在後面補上單位元素直到n是2的冪次\n不過令人意外的是， 上面的程式碼對任意的n都正確!\n讓我們來看看 n = 13 的例子\n現在它不是一棵完美二元樹了，而是很多棵: 以 2 為根高度4的、以 13 為根高度1的、以 7 為根高度2的\n畫上底線的節點在 query 的時候不會被動到，所以實際上它們是什麼值都沒有差\nn不是2的冪次的時候這個演算法仍然正確的原因，可能是它可以被證明和另一個更大二元樹同構吧，不過我也不會證明所以請讀者自己參透(X)\n不把n提高到2的冪次，除了讓程式碼更好看之外，空間使用量也從 $4n$ 減少到了 $2n$\n不過同時也有一些缺點，例如不好在線段樹上二分搜，沒有 1 號節點代表全域的答案等等(如果沒有交換律)\n不遵守交換律的區間查詢? 其實這很容易解決，直接上code\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  node query(int l, int r) { node resl, resr; // initialized as identity  for(l+=n,r+=n; l\u0026lt;r; l\u0026gt;\u0026gt;=1,r\u0026gt;\u0026gt;=1) { if(l\u0026amp;1) resl = combine(resl, tr[l++]); if(r\u0026amp;1) resr = combine(tr[--r], resr); } return combine(resl, resr); } void pull(int p) { while(p \u0026gt; 1) { p \u0026gt;\u0026gt;= 1; tr[p] = combine(tr[p\u0026lt;\u0026lt;1],tr[p\u0026lt;\u0026lt;1|1]) tr[p] = applyTag(tr[p], tag[p]); } }   畢竟區間 query 的原理就是拿每一層前後的區間，所以只要對前後分開存就好了\n應王勻的要求把 pull 也補上，因為沒有交換律的時候不能用 combine(tr[p], tr[p^1]) @@\n什麼? 你問我沒有結合律怎麼辦?\n一個小常識是線段樹必須滿足結合律才能使用\u0026hellip;\u0026hellip;\n迭代型線段樹 with 懶標 進到了大家最需要，也是最常寫爛的部分了owo\nzkw自己似乎是喜歡差分、懶標永久化之類的寫法，不過太精妙了先不解釋XD\n現在題目的單點修改操作變成了區間修改\n  把區間$[l,r)$的數字都增加$x$   首先我們需要額外的陣列代表懶標，而其長度只需要n，因為葉子節點不需再往下傳遞懶標\n1  int tag[N];   Helper Methods 區間修改時，我們就在存取到的那些節點的答案和懶標都加上$x$，因此有了\n1 2 3 4  void upd(int p, int x) { tr[p] += x; if(p \u0026lt; n) tag[p] += x; }   再看一次這張圖，可以想像有兩條分別通過 l 和 r-1 的垂直線，這條線通過的節點是懶標會影響到目前區間答案的節點，所以必須把懶標往下傳\n順序要由上而下，把 p 的祖先節點的懶標往下推\n細節請看code\n1 2 3 4 5 6 7 8 9  void push(int p) { for(int h = __lg(n); h \u0026gt;= 0; h--) { int i = p\u0026gt;\u0026gt;h; // hth ancestor of p  if(!tag[i\u0026gt;\u0026gt;1]) continue; upd(i, tag[i\u0026gt;\u0026gt;1]); upd(i^1, tag[i\u0026gt;\u0026gt;1]); tag[i\u0026gt;\u0026gt;1] = 0; } }   另外修改之後也同樣需要對 l 和 r-1 的祖先 pull ，順序要由下而上\n1 2 3 4 5 6 7  void pull(int p) { while(p \u0026gt; 1) { // do not forget the tag[p\u0026gt;\u0026gt;1] term  tr[p\u0026gt;\u0026gt;1] = max(tr[p],tr[p^1])+tag[p\u0026gt;\u0026gt;1]; p \u0026gt;\u0026gt;= 1; } }   Lazy Propagation! 寫好這兩個函式後，區間修改就不是難事啦\n別忘了:\n query 前要 push modify 前要 push ， modify 後要 pull  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  int query(int l,int r) { push(l+n), push(r-1+n); int res = -1e9; for(l+=n,r+=n; l\u0026lt;r; l\u0026gt;\u0026gt;=1,r\u0026gt;\u0026gt;=1) { if(l\u0026amp;1) res = max(res, tr[l++]); if(r\u0026amp;1) res = max(res, tr[--r]); } return res; } void modify(int l,int r, int d) { int tl = l, tr = r; push(l+n), push(r-1+n); for(l+=n,r+=n; l\u0026lt;r; l\u0026gt;\u0026gt;=1,r\u0026gt;\u0026gt;=1) { if(l\u0026amp;1) upd(l++, d); if(r\u0026amp;1) upd(--r, d); } // uses tl,tr here for l,r changed  pull(tl+n), pull(tr-1+n); }   全都是同一個框架，實在是舒服啊!\n除非時間先後順序會影響到所需的運算，例如同時有乘值和加值兩種操作，否則 modify 前可以不用 push\n區間和 有人可能想到了，有些懶標操作需要區間長度，例如區間加值區間和，怎麼辦呢?\n所有節點代表的區間長度都是2的冪次，也和它與葉子的距離有關\n只需修改一下便可\n以下順便附上完整的區間加值區間和的程式碼，以筆者習慣的風格撰寫\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  const int N = 200000; struct segtree { long long sum[N\u0026lt;\u0026lt;1], tag[N], n; void upd(int p, long long d, int h) { sum[p] += d\u0026lt;\u0026lt;h; if(p \u0026lt; n) tag[p] += d; } void pull(int p) { for(int h=1; p\u0026gt;1; p\u0026gt;\u0026gt;=1, h++) sum[p\u0026gt;\u0026gt;1] = sum[p^1]+sum[p] + (tag[p\u0026gt;\u0026gt;1]\u0026lt;\u0026lt;h); } void push(int p) { for(int h = __lg(n); h \u0026gt;= 0; h--) { int i = p\u0026gt;\u0026gt;h; if(!tag[i\u0026gt;\u0026gt;1]) continue; upd(i,tag[i\u0026gt;\u0026gt;1],h); upd(i^1,tag[i\u0026gt;\u0026gt;1],h); tag[i\u0026gt;\u0026gt;1] = 0; } } void add(int l,int r,long long k) { int tl = l, tr = r, h = 0; push(l+n), push(r-1+n); for(l+=n, r+=n; l\u0026lt;r; l\u0026gt;\u0026gt;=1, r\u0026gt;\u0026gt;=1, h++) { if(l\u0026amp;1) upd(l++,k,h); if(r\u0026amp;1) upd(--r,k,h); } pull(tl+n), pull(tr-1+n); } long long query(int l,int r) { // [l,r)  long long res = 0; push(l+n), push(r-1+n); for(l+=n, r+=n; l\u0026lt;r; l\u0026gt;\u0026gt;=1, r\u0026gt;\u0026gt;=1) { if(l\u0026amp;1) res += sum[l++]; if(r\u0026amp;1) res += sum[--r]; } return res; } void init(long long v[],int _n) { n = _n; for(int i = 0; i \u0026lt; n; i++) sum[i+n] = v[i]; for(int i = n-1; i \u0026gt; 0; i--) sum[i] = sum[i\u0026lt;\u0026lt;1]+sum[i\u0026lt;\u0026lt;1|1]; } } sgt;   參考資料 https://codeforces.com/blog/entry/18051\n寫這篇好久ㄛ，本來想寫全國模擬賽的題解，不過既然學長都給了我還是算了吧(汗)\n","permalink":"https://omeletwithoutegg.github.io/2019/12/07/Iterative-SegmentTree/","tags":["template","tutorial","data-structure"],"title":"Iterative-SegmentTree"},{"contents":"B.廢文大資料 mining https://tioj.ck.tp.edu.tw/problems/2017\nDescription 給定一個序列 $a_i$ ，問有多少區間 $[l,r]$ 使得存在一個 $m \\leq r$ 滿足 $\\sum\\limits _ {i=l}^m a_i \u0026lt; 0$？\nSolution 先對 $a_i$ 做前綴 $s_k = \\sum\\limits _ {i=1}^k a_i$\n對於一個固定的 $l$ 來說，題目等價於找到一個最小的 $m$ 使得 $s_m - s _ {l-1} \u0026lt; 0$\n在 $m$ 之後的 $r$ 都會被算在答案裡面\n可以用單調隊列幫每個 $i$ 找到最小的 $i'$ 使得 $s _ {i'} \u0026lt; s_i$ ，複雜度 $\\mathcal{O}(n)$\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; const int N = 1000025; long long n,a[N],stk[N],p,R[N]; signed main() { ios_base::sync_with_stdio(0), cin.tie(0); cin \u0026gt;\u0026gt; n; for(int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; for(int i = 1; i \u0026lt;= n; i++) a[i] += a[i-1]; //for(int i = 0; i \u0026lt;= n; i++) cout \u0026lt;\u0026lt; v[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;  long long sum = 0; for(int i = n; i \u0026gt;= 0; i--) { while(p \u0026amp;\u0026amp; a[stk[p-1]] \u0026gt;= a[i]) --p; R[i] = (p ? stk[p-1]-1 : n) - i; stk[p++] = i; } for(int i = 0; i \u0026lt; n; i++) sum += R[i]; cout \u0026lt;\u0026lt; n*(n+1)/2 - sum \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }   ","permalink":"https://omeletwithoutegg.github.io/2019/12/06/TIOJ-2017/","tags":["TIOJ","monotone-queue"],"title":"TIOJ-2017"},{"contents":"販賣機耶 https://tioj.ck.tp.edu.tw/problems/1614\nDescription 蝴蝶在路旁玩壞一台販賣機，它一次只能投一枚硬幣（故障？）。\n重點是：投進一枚x元的硬幣，然後按退幣鈕，居然會吐出一枚價值 $f(x)$ 的硬幣耶！\n更神秘的是，天才蝴蝶已經發現 $f(x) = x + (x-b_1) (x-b_2) (x-b_3) \\dots (x-b_m)$。\n現在蝴蝶手上有 $n$ 枚硬幣，分別是 $a_1 \\dots a_n$，請問蝴蝶投進去會賺的硬幣有幾枚？\nSolution 題目就是問$f(x)-x = \\prod\\limits _ {i=1}^m (x-b_i)$是不是正的\n然後看有幾個$b_i$小於$x$就可以知道乘積的正負號了(國中數學??)\n另外注意$x - b_i = 0$的case，然後也不要亂 unique ，要保持個數的奇偶性。\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; const int N = 100025; int n,m,a[N],b[N]; signed main() { ios_base::sync_with_stdio(0), cin.tie(0); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for(int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; for(int i = 0; i \u0026lt; m; i++) cin \u0026gt;\u0026gt; b[i]; sort(b,b+m); int ans = 0; for(int i = 0; i \u0026lt; n; i++) { int j = lower_bound(b,b+m,a[i]) - b; if(!(a[i] == b[j] || (j\u0026amp;1))) ans++; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }   ","permalink":"https://omeletwithoutegg.github.io/2019/12/06/TIOJ-1614/","tags":["TIOJ","math"],"title":"TIOJ-1614"},{"contents":"常用的輸入(出)優化 cin / cout 因為C++ template的性質，不同變數型別的輸出方式都大同小異，算是實用\n競程的時候記得開下面兩個東西\n1  ios_base::sync_with_stdio(0), cin.tie(0);   開了之後就不要使用 stdio 裡面的東西啦\n另外若非互動題也不要使用 endl 之類會flush的函式，請用 '\\n' 代替\nscanf / printf 常用的也就那些\n1 2 3 4 5 6 7 8 9 10 11  #include \u0026lt;cstdio\u0026gt;int main() { int x,y; long long L; scanf(\u0026#34;%d%d%lld\u0026#34;, \u0026amp;x, \u0026amp;y, \u0026amp;L); printf(\u0026#34;%lld\\n\u0026#34;, x+y+L); char s[100]; scanf(\u0026#34;%s\u0026#34;, s); for(int i = 0; s[i]; i++) s[i] = (s[i]-\u0026#39;a\u0026#39;+1)%26+\u0026#39;a\u0026#39;; printf(\u0026#34;%s\\n\u0026#34;, s); }   值得注意的是 iostream 的空間有點大，所以想要壓空間用 stdio 就對了\n另外 printf 格式化輸出也常常會在毒瘤題派上用場XD，例如TIOJ 1845\ngetchar scanf 和 cin 都判了很多case(的感覺)\n對於競賽中固定的輸入格式，自己用 getchar() 一個一個字元讀比較快\n1 2 3 4 5 6 7 8 9  #include \u0026lt;cstdio\u0026gt;inline int nextint() { int x = 0, c = getchar(), neg = false; while((\u0026#39;0\u0026#39; \u0026gt; c || c \u0026gt; \u0026#39;9\u0026#39;) \u0026amp;\u0026amp; c!=\u0026#39;-\u0026#39; \u0026amp;\u0026amp; c!=EOF) c = getchar(); if(c == \u0026#39;-\u0026#39;) neg = true, c = getchar(); while(\u0026#39;0\u0026#39; \u0026lt;= c \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;9\u0026#39;) x = x*10 + (c^\u0026#39;0\u0026#39;), c = getchar(); if(neg) x = -x; return x; // returns 0 if EOF }   要印出數字用 printf 就好，如果必須輸出很多可以先存到陣列最後再一起印出，輸出似乎不常成為瓶頸。\nfread 快! 還要更快! 如果輸入非常多的時候，我們可以把getchar改成\n1 2 3 4 5 6  inline char readchar() { const int S = 1\u0026lt;\u0026lt;20; // buffer size \tstatic char buf[S], *p = buf, *q = buf; if(p == q \u0026amp;\u0026amp; (q = (p=buf)+fread(buf,1,S,stdin)) == buf) return EOF; return *p++; }   原理可能是自己實現緩衝區，對檔案的讀寫一次做多一點會比較快吧\n這個超有感， 1e7 左右的輸入只要不到50ms，有夠扯，例如TIOJ 1093\nunlocked 有些可以在後綴加上unlocked加速的樣子，可是我常常感覺不到有快多少(?)\ngetchar() -\u0026gt; getchar_unlocked() putchar() -\u0026gt; putchar_unlocked() fread() -\u0026gt; fread_unlocked() ","permalink":"https://omeletwithoutegg.github.io/2019/12/06/Fast-IO/","tags":["template","tutorial","fread"],"title":"Fast-IO"},{"contents":"同步(Sync) https://tioj.ck.tp.edu.tw/problems/1927\nDescription 在一個多人單向卷軸遊戲中，有$N \\leq 10^5$個格子，每個格子都有一個不超過$10^9 + 6$的正整數，代表該格的狀況。\n有時遊戲中的兩人會產生「同步」的現象。產生同步的條件是兩人所在的格子的數字$a,b$分別滿足\n$$\n(ab)^{\\frac{p-1}{2}} \\equiv 1 \\pmod p\n$$\n其中$p = 10^9 + 7$。產生同步後，兩人會瞬移至下一格。如果在下一格又產生「同步」，則會繼續往下走，直到其中一人超出格子範圍(到了終點了)或者兩人不再同步。\nSolution 對於$x \\not\\equiv 0 \\pmod p$，$y = x^{\\frac{p-1}{2}} \\equiv \\pm 1 \\pmod p$\n因為$y$是$1$的平方根(?)\n然後$(ab)^{\\frac{p-1}{2}} \\equiv a^{(\\frac{p-1}{2})} b^{(\\frac{p-1}{2})}$\n所以可先把所有值先$(p-1)/2$次方，一定會是$\\pm 1$，接著他們同步的條件就可以簡化成$a = b$了\n考慮到同步必須要是連續的性質，我們聯想到字串演算法中的後綴陣列，這題等價求兩個後綴的LCP，完全是SA的形狀XDD\nSA + RMQ資結收工\n注意查詢兩個同樣位置的情況，RMQ會查到空區間，不過我們知道這時候的答案顯然就是到尾巴的長度\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106  // __________________ // | ________________ | // || ____ || // || /\\ | || // || /__\\ | || // || / \\ |____ || // ||________________|| // |__________________| // \\###################\\ // \\###################\\ // \\ ____ \\ // \\_______\\___\\_______\\ // An AC a day keeps the doctor away.  #pragma g++ optimize(\u0026#34;Ofast\u0026#34;) #pragma loop_opt(on) #include \u0026lt;bits/extc++.h\u0026gt;#ifdef local #define debug(x) (cerr\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;) #else #define debug(x) ((void)0) #endif // local  using namespace std; typedef int64_t ll; constexpr ll N = 100025, INF = 1e18, MOD = 1000000007, K = 256, inf = 1e9; ll modpow(ll e,ll p,ll m=MOD) { ll r=1; while(p) (p\u0026amp;1)\u0026amp;\u0026amp;(r=r*e%m), e=e*e%m, p\u0026gt;\u0026gt;=1; return r; } template\u0026lt;typename T\u0026gt; struct SuffixArray { int sa[N],rk[N],tmp[N],lcp[N]; void init(T v[],int n) { for(int i = 0; i \u0026lt; n; i++) rk[i] = v[i]; iota(sa,sa+n,0); for(int L = 1; L \u0026lt; n; L*=2) { auto cmp = [\u0026amp;](int a,int b) { if(rk[a]!=rk[b]) return rk[a]\u0026lt;rk[b]; int ra = (a+L\u0026lt;n ? rk[a+L] : -1); int rb = (b+L\u0026lt;n ? rk[b+L] : -1); return ra\u0026lt;rb; }; sort(sa,sa+n,cmp); tmp[sa[0]] = 0; for(int i = 1; i \u0026lt; n; i++) tmp[sa[i]] = tmp[sa[i-1]] + cmp(sa[i-1],sa[i]); for(int i = 0; i \u0026lt; n; i++) rk[i] = tmp[i]; } /* for(int i = 0; i \u0026lt; n; i++) { for(int j = sa[i]; j \u0026lt; n; j++) cout \u0026lt;\u0026lt; v[j] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } */ lcp[n-1] = inf; for(int i = 0, h = 0; i \u0026lt; n; i++) { if(!rk[i]) continue; if(h \u0026gt; 0) --h; int j = sa[rk[i]-1]; while(i+h\u0026lt;n \u0026amp;\u0026amp; j+h\u0026lt;n \u0026amp;\u0026amp; v[i+h]==v[j+h]) ++h; lcp[rk[i]-1] = h; } //for(int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; lcp[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;;  } }; SuffixArray\u0026lt;int\u0026gt; SA; struct SegmentTree { int mn[N\u0026lt;\u0026lt;1],n; void init(int v[],int _n) { n = _n; for(int i = 0; i \u0026lt; n; i++) mn[i+n] = v[i]; for(int i = n-1; i \u0026gt; 0; i--) mn[i] = min(mn[i\u0026lt;\u0026lt;1], mn[i\u0026lt;\u0026lt;1|1]); } int query(int l,int r) { //cout \u0026lt;\u0026lt; \u0026#34;qry: \u0026#34;;  //for(int i = l; i \u0026lt; r; i++) cout \u0026lt;\u0026lt; mn[i+n] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;  int res = inf; for(l+=n,r+=n; l\u0026lt;r; l\u0026gt;\u0026gt;=1,r\u0026gt;\u0026gt;=1) { if(l\u0026amp;1) res = min(res, mn[l++]); if(r\u0026amp;1) res = min(res, mn[--r]); } return res; } } RMQ; int n,q,v[N]; signed main() { ios_base::sync_with_stdio(0), cin.tie(0); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; for(int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; v[i]; for(int i = 0; i \u0026lt; n; i++) v[i] = modpow(v[i], (MOD-1)/2); SA.init(v,n); RMQ.init(SA.lcp,n); for(int i = 0,a,b; i \u0026lt; q; i++) { cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; if(a == b) cout \u0026lt;\u0026lt; n-a \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; else { int l = SA.rk[a], r = SA.rk[b]; if(l \u0026gt; r) swap(l,r); cout \u0026lt;\u0026lt; RMQ.query(l,r) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } }   ","permalink":"https://omeletwithoutegg.github.io/2019/12/06/TIOJ-1927/","tags":["TIOJ","suffix-array","string","math"],"title":"TIOJ-1927"},{"contents":"Ch3. Section 9. 妁艷的頭髮 https://tioj.ck.tp.edu.tw/problems/1774\nSolution 裸背包，被值域嚇到XD\n不過實際上魔力M只會到2000所以沒差的啦\nAC code 1 2 3 4 5 6 7 8 9 10 11 12  #include \u0026lt;iostream\u0026gt;using namespace std; long long n,M,dp[2001]; signed main() { ios_base::sync_with_stdio(0), cin.tie(0); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; M; for(int i = 0,h,c; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; h \u0026gt;\u0026gt; c; for(int j = c; j \u0026lt;= M; j++) dp[j] = max(dp[j-c]+h, dp[j]); } cout \u0026lt;\u0026lt; dp[M] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }   ","permalink":"https://omeletwithoutegg.github.io/2019/12/05/TIOJ-1774/","tags":["TIOJ","dp"],"title":"TIOJ-1774"},{"contents":"D.番茄大戰爭 https://tioj.ck.tp.edu.tw/problems/2019\nDescription 兩個人在玩剪刀石頭布，而他們兩個人玩了$T$個回合。兩個人（此處稱為小奕和小安）各自有一個「策略」，分別為兩個字串$A$和$B$。兩個字串皆由R、P、S三個字元組成，分別代表小奕和小安會出石頭、布、剪刀。兩個人都會根據他們的「策略」出題，在第$i$個回合，小奕將會出$A _ {i \\mod {|A|}}$，而小安將出$B _ {i \\mod{|B|}}$，從$i = 0$開始。請輸出：經過$T$個回合後，兩人分別贏了幾局，平手了幾局。\n保證滿足：$1 \\leq T \\leq 10^9$，$1 \\leq |A|, |B| \\leq 10^6$，且$A, B$由R、P、S三個字元組成。\nSolution 首先，看到$1 \\leq T \\leq 10^9$當然想說直接給他寫個$\\mathcal{O}(T)$，寫了五分鐘之後傳上去——AC——了前幾筆，之後就TLE了。所以，當然就來想怪做法嘍！\n先假設$|A| \\leq |B|$。第一個想法就是，對於$A$裏頭的每一個字元$A_i$，我都看一次我會遇到哪些字元（$B_i, B _ {i + |A|}, B _ {i + 2\\times|A|}, \\dots$，也就是所有滿足$(i + k|A|) \\mod{|B|} \\leq T$的$B _ {(i + k|A|)\\mod{|B|}}$，然後再$\\mathcal{O}(1)$更新答案。這樣複雜度依然為$\\mathcal{O}(T)$，因為還是每一個時間點都有戳到一次，只是改變順序而已了。不過！這個順序很重要，因為可以優化！\n若我們看$A_i$，我們先考慮它會遇到那些$B$的字元$$B_i, B _ {i + |A|}, B _ {i + 2\\times|A|}, \\dots $$，也就是所有的$B _ {i + k|A| \\mod{|B|}}$。可以知道，這樣分可以將$B$的所有字元分成若干個相斥的群組$G_t$！具體做法就是，先看$A_i$，如果$B_i$尚未在一個群組裡面，就創立一個新的群組然後將所有的$B _ {i + k|A|}$加進去這個群組裡面。現在，就想要用這個新的資料儲存方式來加快我們的運算。\n同樣的，我們將注意力集中於$A$的字元$A_i$。如果知道這個字元會被掃到幾次（假設是$k$），那是不是可以從$B_i$在其所屬的群組$G$的位子開始爬$k$次（超過邊界就回到$0$）來計算？這樣就會有累加的感覺了，所以下一步就是——對各個群組計算其各個出法（剪刀石頭布）的前綴！所以，我們可以定義$S(i, j, k)$為第$i$個群組中，符號為$j$（以$0,1,2$表示，對應到剪刀石頭布各一），前$k$個位置的前綴和。\n大致的想法知道了，就可以開始去處理細節了！這題細節頗多，彷彿魚刺，得小心！不過，越多魚刺的魚往往更為鮮甜，勿以此而退縮！\nAC code 對不起有點亂qwq 至少目前跑的比baluteshih快啦XD\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103  #include \u0026lt;iostream\u0026gt;#include \u0026lt;string.h\u0026gt;#include \u0026lt;utility\u0026gt;#include \u0026lt;vector\u0026gt;#define pii pair\u0026lt;int,int\u0026gt; #define F first #define S second #define ericxiao ios_base::sync_with_stdio(0);cin.tie(0); using namespace std; const int maxN = 1e6 + 10; int T, gc = 0; string a, b; inline int getId(char c){ if(c == \u0026#39;R\u0026#39;) return 0; if(c == \u0026#39;P\u0026#39;) return 1; if(c == \u0026#39;S\u0026#39;) return 2; return -1; } vector\u0026lt;pii\u0026gt; where; vector\u0026lt;int\u0026gt; groups[maxN]; vector\u0026lt;int\u0026gt; pre[maxN][3]; //ijk: ith group, jth symbol, kth prefix int main(){ ericxiao; cin \u0026gt;\u0026gt; T \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; bool hS = false; if(a.length() \u0026gt; b.length()){ swap(a, b); hS = true; } where.resize(b.length()); fill(where.begin(), where.end(), pii({-1, -1})); int cg, ind, w = 0, l = 0, d = 0; for(int i = 0; i \u0026lt; a.length(); i++){ if(where[i].F != -1) continue; cg = gc++, ind = i; while(where[ind].F == -1){ where[ind] = {cg, groups[cg].size()}; groups[cg].push_back(ind); ind = ( ind + a.length() ) % b.length(); } } for(int g = 0; g \u0026lt; gc; g++){ pre[g][0].resize(groups[g].size()); pre[g][1].resize(groups[g].size()); pre[g][2].resize(groups[g].size()); pre[g][0][0] = pre[g][1][0] = pre[g][2][0] = 0; pre[g][getId(b[groups[g][0]])][0]++; for(int i = 1; i \u0026lt; groups[g].size(); i++){ for(int j = 0; j \u0026lt; 3; j++) pre[g][j][i] = pre[g][j][i - 1]; pre[g][getId(b[groups[g][i]])][i]++; } } int jf, tlt, rem, frqs[3], myId; for(int i = 0; i \u0026lt; a.length(); i++){ if(i \u0026gt;= T) continue; jf = (T - i - 1) / a.length() + 1; //ijk: ith group, jth symbol, kth prefix  //group index: groups[where[i].F]  //position in group: where[i].S  //want to loop forward (T - i) / a.length() times  //total loop time:  /* (group.size() - [group pos]) + tlt * |group| \u0026lt;= jf tlt = (jf - group.size() + [group pos]) / |group| remaining number to go: jf - ((group.size() - [group pos]) + tlt * |group|) */ if(jf + where[i].S \u0026gt;= groups[where[i].F].size()){ tlt = (jf - (groups[where[i].F].size() - where[i].S)) / groups[where[i].F].size(); rem = jf - (groups[where[i].F].size() - where[i].S + tlt * groups[where[i].F].size()); for(int j = 0; j \u0026lt; 3; j++){ frqs[j] = pre[where[i].F][j][groups[where[i].F].size() - 1] * (tlt + 1) + (rem ? pre[where[i].F][j][rem - 1] : 0) - (where[i].S ? pre[where[i].F][j][where[i].S - 1] : 0); } } else { for(int j = 0; j \u0026lt; 3; j++){ frqs[j] = pre[where[i].F][j][jf + where[i].S - 1] - (where[i].S ? pre[where[i].F][j][where[i].S - 1] : 0); } } myId = getId(a[i]); w += frqs[(myId + 2) % 3]; l += frqs[(myId + 1) % 3]; d += frqs[(myId) % 3]; } if(!hS){ cout \u0026lt;\u0026lt; w \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; l \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; d \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; l \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; w \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; d \u0026lt;\u0026lt; endl; } /* 100 RRR PPPP 1 S RPPPSPPRSS */ }   ","permalink":"https://omeletwithoutegg.github.io/2019/12/05/TIOJ-2019/","tags":["TIOJ","math"],"title":"TIOJ-2019"},{"contents":"我要成為海賊王 https://tioj.ck.tp.edu.tw/problems/1171\nDescription 給定一棵樹，一開始所有頂點都是白色的，有$q$次操作，每次操作可以把一個頂點塗成黑色，或者詢問某個頂點$x$到所有黑色頂點的距離和\nSolution 可能算是經典題吧，這邊提供兩種寫法: 重心剖分和輕重鍊剖分\n重心剖分 重心剖分的核心想法是樹分治，每次拔掉一個點，並統計有經過這個點的答案並遞迴計算沒經過該點的答案\n為了確保複雜度，每次拔掉重心是一個好選擇\n也許可以發現每個頂點都會當一次重心(?)\n並且若把每次拔掉的重心$c$和分治下去的每個子樹找到的重心$c'$都連邊，也會是一棵樹，稱為重心樹\n假設我要查詢$x$這個點，我們就枚舉$x$在重心樹上的祖先\n對於所有黑色頂點$b$來說都可以找到恰一個祖先$c$使得$b,x$最後是被$c$分開的\n可以想到紀錄$cnt_c, sum_c$分別代表分治到以$c$為重心的時候的子樹中，黑色節點的數量以及與$c$的距離和\n加加減減就能得到答案了\n算式好難推QQ去查了YP的題解才知道怎麼寫\n記得在重心樹往上爬的時候必須減掉和下一層有關的一些東西，要避免有重複的邊的路徑被計算到\n式子可能長得像這樣吧\n$$\n\\sum _ {p\\not=croot} sum_q + cnt_q \\cdot path(q,x) - sum_p - cnt_p \\cdot path(p,q)\n$$\n其中$q$是$p$在重心樹上的父節點\n每次詢問的複雜度是重心樹的深度也就是$\\mathcal{O}(\\log n)$\n輕重鍊剖分 用$b$和$B$代表黑色頂點和他們的集合，$dis_v$代表從根走到$v$的距離\n把所求寫成\n$$\n\\sum _ {b\\in B} dis_x + \\sum _ {b\\in B} dis_b - 2\\sum _ {b\\in B} dis _ {LCA(b,x)} = |B|dis_x + \\sum _ {b\\in B}dis_b - 2 \\sum _ {b\\in B} dis _ {LCA(b,x)}\n$$\n關注最後一項，想成枚舉$x$到根的所有邊$e$\n可以發現：$dis _ {LCA(b,x)}$有包含某個$e$ $\\Leftrightarrow$ $b$到根會經過$e$且$x$到根會經過$e$\n所以對每個邊維護一個值$sum_e$，把一個點$x$塗黑的時候就把$x$到根會經過的$sum_e$都加上$e$的長度，查詢$x$的時候就看$x$到根所有邊的$sum_e$總和\n如果畫成圖大概長這樣\n紅藍紫代表那個邊被加幾次，而橘色的框框代表查詢$x$要看的邊\n按照慣例把算邊改成算點，用$e$深度較深的點來代表$e$\n輕重鍊剖分可以把點到根的路徑分成遍歷順序的$\\mathcal{O}(\\log n)$個區間，再搭配一個線段樹處理「區間加值、區間加權和」就可以啦\n這個寫法每次詢問的複雜度是$\\mathcal{O}(\\log^2n)$，如果用link-cut-tree可以到$\\mathcal{O}(\\log n)$的樣子\nAC code 因為1-base好像比較安全我就擅自把輸入都+1了OwO\n重心剖分 好醜(X\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127  // __________________ // | ________________ | // || ____ || // || /\\ | || // || /__\\ | || // || / \\ |____ || // ||________________|| // |__________________| // \\###################\\ // \\###################\\ // \\ ____ \\ // \\_______\\___\\_______\\ // An AC a day keeps the doctor away.  #pragma GCC optimize(\u0026#34;Ofast,unroll-loops,no-stack-protector\u0026#34;) #pragma loop_opt(on) #include \u0026lt;bits/extc++.h\u0026gt;#ifdef local #define debug(x) (cerr\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;) #else #define debug(x) ((void)0) #endif // local #define all(v) begin(v),end(v) #define siz(v) (ll(v.size())) #define get_pos(v,x) (lower_bound(all(v),x)-begin(v)) #define sort_uni(v) sort(begin(v),end(v)),v.erase(unique(begin(v),end(v)),end(v)) #define pb emplace_back #define ff first #define ss second #define mid (l+(r-l\u0026gt;\u0026gt;1)) #define mem(v,x) memset(v,x,sizeof v) #define int ll  using namespace std; using namespace __gnu_pbds; typedef int64_t ll; typedef long double ld; typedef pair\u0026lt;ll,ll\u0026gt; pll; typedef pair\u0026lt;ld,ld\u0026gt; pld; template \u0026lt;typename T\u0026gt; using max_heap = __gnu_pbds::priority_queue\u0026lt;T,less\u0026lt;T\u0026gt; \u0026gt;; template \u0026lt;typename T\u0026gt; using min_heap = __gnu_pbds::priority_queue\u0026lt;T,greater\u0026lt;T\u0026gt; \u0026gt;; template \u0026lt;typename T\u0026gt; using rbt = tree\u0026lt;T,null_type,less\u0026lt;T\u0026gt;,rb_tree_tag,tree_order_statistics_node_update\u0026gt;; constexpr ld PI = acos(-1), eps = 1e-9; constexpr ll N = 100025, INF = 1e18, MOD = 20191126, K = 20, inf = 1e9; constexpr ll modpow(ll e,ll p,ll m=MOD) {ll r=1; for(;p;p\u0026gt;\u0026gt;=1,e=e*e%m) if(p\u0026amp;1) r=r*e%m; return r;} constexpr inline ll cdiv(ll x, ll m) { return (x+m-1)/m; } // ceiling divide, x/m for flooring divide template \u0026lt;typename T\u0026gt; void M(T \u0026amp;x, ll m=MOD){x%=m; if(x\u0026lt;0) x+=m;} struct Edge { ll v,w; // v=a^b } E[N]; int vis[N],sz[N],mxs[N],cpa[N],cdep[N]; ll dis[K][N]; vector\u0026lt;int\u0026gt; g[N],tmp; void dfs(int u) { vis[u] = true, mxs[u] = 0, sz[u] = 1; tmp.pb(u); for(int id:g[u]) { int v = E[id].v^u; if(!vis[v]) dfs(v), mxs[u] = max(mxs[u], sz[v]), sz[u] += sz[v]; } } void get_dis(int u,int d) { // get distance to centroid whose depth is d  vis[u] = true; for(int id:g[u]) { int v = E[id].v^u; if(!vis[v]) dis[d][v] = dis[d][u]+E[id].w, get_dis(v,d); } } void deco(int u,int dep=1,int pa=0) { // centroid decomposition  tmp.clear(); dfs(u); int c = u, S = tmp.size(); for(int i:tmp) { if(max(S-sz[i],mxs[i]) \u0026lt; max(S-sz[c], mxs[c])) c = i; vis[i] = 0; } dis[dep][c] = 0; get_dis(c,dep); for(int i:tmp) vis[i] = 0; vis[c] = true; cpa[c] = pa; cdep[c] = dep; for(int id:g[c]) { int v = E[id].v^c; if(!vis[v]) deco(v,dep+1,c); } } ll ans[N],re[N],cnt[N]; void update(int p) { for(int x = p, d = cdep[p]; x; x = cpa[x], --d) { ans[x] += dis[d][p]; re[x] += dis[d-1][p]; ++cnt[x]; } } ll query(int p) { ll res = 0, now = 0; for(int x = p, d = cdep[p]; x; x = cpa[x], --d) { res += (ans[x] - re[x]) + (cnt[x] - now) * dis[d][p]; now = cnt[x]; } return res; } bitset\u0026lt;N\u0026gt; color; signed main() { int n,q; ios_base::sync_with_stdio(0), cin.tie(0); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; for(int i = 0,a,b,w; i \u0026lt; n-1; i++) { cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; w, a++, b++; E[i] = {a^b,w}; g[a].pb(i), g[b].pb(i); } deco(1); //for(int i = 1; i \u0026lt;= n; i++) cout \u0026lt;\u0026lt; cpa[i] \u0026lt;\u0026lt; \u0026#34; \\n\u0026#34;[i==n];  //for(int i = 1; i \u0026lt;= n; i++) cout \u0026lt;\u0026lt; cdep[i] \u0026lt;\u0026lt; \u0026#34; \\n\u0026#34;[i==n];  //for(int i = 1; i \u0026lt;= n; i++) cout \u0026lt;\u0026lt; dis[1][i] \u0026lt;\u0026lt; \u0026#34; \\n\u0026#34;[i==n];  while(q--) { int t,v; cin \u0026gt;\u0026gt; t \u0026gt;\u0026gt; v, v++; if(t == 2) cout \u0026lt;\u0026lt; query(v) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; else if(t == 1 \u0026amp;\u0026amp; !color[v]) color[v] = true, update(v); //for(int i = 1; i \u0026lt;= n; i++) cout\u0026lt;\u0026lt;ans[i]\u0026lt;\u0026lt;\u0026#34; \\n\u0026#34;[i==n];  } }   輕重鍊剖分 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150  // __________________ // | ________________ | // || ____ || // || /\\ | || // || /__\\ | || // || / \\ |____ || // ||________________|| // |__________________| // \\###################\\ // \\###################\\ // \\ ____ \\ // \\_______\\___\\_______\\ // An AC a day keeps the doctor away.  #pragma g++ optimize(\u0026#34;Ofast\u0026#34;) #pragma loop_opt(on) #include \u0026lt;bits/extc++.h\u0026gt;#ifdef local #define debug(x) (cerr\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;) #else #define debug(x) ((void)0) #endif // local  using namespace std; typedef int64_t ll; constexpr ll N = 100001, INF = 1e18, MOD = 1000000007, K = 256, inf = 1e9; struct SegmentTree { ll w[N\u0026lt;\u0026lt;1],sum[N\u0026lt;\u0026lt;1]; int laz[N],n; void init(int _w[],int _n) { n = _n; for(int i = 0; i \u0026lt; n; i++) w[i+n] = _w[i]; for(int i = n-1; i \u0026gt; 0; i--) w[i] = w[i\u0026lt;\u0026lt;1]+w[i\u0026lt;\u0026lt;1|1]; } void upd(int p,int d) { sum[p] += d*w[p]; if(p \u0026lt; n) laz[p] += d; } void pull(int p) { while(p\u0026gt;1) sum[p\u0026gt;\u0026gt;1] = sum[p]+sum[p^1]+laz[p\u0026gt;\u0026gt;1]*w[p\u0026gt;\u0026gt;1], p\u0026gt;\u0026gt;=1; } void push(int p) { for(int h = __lg(n); h \u0026gt;= 0; h--) { int i = p\u0026gt;\u0026gt;h; if(!laz[i\u0026gt;\u0026gt;1]) continue; upd(i,laz[i\u0026gt;\u0026gt;1]); upd(i^1,laz[i\u0026gt;\u0026gt;1]); laz[i\u0026gt;\u0026gt;1] = 0; } } void edit(int l,int r,int d) { int L = l, R = r; for(l+=n,r+=n; l\u0026lt;r; l\u0026gt;\u0026gt;=1,r\u0026gt;\u0026gt;=1) { if(l\u0026amp;1) upd(l++,d); if(r\u0026amp;1) upd(--r,d); } pull(L+n), pull(R-1+n); } ll query(int l,int r) { ll res = 0; push(l+n), push(r-1+n); for(l+=n,r+=n; l\u0026lt;r; l\u0026gt;\u0026gt;=1,r\u0026gt;\u0026gt;=1) { if(l\u0026amp;1) res += sum[l++]; if(r\u0026amp;1) res += sum[--r]; } return res; } } sgt; struct HeavyLightDecomposition { struct Edge {int cost,to;}; vector\u0026lt;Edge\u0026gt; g[N]; int pa[N],pa_d[N]; int sz[N],mxs[N],id[N],link_top[N]; int weight[N],sumc,tot; ll dis[N],sumd; void add_edge(int a,int b,int c) { g[a].push_back({c,b}); g[b].push_back({c,a}); } void dfs(int i) { sz[i] = 1; mxs[i] = 0; for(auto \u0026amp;edge:g[i]) { int j = edge.to; int c = edge.cost; if(j == pa[i]) continue; pa[j] = i; pa_d[j] = c; dis[j] = dis[i] + c; dfs(j); sz[i]+=sz[j]; if(mxs[i]==0 || sz[j] \u0026gt; sz[mxs[i]]) mxs[i] = j; } } void deco(int i,int t) { link_top[i] = t; weight[id[i] = tot++] = pa_d[i]; if(mxs[i]) deco(mxs[i],t); for(auto \u0026amp;edge:g[i]) { int j = edge.to; if(j == pa[i] || j == mxs[i]) continue; deco(j,j); } } void init(int n) { dfs(1); deco(1,1); sgt.init(weight,n); } void poke(int x) { sumd += dis[x]; ++sumc; while(x) { int y = link_top[x]; sgt.edit(id[y],id[x]+1,1); x = pa[y]; } } ll query(int x) { ll res = sumc * dis[x] + sumd; while(x) { int y = link_top[x]; res -= 2*sgt.query(id[y],id[x]+1); x = pa[y]; } return res; } } HLD; bool color[N]; signed main() { ios_base::sync_with_stdio(0), cin.tie(0); int n,q; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; for(int i = 1,a,b,c; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c; ++a, ++b; HLD.add_edge(a,b,c); } HLD.init(n); while(q--) { int t,x; cin \u0026gt;\u0026gt; t \u0026gt;\u0026gt; x, ++x; if(t == 1) { if(!color[x]) color[x] = 1, HLD.poke(x); }else if(t == 2) { cout \u0026lt;\u0026lt; HLD.query(x) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } }   ","permalink":"https://omeletwithoutegg.github.io/2019/12/04/TIOJ-1171/","tags":["TIOJ","tree","data-structure"],"title":"TIOJ-1171"},{"contents":"排教室問題 https://tioj.ck.tp.edu.tw/problems/1197\nDescription 某校有M種不同的課程，其中有些課程的時間會有衝堂。如果學校中總共有N間不同的教室，請問共有多少種安排各課程上課教室的方式？最少要用到幾間教室？\n$M,N \\leq 10$\n註: 衝堂的意思是他們不能被安排在同一個教室\nSolution 題目可以想成給定一張圖，每個頂點有$k$種顏色可以塗，定義合法塗色是讓相鄰頂點無同色的塗色方式，問有幾種合法塗色的方式以及至少要用多少顏色才能合法塗色\n一開始覺得這是暴搜題，但忽然想到可能不連通也可能會有環之後就不太知道怎麼實作\n另外題敘好像沒有講到，不過這題讀邊的時候要用EOF讀\n這題我的寫法是位元DP，考慮狀態$dp[S][c]$代表$c$之前的顏色都用過了，並且$S$這個subset已經被塗過了\n那轉移可以想成把$S$的一個subset$X$都塗上$c$這個顏色，當然$X$中任意兩個頂點都不相鄰(也就是說$X$是獨立集)，式子長得像\n$$\ndp[S][c] = \\sum\\limits _ {X \\subseteq S, Valid(X)} dp[S \\setminus X][c-1]\n$$\n其中$Valid(X)$代表$X$是否為獨立集，可以先預處理\n預處理獨立集可以做到$\\mathcal{O}(n \\cdot 2^n)$，而後面枚舉$k$次子集則是$\\mathcal{O}(k \\cdot 3^n)$\n註: 一次枚舉複雜度是$\\mathcal{O}(3^n)$的原因可以參考 https://cp-algorithms.com/algebra/all-submasks.html\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; const int N = 10; typedef long long ll; int k,n,a,b,valid[1\u0026lt;\u0026lt;N],g[N][N]; ll dp[1\u0026lt;\u0026lt;N][N]; signed main() { scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;n,\u0026amp;k); while(~scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;a,\u0026amp;b)) --a, --b, g[a][b] = g[b][a] = true; for(int s = 0; s \u0026lt; (1\u0026lt;\u0026lt;n); s++) valid[s] = true; for(int s = 0; s \u0026lt; (1\u0026lt;\u0026lt;n); s++) { for(int i = n-1; i \u0026gt;= 0; i--) if(s \u0026amp; (1\u0026lt;\u0026lt;i)) { if(!valid[s ^ (1\u0026lt;\u0026lt;i)]) valid[s] = false; for(int j = 0; j \u0026lt; i; j++) if(s \u0026amp; (1\u0026lt;\u0026lt;j)) if(g[i][j]) valid[s] = false; break; } } int ans = n; ll sum = 0; int S = (1\u0026lt;\u0026lt;n)-1; dp[0][0] = 1; for(int c = 1; c \u0026lt;= max(k,n); c++) { for(int s = 0; s \u0026lt; (1\u0026lt;\u0026lt;n); s++) { dp[s][c] = dp[s][c-1]; for(int f = s; f; f = (f-1)\u0026amp;s) if(valid[f]) { dp[s][c] += dp[s^f][c-1]; } } if(dp[S][c]) ans = min(ans, c); } printf(\u0026#34;%lld\\n%d\\n\u0026#34;,dp[S][k],ans); }   話說雖然感覺會需要long long不過TIOJ上似乎沒有會超過int的測資\n另外利用Fast Subset Convolution可以讓後面那部分從$\\mathcal{O}(3^n)$壓到$\\mathcal{O}(n^22^n)$\n可以參考 https://people.csail.mit.edu/rrw/presentations/subset-conv.pdf\n不過常數蠻大的，要$n$大一點才看得出來差異\n","permalink":"https://omeletwithoutegg.github.io/2019/12/04/TIOJ-1197/","tags":["TIOJ","dp","bitmask"],"title":"TIOJ-1197"},{"contents":"F.無限兔子問題 https://tioj.ck.tp.edu.tw/problems/2021\nDescription 令$F_i$是費式數列\n給定$s,t$，求$\\sum\\limits _ {i=s}^t\\binom{F_i}{2}$\nSolution 這題也是有夠數學OwO\n題目所求是$\\sum\\limits _ {i=s}^t\\frac{1}{2}{F_i(F_i - 1)}$\n可以想到分別求$\\sum\\limits _ {i=1}^nF_i$和$\\sum\\limits _ {i=1}^nF_i^2$\n前者可以用\n$$\n\\left[\n\\begin{matrix}\n0 \u0026amp; 1 \u0026amp; 0 \\newline\n1 \u0026amp; 1 \u0026amp; 0 \\newline\n1 \u0026amp; 1 \u0026amp; 1\n\\end{matrix}\n\\right]\n\\left[\n\\begin{matrix}\nF _ {i-2} \\newline\nF _ {i-1} \\newline\nS _ {i-1}\n\\end{matrix}\n\\right] =\n\\left[\n\\begin{matrix}\nF _ {i-1} \\newline\nF_i \\newline\nS_i\n\\end{matrix}\n\\right]\n$$\n來得到前綴$S_i$的值\n然後$F_i^2 = (F _ {i-1}+F _ {i-2})^2 = F _ {i-1}^2 + F _ {i-2}^2 + 2F _ {i-1}F _ {i-2}$\n又有$F_iF _ {i-1} = (F _ {i-1}+F _ {i-2})F _ {i-1} = F _ {i-1}F _ {i-2} + F _ {i-1}^2$\n所以寫成\n$$\n\\left[\n\\begin{matrix}\n0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0\\newline\n0 \u0026amp; 1 \u0026amp; 1 \u0026amp; 0\\newline\n1 \u0026amp; 2 \u0026amp; 1 \u0026amp; 0\\newline\n1 \u0026amp; 2 \u0026amp; 1 \u0026amp; 1\n\\end{matrix}\n\\right]\n\\left[\n\\begin{matrix}\nF _ {i-2}^2\\newline\nF _ {i-1}F _ {i-2}\\newline\nF _ {i-1}^2\\newline\nQ _ {i-1}\n\\end{matrix}\n\\right] =\n\\left[\n\\begin{matrix}\nF _ {i-1}^2\\newline\nF_iF _ {i-1}\\newline\nF_i^2\\newline\nQ_i\n\\end{matrix}\n\\right]\n$$\n可以得到二次的前綴\n套上矩陣快速冪即可AC本題\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79  // __________________ // | ________________ | // || ____ || // || /\\ | || // || /__\\ | || // || / \\ |____ || // ||________________|| // |__________________| // \\###################\\ // \\###################\\ // \\ ____ \\ // \\_______\\___\\_______\\ // An AC a day keeps the doctor away.  #pragma g++ optimize(\u0026#34;Ofast\u0026#34;) #pragma loop_opt(on) #include \u0026lt;bits/extc++.h\u0026gt;#ifdef local #define debug(x) (cerr\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;) #else #define debug(x) ((void)0) #endif // local  using namespace std; typedef int64_t ll; constexpr ll N = 1025, INF = 1e18, MOD = 1000000007, K = 512, inf = 1e9; constexpr ll modpow(ll e,ll p,ll m=MOD) {ll r=1; for(;p;p\u0026gt;\u0026gt;=1,e=e*e%m) if(p\u0026amp;1) r=r*e%m; return r;} ll inv2 = modpow(2,MOD-2); typedef vector\u0026lt;vector\u0026lt;ll\u0026gt;\u0026gt; matrix; matrix operator*(const matrix \u0026amp;a, const matrix \u0026amp;b) { matrix c(a.size(), vector\u0026lt;ll\u0026gt;(b[0].size())); for(int i = 0; i \u0026lt; a.size(); i++) for(int k = 0; k \u0026lt; b.size(); k++) { ll r = a[i][k]; for(int j = 0; j \u0026lt; b[k].size(); j++) c[i][j] = (c[i][j] + r*b[k][j]) % MOD; } return c; } matrix operator^(matrix e, ll p) { matrix r(e.size(), vector\u0026lt;ll\u0026gt;(e.size())); for(int i = 0; i \u0026lt; e.size(); i++) r[i][i] = 1; while(p) { if(p\u0026amp;1) r = r*e; e = e*e, p\u0026gt;\u0026gt;=1; } return r; } ll solve(ll n) { if(n == 0) return 0; /* [F _ {n-1}, F_n, S_n] [F _ {n-1}^2, F _ {n-1}F_n, F_n^2, Q_n] */ matrix S { {0,1,0}, {1,1,0}, {1,1,1}, }; matrix Q { {0,0,1,0}, {0,1,1,0}, {1,2,1,0}, {1,2,1,1}, }; matrix Rs = {{0},{1},{1}}; matrix Rq = {{0},{0},{1},{1}}; S = (S^(n-1)) * Rs; Q = (Q^(n-1)) * Rq; return (Q[3][0] - S[2][0] + MOD) * inv2 % MOD; } signed main() { ios_base::sync_with_stdio(0), cin.tie(0); ll t,a,b; cin \u0026gt;\u0026gt; t; while(t--) { cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; cout \u0026lt;\u0026lt; (solve(b) - solve(a-1) + MOD) % MOD \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } }   這題的題源好像是NPSC? 不過我還是查不太到題解，可能太水了吧QQ\n","permalink":"https://omeletwithoutegg.github.io/2019/12/04/TIOJ-2021/","tags":["TIOJ","math","matrix"],"title":"TIOJ-2021"},{"contents":"愛蜜利雅的作業2 https://tioj.ck.tp.edu.tw/problems/1282\nDescription 給定一個長度$n$的正整數序列，有$q$次操作，每次操作可能會對區間$[l,r]$加上$k$或詢問區間$[l,r]$的最大公因數\n$1 \\leq n,q \\leq 10^5$\nSolution 想法是利用區間加值等於對差分的兩個單點修改\n然後有一個性質是 $\\gcd(a,b) = \\gcd(a-b,b)$\n所以$[l,r]$區間的GCD會等於$\\gcd(\\gcd(a _ {l+1}-a_l, a _ {l+2}-a _ {l+1}, \\dots, a_r-a _ {r-1}), a_r)$之類的\n求$a_r$可以用BIT就好，前面那項我則是用線段樹維護\n複雜度$\\mathcal{O}(n\\log c + q\\log n \\log c)$\n注意算完GCD要加絕對值，因為差分會出現負數，此時__gcd可能回傳負數\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87  // __________________ // | ________________ | // || ____ || // || /\\ | || // || /__\\ | || // || / \\ |____ || // ||________________|| // |__________________| // \\###################\\ // \\###################\\ // \\ ____ \\ // \\_______\\___\\_______\\ // An AC a day keeps the doctor away.  #pragma g++ optimize(\u0026#34;Ofast\u0026#34;) #pragma loop_opt(on) #include \u0026lt;bits/extc++.h\u0026gt;#ifdef local #define debug(x) (cerr\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;) #else #define debug(x) ((void)0) #endif // local  using namespace std; typedef int64_t ll; constexpr ll N = 100025, INF = 1e18, MOD = 1000000007, K = 256, inf = 1e9; struct FenwickTree{ ll sum[N],n; void init(ll v[],int _n) { n = _n; for(int i = 1; i \u0026lt;= n; i++) sum[i] = v[i] - v[i-(i\u0026amp;-i)]; } ll query(int p) { ll res = 0; for(; p; p-=p\u0026amp;-p) res += sum[p]; return res; } void edit(int p,ll d) { for(; p\u0026lt;=n; p+=p\u0026amp;-p) sum[p] += d; } } BIT; struct SegmentTree { ll seg[N\u0026lt;\u0026lt;1],n; void init(ll v[],int _n) { n = _n; for(int i = 0; i \u0026lt; n; i++) seg[i+n] = v[i]; for(int i = n-1; i \u0026gt; 0; i--) seg[i] = __gcd(seg[i\u0026lt;\u0026lt;1],seg[i\u0026lt;\u0026lt;1|1]); } ll query(int l,int r) { ll res = 0; for(l+=n,r+=n; l\u0026lt;r; l\u0026gt;\u0026gt;=1,r\u0026gt;\u0026gt;=1) { if(l\u0026amp;1) res = __gcd(res,seg[l++]); if(r\u0026amp;1) res = __gcd(res,seg[--r]); } return abs(res); } void edit(int p,ll d) { for(seg[p+=n]+=d; p\u0026gt;1; p\u0026gt;\u0026gt;=1) seg[p\u0026gt;\u0026gt;1] = __gcd(seg[p],seg[p^1]); } } sgt; int n,q; ll v[N]; signed main() { ios_base::sync_with_stdio(0), cin.tie(0); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; for(int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; v[i]; BIT.init(v,n); for(int i = 0; i \u0026lt; n; i++) v[i] = v[i+1]-v[i]; sgt.init(v,n); while(q--) { int tp,l,r; ll k; cin \u0026gt;\u0026gt; tp; if(tp == 1) { cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r \u0026gt;\u0026gt; k; BIT.edit(l,k); BIT.edit(r+1,-k); sgt.edit(l-1,k); sgt.edit(r,-k); }else { cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; cout \u0026lt;\u0026lt; abs(__gcd(BIT.query(r), sgt.query(l,r))) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } }   註: 寫題解的時候一直TLE，後來發現是我的edit宣告成ll卻沒回傳東西orz\u0026hellip;\n似乎在TIOJ上宣告成非void的函數而不回傳值有機會出問題\u0026hellip;\n","permalink":"https://omeletwithoutegg.github.io/2019/12/04/TIOJ-1282/","tags":["TIOJ","data-structure","math"],"title":"TIOJ-1282"},{"contents":"在刷TIOJ的時候都查不到解，所以我想來當那個查的到的解! 希望能進選訓營(*’ｰ’*)\n全國賽打得好像算好，能夠跳過入營考去選訓了\u0026gt;W\u0026lt;\n開心\u0026gt;w\u0026lt; 選訓2!第三\nIOI2020 打好爛，想要重新再來。不過似乎被 Enjoy_the_game電爆了\n大家好，我是一塊蛋餅，一塊APIO沒拿過牌不過IOI2021撈到金牌的蛋餅\n","permalink":"https://omeletwithoutegg.github.io/about/","tags":null,"title":"about"},{"contents":"這是一篇測試用的文章\nA quick brown fox jumps over the lazy dog.\n 引用文字\n 標題 二級標題 1 2 3 4 5  #include \u0026lt;iostream\u0026gt; int main() { std::cout \u0026lt;\u0026lt; \u0026#34;Hello hexo\u0026#34; \u0026lt;\u0026lt; std::endl; }   1 2 3  $ hexo clean $ hexo s -g $ echo 7122   ","permalink":"https://omeletwithoutegg.github.io/2019/12/01/hello-world/","tags":["hexo","blog"],"title":"Hello World"},{"contents":"This is the search page, type keywords to search among my articles.\n","permalink":"https://omeletwithoutegg.github.io/search/","tags":null,"title":"Search"}]