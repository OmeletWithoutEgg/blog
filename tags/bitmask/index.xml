<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Bitmask on 蛋餅的競程隨筆</title><link>https://omeletwithoutegg.github.io/tags/bitmask/</link><description>Recent content in Bitmask on 蛋餅的競程隨筆</description><generator>Hugo</generator><language>en-us</language><copyright>Omelet</copyright><lastBuildDate>Fri, 24 Jan 2020 10:33:31 +0000</lastBuildDate><atom:link href="https://omeletwithoutegg.github.io/tags/bitmask/index.xml" rel="self" type="application/rss+xml"/><item><title>TIOJ-1094</title><link>https://omeletwithoutegg.github.io/2020/01/24/tioj-1094/</link><pubDate>Fri, 24 Jan 2020 10:33:31 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2020/01/24/tioj-1094/</guid><description>C.幼稚國王的獎賞 https://tioj.ck.tp.edu.tw/problems/1094
Description 定義一個非負整數集合的價值是裡面所有數字XOR起來
給定一些非負整數，問你能選出價值最高的子集價值是多少？
Solution 經典題 maximum subset xor
線性基 首先可以把每個數字的二進位看成模2的$k$維向量
span 我們說一群向量$S = {\textbf{v}_ 1, \textbf{v}_ 2, \dots, \textbf{v}_ n}$的線性生成空間是
$$
\textrm{span}(S) = { \sum _ {i=1}^n\lambda _ i \textbf{v} _ i }
$$
也就是說$\textrm{span}(S)$代表的是所有$S$內的元素的有限線性組合
linear independent 對於一組向量${\textbf{v}_ 1, \textbf{v}_ 2, \dots, \textbf{v} _ n}$
若存在不全為$0$的$\lambda_1, \lambda_2, \dots, \lambda_n$使得
$$
\sum _ {i=1}^n\lambda_ i \textbf{v}_ i = \textbf{0}
$$
則我們說這群向量是線性相關的；反之則稱為線性獨立(linear independent)
一組線性相關的向量至少有一個向量可以用其他向量表示
說明: 不失一般性設$\lambda _ 1 \neq 0$，則</description></item><item><title>TIOJ-1197</title><link>https://omeletwithoutegg.github.io/2019/12/04/tioj-1197/</link><pubDate>Wed, 04 Dec 2019 14:18:31 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2019/12/04/tioj-1197/</guid><description>排教室問題 https://tioj.ck.tp.edu.tw/problems/1197
Description 某校有M種不同的課程，其中有些課程的時間會有衝堂。如果學校中總共有N間不同的教室，請問共有多少種安排各課程上課教室的方式？最少要用到幾間教室？
$M,N \leq 10$
註: 衝堂的意思是他們不能被安排在同一個教室
Solution 題目可以想成給定一張圖，每個頂點有$k$種顏色可以塗，定義合法塗色是讓相鄰頂點無同色的塗色方式，問有幾種合法塗色的方式以及至少要用多少顏色才能合法塗色
一開始覺得這是暴搜題，但忽然想到可能不連通也可能會有環之後就不太知道怎麼實作
另外題敘好像沒有講到，不過這題讀邊的時候要用EOF讀
這題我的寫法是位元DP，考慮狀態$dp[S][c]$代表$c$之前的顏色都用過了，並且$S$這個subset已經被塗過了
那轉移可以想成把$S$的一個subset$X$都塗上$c$這個顏色，當然$X$中任意兩個頂點都不相鄰(也就是說$X$是獨立集)，式子長得像
$$
dp[S][c] = \sum\limits _ {X \subseteq S, Valid(X)} dp[S \setminus X][c-1]
$$
其中$Valid(X)$代表$X$是否為獨立集，可以先預處理
預處理獨立集可以做到$\mathcal{O}(n \cdot 2^n)$，而後面枚舉$k$次子集則是$\mathcal{O}(k \cdot 3^n)$
註: 一次枚舉複雜度是$\mathcal{O}(3^n)$的原因可以參考 https://cp-algorithms.com/algebra/all-submasks.html
AC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include &amp;lt;cstdio&amp;gt; #include &amp;lt;algorithm&amp;gt; using namespace std; const int N = 10; typedef long long ll; int k,n,a,b,valid[1&amp;lt;&amp;lt;N],g[N][N]; ll dp[1&amp;lt;&amp;lt;N][N]; signed main() { scanf(&amp;#34;%d%d&amp;#34;,&amp;amp;n,&amp;amp;k); while(~scanf(&amp;#34;%d%d&amp;#34;,&amp;amp;a,&amp;amp;b)) --a, --b, g[a][b] = g[b][a] = true; for(int s = 0; s &amp;lt; (1&amp;lt;&amp;lt;n); s++) valid[s] = true; for(int s = 0; s &amp;lt; (1&amp;lt;&amp;lt;n); s++) { for(int i = n-1; i &amp;gt;= 0; i--) if(s &amp;amp; (1&amp;lt;&amp;lt;i)) { if(!</description></item></channel></rss>