<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Data-Structure on 蛋餅的競程隨筆</title><link>https://omeletwithoutegg.github.io/tags/data-structure/</link><description>Recent content in Data-Structure on 蛋餅的競程隨筆</description><generator>Hugo</generator><language>en-us</language><copyright>Omelet</copyright><lastBuildDate>Sun, 09 Jul 2023 02:26:08 +0800</lastBuildDate><atom:link href="https://omeletwithoutegg.github.io/tags/data-structure/index.xml" rel="self" type="application/rss+xml"/><item><title>CF 793f Julia the snail</title><link>https://omeletwithoutegg.github.io/2023/07/09/cf-793f/</link><pubDate>Sun, 09 Jul 2023 02:26:08 +0800</pubDate><guid>https://omeletwithoutegg.github.io/2023/07/09/cf-793f/</guid><description>Codeforces 793 F Julia the snail Description 有 $M$ 個傳送器，第 $i$ 個可以把你從 $l_i$ 傳送到 $r_i$，其中 $l_i, r_i$ 介在 $1, N$ 之間。
你除了傳送以外的移動方式只有向數線的左邊走（把 $x$ 變小）
接著有 $Q$ 筆詢問問，每筆詢問給 $x, y$，
問你從 $x$ 開始走，在不超出 $[x, y]$ 這個區間的前提下可以走最右邊是多右邊。
$r_i$ 全部相異（雖然我感覺好像沒用）
Solution 想了很久之後看官解發現是 $\mathcal{O}(\sqrt{n})$ 氣死
留言說有一個 log 的解但他不願透露
網路上查到很多類似吉如一線段樹的解但我覺得他們都沒什麼說服力
先從 naive 的想法開始說明。
這邊的說明都是用左閉右閉的。
如果把所有被 $[x, y]$ 包含的 $[l_i, r_i]$ 拿出來，那他們會把整個區間分成一些連通塊的感覺。
具體來說，會有一些分界線 $z$，
使得我們可以把 $[l_i, r_i]$ 分成兩部分，一部分完全落在 $[x, z]$ 而另一部分完全落在 $[z+1, y]$。
注意到 $z = y$ 一定是一個合法的分界線（？）</description></item><item><title>TIOJ 1841</title><link>https://omeletwithoutegg.github.io/2022/02/11/tioj-1841/</link><pubDate>Fri, 11 Feb 2022 10:03:10 +0800</pubDate><guid>https://omeletwithoutegg.github.io/2022/02/11/tioj-1841/</guid><description>好．傳囉！ Nice Boat！ Description 給定一個長度 $N$ 的整數序列 $A_i$。
如果你可以找出一個區間，他的前綴和每個數字都大於等於0，而且他的後綴和的每個數字也都大於等於0，我們就稱他是安全區間，請你找出最長的安全區間長度是多少。
Solution 考慮原序列的前綴和 $p_i = A_1+A_2+\cdots+A_i$，$p_0=0$，一個區間 $(l, r]$ 是安全區間若且唯若：
$$
\begin{cases}
\forall l \leq x &amp;lt; r ,&amp;amp; p_r - p_x \geq 0 \\
\forall l &amp;lt; x \leq r ,&amp;amp; p_x - p_l \geq 0 \\
\end{cases}
$$
也就是說，$p_r$ 和 $p_l$ 分別必須要是這段區間的最大值與最小值。
可以用單調隊列對於每個 $r$ 求出它左邊第一個嚴格比 $p_r$ 大的數字 $left_r$，以及對於每個 $l$ 求出它右邊第一個嚴格比 $p_l$ 小的數字 $right_l$。
那麼，安全區間的定義又可以寫成
$$
left_r &amp;lt; l \leq r &amp;lt; right_l</description></item><item><title>TOI 2021 Solutions</title><link>https://omeletwithoutegg.github.io/2021/09/22/toi-2021-sols/</link><pubDate>Wed, 22 Sep 2021 01:15:50 +0800</pubDate><guid>https://omeletwithoutegg.github.io/2021/09/22/toi-2021-sols/</guid><description>2021 TOI 模考 可能因為以前 TOI 模考題也不太公開，好像從來沒人做過這種事情，但因為現在模考題甚至可以在公開的 facebook 社團看到，所以我認為這樣沒有太不妥。
今年的題目相較於去年簡單很多（去年好難…），所以就嘗試把四次模擬考總共 16 題的解寫完啦～要是能幫上想做今年模考題的人就好了！
如果想在 hackmd 上看的話可以戳 https://hackmd.io/@omeletwithoutegg/TOI-2021-sols
如果只想看題目可以戳
https://www.facebook.com/notes/%E8%B3%87%E8%A8%8A%E7%AB%B6%E8%B3%BD%E9%81%B8%E6%89%8B%E6%96%B0%E6%89%8B%E6%9D%91/toi-2021/823380795202246/
免責條款 因為測資不一定夠強，有些解也是賽後討論才AC或是甚至只有精神AC的
所以這裡的解有可能任何錯誤或是唬爛，不可全盤相信。
註：三模跟四模的 code 幾乎都沒有丟到師大開放的臨時 judge 上跑，所以不保證正確。
一模 p1 shortcut 題意 定義一張圖的總花費是所有點對之間的最短距離總和。
給定一張 $n$ 點 $m$ 邊的簡單無向連通圖，在你可以加一條邊的情況下，和原圖相比最多可以減少多少總花費？又有幾種加邊的方式可以減少那麼多花費？
限制 $3 \leq n \leq 500; n-1 \leq m \leq n(n-1)/2-1$
subtask 1 (9) $n \leq 40$ subtask 2 (22) $n \leq 150$ subtask 3 (18) $m = n-1$ subtask 4 (51) 無額外限制 作法 $\mathcal{O}(n^5)$</description></item><item><title>PBDS Split Join Is Slow</title><link>https://omeletwithoutegg.github.io/2021/07/23/pbds-split-join-is-slow/</link><pubDate>Fri, 23 Jul 2021 18:16:13 +0800</pubDate><guid>https://omeletwithoutegg.github.io/2021/07/23/pbds-split-join-is-slow/</guid><description>幫 pbds 上香 如題。
先說結論：
官網的 document 寫說 split 跟 join 時間是「poly-logarithm」，但是其實目前為止 GNU 的 pbds 預設的 split 是 $\mathcal{O}(N)$ 的，請看這篇文章。
不過有一些方法可以讓複雜度變回一次 split $\Theta(\log N)$，但是有一點麻煩。
前言 Policy-Base Data Structure 簡稱 pbds ，是 GCC 提供的一系列資料結構的 template，而今天要談的是當中的 tree 型別。
因為看到別人寫的 pbds 自訂 metadata_type 覺得很酷，因此想要來探索探索 pbds 一番。
大概了解 node_update 怎麼運作之後，我試著去寫了 氣球博覽會，因為需要區間查詢，我使用了 tree::split(key, other) 和 tree::join(other)，沒想到全部吃 TLE，研究一番之後發現下面這樣的 code 就會執行不完了：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include &amp;lt;bits/extc++.</description></item><item><title>TIOJ-1764</title><link>https://omeletwithoutegg.github.io/2020/05/12/tioj-1764/</link><pubDate>Tue, 12 May 2020 15:31:47 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2020/05/12/tioj-1764/</guid><description>Ch2. Section 9. 補魔力的條件 https://tioj.ck.tp.edu.tw/problems/1764
Description 現在有排成一直線的$N$個格子，從左到右編號為$1 \dots N$，每個格子都有自己的高度 一開始你站在第一格，每次移動都只能往編號大的格子跳，目標是走到第$N$格 假設第$i$個格子的高度是$x_i$，從格子$i$跳到格子$j$需要耗費$\max(0, (j-i)+(x_j-x_i))$的力氣
請問在花最少力氣到達終點的前提下，他最多可以跳幾次? Solution 先考慮最小化力氣
令$x_i+i = v_i$，簡單的列出DP式
$$
dp[i] = \min _ {j &amp;lt; i}(dp[j] + \max(0,v_j-v_i))
$$
這樣的複雜度是$\mathcal{O}(N^2)$
不過可以分case討論
$$
dp[i] = \min(
\min _ {j &amp;lt; i \wedge v_j \geq v_i}(dp[j]+v_j)-v_i,
\min _ {j &amp;lt; i \wedge v_j &amp;lt; v_i}(dp[j])
)
$$
就可以用資料結構$\mathcal{O}(N \log N)$維護了
那麼最多可以跳的次數也可以一邊維護
也就是說如果力氣不同就選力氣小的，力氣相同則選跳的次數多的，可以直接用pair做就好
這邊寫的是值域壓縮之後用BIT維護前後綴min OAO
AC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #pragma GCC optimize(&amp;#34;Ofast&amp;#34;) #pragma loop_opt(on) #include &amp;lt;bits/stdc++.</description></item><item><title>TIOJ-1633</title><link>https://omeletwithoutegg.github.io/2020/05/08/tioj-1633/</link><pubDate>Fri, 08 May 2020 13:43:30 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2020/05/08/tioj-1633/</guid><description>序列維護問題 https://tioj.ck.tp.edu.tw/problems/1633
Description 有一個由1到N的數字排成的序列。
可是你對於現在這個排列很不滿意，決定透過一些操作改變這個序列。
你現在有兩種操作：
REV L R ：把L到R所有數字反轉順序，例如1 2 3 4變成4 3 2 1 SWAP L1 R1 L2 R2：把L1到R1所有數字跟L2到R2所有數字交換位置，但順序不變。 你總共進行了M次操作，請輸出最後序列的樣子。
Solution 平衡二元樹裸題，我用的是Treap
要反轉的話可以打懶標(?)然後記得push
AC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 #pragma GCC optimize(&amp;#34;Ofast&amp;#34;) #pragma loop_opt(on) #include &amp;lt;cstdio&amp;gt; #include &amp;lt;random&amp;gt; const int N = 130025; inline char readchar() { constexpr int B = 1&amp;lt;&amp;lt;20; static char buf[B], *p, *q; if(p == q &amp;amp;&amp;amp; (q=(p=buf)+fread(buf,1,B,stdin)) == buf) return EOF; return *p++; } inline int nextint() { int x = 0, c = readchar(); while(c &amp;lt; &amp;#39;0&amp;#39;) c = readchar(); while(c &amp;gt;= &amp;#39;0&amp;#39;) x=x*10+(c^&amp;#39;0&amp;#39;), c=readchar(); return x; } inline void readuntil(char *s, char esc = &amp;#39;\n&amp;#39;) { char c = readchar(); while(c !</description></item><item><title>TIOJ-2140</title><link>https://omeletwithoutegg.github.io/2020/02/25/tioj-2140/</link><pubDate>Tue, 25 Feb 2020 09:09:25 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2020/02/25/tioj-2140/</guid><description>殿壬愛序列 https://tioj.ck.tp.edu.tw/problems/2140
Description 給你一個長度為$N$的序列$a_1, a_2, \dots, a_N$，並且依序執行$Q$個操作，每個操作可能是
1 x y ：把$a_x$設成$y$
2 L R k ：對於每個$i \in [L, R]$，把$a_i$設成$\lfloor \frac{a_i}{k} \rfloor$。其中$\lfloor x \rfloor$代表不大於$x$的最大整數
3 L R ：請輸出$a_L, a _ {L+1}, \dots, a_R$的絕對眾數，如果絕對眾數不存在請輸出-1。一個數字若為$T$個數字的絕對眾數，代表這個數字至少在$T$個數字中出現$\lfloor \frac{T+2}{2} \rfloor$次。
$1 \leq N, Q \leq 10^5$
$1 \leq L \leq R \leq N$
$1 \leq x \leq N$
$0 \leq a_i, y \leq 10^9$
$1 \leq k \leq 10^9$
Solution 打架線段樹的裸題
對每個節點維護val和win，分別表示那個區間打贏的數字以及他贏了多少(?)
合併的時候假如兩個區間的val一樣，那麼他們的win就會相加
不同的話就是讓他們打架! win比較多的一方獲勝，但是必須減去對方的win
詳細請看node operator+的部分</description></item><item><title>TIOJ-1798</title><link>https://omeletwithoutegg.github.io/2020/02/23/tioj-1798/</link><pubDate>Sun, 23 Feb 2020 11:34:03 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2020/02/23/tioj-1798/</guid><description>Can You Arrive? https://tioj.ck.tp.edu.tw/problems/1798
Description 地鐵有$N$個站，$M$條軌道，$K$段行駛路線
站與站之間使用軌道連接
保證軌道不會形成環，且$M = N-1$
每段行駛路線代表有一輛車在兩站之間的最短路徑來回發車
也就是說這段路上的任意兩站都是互通的，可以直接抵達不需轉車
現在$Q$位妹子來向你問路，問你能不能從某一站經過任意多次的轉車搭到另一站。
保證兩站不是同一站。
$K \leq N \leq 10^6, M = N-1, Q \leq 10^6$
Solution 每條行駛路線代表的就是在這條路徑上加值
而查詢到不到得了就是查詢路徑上有沒有$0$
可以採用輕重鏈剖分維護樹上路徑和
因為修改都在詢問之前，所以利用前綴和就好，不需要開線段樹
複雜度$\mathcal{O}(N + Q \log N)$
AC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 // __________________ // | ________________ | // || ____ || // || /\ | || // || /__\ | || // || / \ |____ || // ||________________|| // |__________________| // \###################\ // \###################\ // \ ____ \ // \_______\___\_______\ // An AC a day keeps the doctor away.</description></item><item><title>TIOJ-2124</title><link>https://omeletwithoutegg.github.io/2020/02/22/tioj-2124/</link><pubDate>Sat, 22 Feb 2020 20:04:25 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2020/02/22/tioj-2124/</guid><description>殿壬看蝴蝶 https://tioj.ck.tp.edu.tw/problems/2124
Description 太長了，略
Solution 看到第五種操作就會想用平衡樹去寫這題
然後仔細看看就會發現第八種操作其實和其他操作都沒什麼關係，只有第三、四種操作會改變以蝴蝶編號為順序的區間和
所以呢對蝴蝶的編號開一個線段樹、對樹的編號開個Splay就能AC了
Splay只需要實現查一個節點在中序是第個、查中序第k個節點是什麼，還有剪切區間
至於區間和就隨便維護吧XD，code如下，我不知道該對裸題做甚麼解釋
寫剪切區間的splay的時候要注意的可能就是不要改到空節點(我是用0代表空節點)的任何值
也小心不要讓合併的時候合併到同一棵splay，出現環
中途有一次一個回傳int的函數忘記回傳東西，在TIOJ上吃SF
AC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; const int N = 200025; int n, q, v[N]; struct SplayTree { struct node { int val, sz; int sum; int ch[2], pa; //bool rev; } S[N]; bool dir(int i) {return i==S[S[i].</description></item><item><title>TIOJ-1202</title><link>https://omeletwithoutegg.github.io/2020/02/09/tioj-1202/</link><pubDate>Sun, 09 Feb 2020 11:37:43 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2020/02/09/tioj-1202/</guid><description>重疊的天際線 https://tioj.ck.tp.edu.tw/problems/1202
Description 地平線上有許多房子，而這些房子在夕陽的照射之下形成有趣的輪廓，我們稱之為天際線(Skyline)。為了方便起見，你可以假設所有的房子都是一個位在2D平面上的矩形，並且有一條邊貼在這個假想2D平面上的X軸。
一棟建築可以用三元數組$(L_i, H_i, R_i)$來表示，依序代表該建築物的左界座標、高度、右界座標。
下圖中的八棟建築就是用此方法表示就是
$(1,11,5), (2,6,7), (3,13,9), (12,7,16), (14,3,25), (19,18,22), (23,13,29), (24,4,28)$。
一個天際線也可以用類似的「X-遞增序列」表示出來，例如上面的八棟建築合併之後上方右圖的天際線可表示為：
$(1, 11, 3, 13, 9, 0, 12, 7, 16, 3, 19, 18, 22, 3, 23, 13, 29, 0)$
請你寫一個程式，給你這些房子的位置，請你把它們形成的天際線描述出來。
對於每一筆測試資料，請按照題目以及範例輸出格式輸出天際線的樣子。
請注意，最後一個數字一定是0。也請不要輸出多餘空白。
Solution 考慮所有矩形的邊界上的點，我們只要確定這些點的最大高度就能夠描述這個天際線
更進一步的話題目要求的格式甚至只需要考慮左界這個點
因此我們維護一個 multiset
從左到右考慮所有邊界，對於任一個建築物的高度$H$，都在$L$的時候加進 multiset 裡面然後在$R$的時候刪掉
如果這個點的高度和前一次的答案一樣就不需要加進答案裡面
注意輸出格式QQ，一開始還吃WA好幾次
AC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include &amp;lt;bits/stdc++.</description></item><item><title>TIOJ-1168</title><link>https://omeletwithoutegg.github.io/2020/01/25/tioj-1168/</link><pubDate>Sat, 25 Jan 2020 21:20:17 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2020/01/25/tioj-1168/</guid><description>進階的入門 https://tioj.ck.tp.edu.tw/problems/1168
Description 你需要實作五個函式：
1 2 3 4 5 void pop_big(); void pop_small(); void push(int s); int big(); int small(); 其中第一個函式需要將最大的數字移除，第二個函式需要將最小的數字移除，第三個函式需要將一個數加入目前的數字們，第四個函式需要回傳當前的最大值，第五個函式需要回傳當前的最小值。
假設一開始沒有任何數字，請你實作這五個操作。
保證當沒有數字的時候只會呼叫 push ，並且加入的數字 $\leq 10^9$ ，五個函數的總呼叫次數 $\leq 10^6$ 。
Solution 好久之前就一直卡這題總算AC了@_@
最直覺的想法就是開一個multiset或map，但這題的時限超誇張的緊
可以想到利用 priority_queue 維護最大最小
然而假如一個數字在最大堆被pop掉，不容易在最小堆裡面把他給刪除
我一開始的想法是開 unordered_map 之類的紀錄每個數字的個數，想當然而吃了TLE
後來查了解才發現紀錄插入編號並且維護編號幾的被 pop 了就可以
於是我就在 priority_queue 裡面存編號，並且自己寫compare函式
不過這樣寫的locality很差，似乎會讓常數暴增
改成用struct包住之後剩下最後兩筆TLE，試了好久之後才想到 priority_queue 是用 vector 實作，動態開的空間顯然會浪費很多常數，不如自己靜態開一個大陣列
注意到 pop 操作最多就是呼叫次數的一半，所以 heap 只要開 5e5 就好了， push 的時候多出去的可以直接丟掉
至於 popped 陣列應該還是要開到 1e6 ，因為被 pop 的東西有可能編號很大，TIOJ上的測資似乎沒考慮到這個地方所以開 5e5 也能AC</description></item><item><title>TIOJ-1408</title><link>https://omeletwithoutegg.github.io/2020/01/14/tioj-1408/</link><pubDate>Tue, 14 Jan 2020 21:06:04 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2020/01/14/tioj-1408/</guid><description>我很忙 https://tioj.ck.tp.edu.tw/problems/1408
Description 給定$n$個時段$[l_i, r_i)$
問至少有多少單位時間要是忙碌的才能滿足
「每個時段中都有至少$c_i$單位時間是忙碌的」(每單位時間都不是忙碌就是空閒)
註: 題目保證有解
Solution 看到這種很多區間的題目，就會很想把它們照右界從小到大排序
可以想到一個greedy策略
按右界遞增排序好之後，遇到一個時段就看是否已經滿足條件
如果已經滿足了就跳過
如果還沒有的話就必須選一些時間由空閒變為忙碌，而這些時間依照貪心的原則是從越右邊開始選越好
(選左邊的不會對之後右界更大的時段有比較多幫助)
檢查是否滿足條件只要維護區間和
於是我的作法是用一棵線段樹配上一個 stack
每次新插入一個時段，先以線段樹查詢這個區間內忙碌的時間總共是多少
接著對於剩下需要再增加的時間，維持 stack 內是不相交且排序好的一些時段，代表那些時間必須要是忙碌的
只要看目前最右邊的忙碌時段就能處理好
這份AC code中我沒有值域壓縮(因為我懶)
一臉在CF上欠hack
AC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 #include &amp;lt;bits/stdc++.</description></item><item><title>TIOJ-1739</title><link>https://omeletwithoutegg.github.io/2019/12/11/tioj-1739/</link><pubDate>Wed, 11 Dec 2019 15:26:33 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2019/12/11/tioj-1739/</guid><description>[APIO &amp;lsquo;08] Beads [Interactive] https://tioj.ck.tp.edu.tw/problems/1739
Description 有一個長度$n$的序列$a$，一開始$a_i = i$
接下來有$m$個操作，每個操作只會交換相鄰的兩個數字
接著有$q$個詢問，每次會詢問：第$t$個操作之後，數字$x$被放到哪個位置？
$n,m,q \leq 3 \times 10^5; 1 \leq x \leq n; 1 \leq t \leq m$
Solution 對序列保存不同的版本，當然持久化資料結構砸下去就對啦
是說本來想寫treap不過我實作能力好差QQ
什麼？你想問什麼是持久化？
反正就是用樹來存一個序列啦，然後因為改一個數字時只要改他到根的那條鏈就好了啦，這樣每次修改新增的點數會和樹高一樣
AC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 // __________________ // | ________________ | // || ____ || // || /\ | || // || /__\ | || // || / \ |____ || // ||________________|| // |__________________| // \###################\ // \###################\ // \ ____ \ // \_______\___\_______\ // An AC a day keeps the doctor away.</description></item><item><title>Iterative-SegmentTree</title><link>https://omeletwithoutegg.github.io/2019/12/07/iterative-segmenttree/</link><pubDate>Sat, 07 Dec 2019 20:48:20 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2019/12/07/iterative-segmenttree/</guid><description>迭代式線段樹 先備知識: 線段樹(帶懶標) + 位元運算(吧)
如果讀者還不知道線段樹的原理最好看遞迴的(?)
單點修改 例題仍然是萬年RMQ
給定一個長度$n$的序列，請支援以下操作
將位置$p$的值改為$x$ 查詢區間$[l,r)$的最大值 完美二元樹 首先假定$n$是2的冪次，思考可能可以簡單一些
我們一樣用1當根，並且節點i的左右子樹會是i*2和i*2+1或寫成i&amp;lt;&amp;lt;1, i&amp;lt;&amp;lt;1|1
1 2 const int N = 1&amp;lt;&amp;lt;18; int tr[N&amp;lt;&amp;lt;1], n; 對於初始化來說，可以發現葉子節點對應的都是長度$1$的區間，正好是原序列的值，所以可以直接讀入或另外傳入賦值給 tr[i+n]，接著可以用遞減的順序把其他長度的區間的答案算好
1 2 3 4 void build(int v[]) { for(int i = 0; i &amp;lt; n; i++) tr[i+n] = v[i]; for(int i = n-1; i &amp;gt; 0; i--) tr[i] = max(tr[i&amp;lt;&amp;lt;1], tr[i&amp;lt;&amp;lt;1|1]); } 更新一個節點$p$，那麼只有$p$的所有祖先的答案會被影響到
注意 p^1 代表 p 的兄弟節點，也就是 p 父親的另一個兒子
1 2 3 4 void modify(int p, int x) { for(tr[p+=n] = x; p &amp;gt; 1; p&amp;gt;&amp;gt;=1) tr[p&amp;gt;&amp;gt;1] = max(tr[p],tr[p^1]); } 至於區間的查詢就沒有那麼顯然了，我們一樣必須把詢問的區間拆分成線段樹上的一些區間，而且數量不能超過$\mathcal{O}(\log n)$</description></item><item><title>TIOJ-1171</title><link>https://omeletwithoutegg.github.io/2019/12/04/tioj-1171/</link><pubDate>Wed, 04 Dec 2019 23:41:02 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2019/12/04/tioj-1171/</guid><description>我要成為海賊王 https://tioj.ck.tp.edu.tw/problems/1171
Description 給定一棵樹，一開始所有頂點都是白色的，有$q$次操作，每次操作可以把一個頂點塗成黑色，或者詢問某個頂點$x$到所有黑色頂點的距離和
Solution 可能算是經典題吧，這邊提供兩種寫法: 重心剖分和輕重鍊剖分
重心剖分 重心剖分的核心想法是樹分治，每次拔掉一個點，並統計有經過這個點的答案並遞迴計算沒經過該點的答案
為了確保複雜度，每次拔掉重心是一個好選擇
也許可以發現每個頂點都會當一次重心(?)
並且若把每次拔掉的重心$c$和分治下去的每個子樹找到的重心$c&amp;rsquo;$都連邊，也會是一棵樹，稱為重心樹
假設我要查詢$x$這個點，我們就枚舉$x$在重心樹上的祖先
對於所有黑色頂點$b$來說都可以找到恰一個祖先$c$使得$b,x$最後是被$c$分開的
可以想到紀錄$cnt_c, sum_c$分別代表分治到以$c$為重心的時候的子樹中，黑色節點的數量以及與$c$的距離和
加加減減就能得到答案了
算式好難推QQ去查了YP的題解才知道怎麼寫
記得在重心樹往上爬的時候必須減掉和下一層有關的一些東西，要避免有重複的邊的路徑被計算到
式子可能長得像這樣吧
$$
\sum _ {p\not=croot} sum_q + cnt_q \cdot path(q,x) - sum_p - cnt_p \cdot path(p,q)
$$
其中$q$是$p$在重心樹上的父節點
每次詢問的複雜度是重心樹的深度也就是$\mathcal{O}(\log n)$
輕重鍊剖分 用$b$和$B$代表黑色頂點和他們的集合，$dis_v$代表從根走到$v$的距離
把所求寫成
$$
\sum _ {b\in B} dis_x + \sum _ {b\in B} dis_b - 2\sum _ {b\in B} dis _ {LCA(b,x)} = |B|dis_x + \sum _ {b\in B}dis_b - 2 \sum _ {b\in B} dis _ {LCA(b,x)}</description></item><item><title>TIOJ-1282</title><link>https://omeletwithoutegg.github.io/2019/12/04/tioj-1282/</link><pubDate>Wed, 04 Dec 2019 09:31:16 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2019/12/04/tioj-1282/</guid><description>愛蜜利雅的作業2 https://tioj.ck.tp.edu.tw/problems/1282
Description 給定一個長度$n$的正整數序列，有$q$次操作，每次操作可能會對區間$[l,r]$加上$k$或詢問區間$[l,r]$的最大公因數
$1 \leq n,q \leq 10^5$
Solution 想法是利用區間加值等於對差分的兩個單點修改
然後有一個性質是 $\gcd(a,b) = \gcd(a-b,b)$
所以$[l,r]$區間的GCD會等於$\gcd(\gcd(a _ {l+1}-a_l, a _ {l+2}-a _ {l+1}, \dots, a_r-a _ {r-1}), a_r)$之類的
求$a_r$可以用BIT就好，前面那項我則是用線段樹維護
複雜度$\mathcal{O}(n\log c + q\log n \log c)$
注意算完GCD要加絕對值，因為差分會出現負數，此時__gcd可能回傳負數
AC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 // __________________ // | ________________ | // || ____ || // || /\ | || // || /__\ | || // || / \ |____ || // ||________________|| // |__________________| // \###################\ // \###################\ // \ ____ \ // \_______\___\_______\ // An AC a day keeps the doctor away.</description></item></channel></rss>