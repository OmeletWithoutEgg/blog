<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>TIOJ on 蛋餅的競程隨筆</title><link>https://omeletwithoutegg.github.io/tags/TIOJ/</link><description>Recent content in TIOJ on 蛋餅的競程隨筆</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>Omelet</copyright><lastBuildDate>Wed, 30 Dec 2020 12:57:24 +0800</lastBuildDate><atom:link href="https://omeletwithoutegg.github.io/tags/TIOJ/index.xml" rel="self" type="application/rss+xml"/><item><title>TIOJ 1597</title><link>https://omeletwithoutegg.github.io/2020/12/30/TIOJ-1597/</link><pubDate>Wed, 30 Dec 2020 12:57:24 +0800</pubDate><guid>https://omeletwithoutegg.github.io/2020/12/30/TIOJ-1597/</guid><description>變動的過路費 https://tioj.ck.tp.edu.tw/problems/1597
Description 給你一張有向圖，每個邊會有隨時間變動的權重，並且邊的權重對時間是一個線性函數。
再給你兩個點 $A,B$，現在你想要從 $A$ 走到 $B$ 再走回 $A$，
問你在時間 $[0, D-1]$ 中，最長的最短路徑和最短的最短路徑相差多少。
保證在時間內的邊權都是非負整數，並且答案不會超過long long。
Solution 這題很久以前就跟蕭梓宏討論過了，不過我怎麼寫都會吃WA 0分
今天#define int ll結果就拿了67分XD仔細檢查才發現原來一條邊的邊權可以不在int的範圍內但我卻用了int
忘記開long long真的Orz
因為線性函數的和還是線性函數，考慮所有的「路徑」，他們都代表一條對時間的線性函數。
而某個時間點的最短路徑就是這些直線的 $\min$。也就是說，所有時間點的最短路徑是所有路徑的線性函數的下凸包(lower envelope)
把這個凸包建出來似乎不是可行的（？）所以就考慮三分搜找出最大值。至於最小值一定是在端點，所以相減就是答案了。
好像有卡一些常數QQ我還得判如果dijkstra跑到終點就return、三分搜遇到相同就break;之類的，不知道是不是TIOJ主機變慢了QQ
AC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 #pragma GCC optmize(&amp;#34;Ofast&amp;#34;) #include &amp;lt;bits/stdc++.</description></item><item><title>TIOJ 1284</title><link>https://omeletwithoutegg.github.io/2020/12/23/TIOJ-1284/</link><pubDate>Wed, 23 Dec 2020 13:31:04 +0800</pubDate><guid>https://omeletwithoutegg.github.io/2020/12/23/TIOJ-1284/</guid><description>賽車問題 https://tioj.ck.tp.edu.tw/submissions/231136
Description 現在有 $n$ 輛往右邊跑的賽車，每一輛都有其固定的車速以及起始位置。
你想要知道在從現在開始的所有時刻中，什麼時候最領先的車子跟最落後的車子的距離會最短。
可以假設車速都不相同
Solution 首先每個車的位置對於時間是一個一次函數，而「每個時刻最前面的車的位置」和「每個時刻最後面的車的位置」就是這些直線形成的上下凸包（envelope）
這題可以用三分搜寫掉（？）
不過可以把凸包真的建出來做。最佳的答案一定會出現在凸包的頂點上，或是邊界（也就是時刻=0的時候）
於是建出來之後用雙指標依照x由小到大檢查上下凸包的距離就可以了，記得要處理邊界的case。
這樣雖然時間複雜度還是有 $\log$ ，不過是 sort 的 $\log n$。
AC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 #include &amp;lt;bits/stdc++.</description></item><item><title>TIOJ-1978</title><link>https://omeletwithoutegg.github.io/2020/11/22/TIOJ-1978/</link><pubDate>Sun, 22 Nov 2020 21:39:59 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2020/11/22/TIOJ-1978/</guid><description>邀請函（Invitation） https://tioj.ck.tp.edu.tw/problems/1978
Description 給你一張圖，求出最大點獨立集。
點數最多80
Solution 我本來一直以為這題是一般圖最大匹配，不過今天仔細看之後發現不是，而且一般圖沒有最大匹配=最小點覆蓋的結論。
不過有最大點獨立集$+$最小點覆蓋$=|V|$。
吳邦一教授講過關於最小點覆蓋的一個回溯法，於是我想說把他拿來用。
其實這個演算法也很簡單，就每次挑最大degree的點出來要選或者不選就好，這樣的話複雜度聽起來會是$\mathcal{O}(2^n)$之類的。
不過我們可以先做以下幾個處理(簡化)
1. degree 0的點直接拔掉。
2. degree 1的點，選他不如選他唯一的鄰居
3. 剩下假設最大的degree是2，那所有點的degree都是2了，也就是說是一堆環，可以判掉
於是乎我們只剩下最大degree至少是3的case了。
如果不選那個點的話，那他的鄰居都必須要選，可以列出遞迴式$T(n) = T(n-1) + T(n-4) + f(n)$，$n$代表還沒決定要不要選的點的數量，$f(n)$代表維護上面那些東西需要的時間。
解這個遞迴式可以直接DP，或是利用特徵方程式$\lambda^n = \lambda^{n-1} + \lambda^{n-4} \Rightarrow \lambda^4 - \lambda^3 - 1 = 0$，他最大的實根大約是1.38左右，所以我們dfs的複雜度最多是$\mathcal{O}(1.38^n f(n))$。用蠻naive的寫法$f(n)$會是$\mathcal{O}(n)$(我也不知道怎麼快速維護XD)，$n=80$代進去$80 \cdot 1.38^{80}$似乎幾乎是不行，不過不知道為什麼會AC而且竟然只輸BB跟塗大為的submission XD
寫完之後，身為admin看到幾乎所有人都是用random，心情很複雜(#
還有BB跟waynetuinfor的演算法似乎是轉成clique在做，不知道大學打ICPC有沒有機會搞懂。
AC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 // __________________ // | ________________ | // || ____ || // || /\ | || // || /__\ | || // || / \ |____ || // ||________________|| // |__________________| // \###################\ // \###################\ // \ ____ \ // \_______\___\_______\ // An AC a day keeps the doctor away.</description></item><item><title>TIOJ-1764</title><link>https://omeletwithoutegg.github.io/2020/05/12/TIOJ-1764/</link><pubDate>Tue, 12 May 2020 15:31:47 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2020/05/12/TIOJ-1764/</guid><description>Ch2. Section 9. 補魔力的條件 https://tioj.ck.tp.edu.tw/problems/1764
Description 現在有排成一直線的$N$個格子，從左到右編號為$1 \dots N$，每個格子都有自己的高度
一開始你站在第一格，每次移動都只能往編號大的格子跳，目標是走到第$N$格
假設第$i$個格子的高度是$x_i$，從格子$i$跳到格子$j$需要耗費$\max(0, (j-i)+(x_j-x_i))$的力氣
請問在花最少力氣到達終點的前提下，他最多可以跳幾次?
Solution 先考慮最小化力氣
令$x_i+i = v_i$，簡單的列出DP式
$$
dp[i] = \min _ {j &amp;lt; i}(dp[j] + \max(0,v_j-v_i))
$$
這樣的複雜度是$\mathcal{O}(N^2)$
不過可以分case討論
$$
dp[i] = \min(
\min _ {j &amp;lt; i \wedge v_j \geq v_i}(dp[j]+v_j)-v_i,
\min _ {j &amp;lt; i \wedge v_j &amp;lt; v_i}(dp[j])
)
$$
就可以用資料結構$\mathcal{O}(N \log N)$維護了
那麼最多可以跳的次數也可以一邊維護
也就是說如果力氣不同就選力氣小的，力氣相同則選跳的次數多的，可以直接用pair做就好
這邊寫的是值域壓縮之後用BIT維護前後綴min OAO
AC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #pragma GCC optimize(&amp;#34;Ofast&amp;#34;) #pragma loop_opt(on) #include &amp;lt;bits/stdc++.</description></item><item><title>TIOJ-1633</title><link>https://omeletwithoutegg.github.io/2020/05/08/TIOJ-1633/</link><pubDate>Fri, 08 May 2020 13:43:30 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2020/05/08/TIOJ-1633/</guid><description>序列維護問題 https://tioj.ck.tp.edu.tw/problems/1633
Description 有一個由1到N的數字排成的序列。
可是你對於現在這個排列很不滿意，決定透過一些操作改變這個序列。
你現在有兩種操作：
REV L R ：把L到R所有數字反轉順序，例如1 2 3 4變成4 3 2 1
SWAP L1 R1 L2 R2：把L1到R1所有數字跟L2到R2所有數字交換位置，但順序不變。
你總共進行了M次操作，請輸出最後序列的樣子。
Solution 平衡二元樹裸題，我用的是Treap
要反轉的話可以打懶標(?)然後記得push
AC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 #pragma GCC optimize(&amp;#34;Ofast&amp;#34;) #pragma loop_opt(on) #include &amp;lt;cstdio&amp;gt;#include &amp;lt;random&amp;gt; const int N = 130025; inline char readchar() { constexpr int B = 1&amp;lt;&amp;lt;20; static char buf[B], *p, *q; if(p == q &amp;amp;&amp;amp; (q=(p=buf)+fread(buf,1,B,stdin)) == buf) return EOF; return *p++; } inline int nextint() { int x = 0, c = readchar(); while(c &amp;lt; &amp;#39;0&amp;#39;) c = readchar(); while(c &amp;gt;= &amp;#39;0&amp;#39;) x=x*10+(c^&amp;#39;0&amp;#39;), c=readchar(); return x; } inline void readuntil(char *s, char esc = &amp;#39;\n&amp;#39;) { char c = readchar(); while(c !</description></item><item><title>TIOJ-1039</title><link>https://omeletwithoutegg.github.io/2020/05/06/TIOJ-1039/</link><pubDate>Wed, 06 May 2020 16:36:03 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2020/05/06/TIOJ-1039/</guid><description>B.魔術數字 https://tioj.ck.tp.edu.tw/problems/1039
Description 超級長orz
總之名次的比較是看勝率，勝率的定義是「勝場數/(勝場數+敗場數)」
而兩隊魔術數字$M$的定義如下：
假設A隊的勝率領先B隊，只要A隊再贏除了B隊以外的隊伍$M$場，就算$B$隊剩下的所有場次都贏也不能得到和A相等的勝率
假設$M$大於A隊對上除了B隊以外的隊伍剩下的場次，那我們說A隊對B隊的魔術數字尚未點亮
否則我們說A隊對B隊的魔術數字是$M$
如果$M$歸零的話，表示A隊不管怎麼樣名次都會超過B隊
對於每一筆測試資料，請輸出一排版過的戰績表。依n支球隊的戰績排名順序輸出n行。除了第1名球隊以外，若發生勝率相同的情形，請依球隊在原資料的出現順序為輸出順序，但其排名則應並列。格式請參考範例輸出。隊名，勝率，魔術數字分別以一個空格來間隔，而隊名部分不足9個字元的部分則需填入空格。勝率固定輸出到小數點後三位(四捨五入)。第一名球隊不需要輸出魔術數字，請你分別計算出第一名球隊對其他球隊的魔術數字。若對其他球隊的魔術數字尚未點亮，請輸出--。若魔術數字已點亮，則輸出M以及該數字。測試資料之間請留一個空行。
Solution 呃&amp;hellip;就是一大堆噁心輸出
注意勝率的定義不包括和局QQ
計算魔術數字的方法就是用while迴圈一直加，跑到在題敘指定的情況下A隊的勝率會大於B隊的勝率
噢名次的地方也是要注意QQ很容易沒注意就寫錯
還有他的空行是在測試資料之間(?)雖然我不知道有沒有差啦
AC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include &amp;lt;cstdio&amp;gt;#include &amp;lt;cmath&amp;gt;#include &amp;lt;algorithm&amp;gt;struct Team { char name[10]; int W, T, L, id; double rate; friend bool operator&amp;lt;(const Team &amp;amp;a, const Team &amp;amp;b) { return a.</description></item><item><title>TIOJ-1404</title><link>https://omeletwithoutegg.github.io/2020/05/04/TIOJ-1404/</link><pubDate>Mon, 04 May 2020 21:05:10 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2020/05/04/TIOJ-1404/</guid><description>照亮的山景 https://tioj.ck.tp.edu.tw/problems/1404
Description 在一片山的上空，高度為$T$處有$N$個處於不同水平位置的燈泡，如上圖所示。
如果山的邊界上某一點與第$i$盞燈的連線不經過任何山稜線上的一點，我們稱第$i$盞燈可以照亮該點。
請問在所有$M$盞燈中，至少要打開幾盞燈，才能照亮山上每一個轉折點，或者打開所有的燈也無法照亮所有轉折點？
$1 \leq M, N \leq 10^5$
所有座標的絕對值小於$10^5$
Solution 發現到每個燈泡可以照到的範圍可能會長的非常奇怪
於是我們轉換思維，考慮每個轉折點如果要被照到要有什麼條件
可以發現，對於每個轉折點來說有一個區間，只要區間內有一個燈泡有開，這個轉折點就會被照到
找出那些區間之後這題就是經典的greedy題目了（按照右界由小到大，有拿過的跳過沒拿過的拿右界那個點）
那麼要怎麼找出這些區間呢？某個轉折點$p_i$對應的右界，正好是他和他右邊所有其他點所連出的射線中斜率最大者
維護一個上凸包能夠找到對應的那個點，再用直線求交點公式找出高度恰好是$T$的位置就好
左界也是同樣方式處理
因為題目給定的點已經幫我們排序好了，所以做凸包是$\mathcal{O}(M)$，而greedy的部分也可以做到$\mathcal{O}(N)$不過我這邊是放了$\mathcal{O}(N\log N)$的，因為找到交點之後必須二分搜求出到底涵蓋了哪些燈泡
總複雜度是$\mathcal{O}((M+N)\log N)$
AC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 #include &amp;lt;bits/stdc++.</description></item><item><title>TIOJ-1628</title><link>https://omeletwithoutegg.github.io/2020/05/03/TIOJ-1628/</link><pubDate>Sun, 03 May 2020 15:02:18 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2020/05/03/TIOJ-1628/</guid><description>組合布丁 https://tioj.ck.tp.edu.tw/problems/1628
Description 記得在快樂暑假營開始前，你曾經說過：「只要我有一次比賽沒有破台，就要請全快樂營的人吃布丁。」
好吧，蚯蚓太威了，你終究是沒有破台。
根據小道消息，你得知了這次的快樂暑假營總共有 $n$ 個人報名，
但是實際上會出席的只有 $k$ 個人，因此你只要請 $k$ 個人吃布丁就好。
而報名的第 $i$ 個人只會願意吃 $t_i$ 口味的布丁(用一個 int 範圍內的整數表示)。
假設你不確定究竟誰會出席，那有幾種不同的布丁組合可能會出現在你的採買清單上 ?
喔對了，因為答案可能太大了，所以你決定只要知道答案除以 $M$ 的餘數就好。
輸入包含多筆測資
$$
1 \leq n, k \leq 5000, 1 \leq M &amp;lt; 2^{31}
$$
Solution 兩種布丁組合不同，若且唯若某一種布丁的數量不同
因此我們枚舉每個布丁的數量去做計數背包就好了
可以用前綴和甚至FFT加速(?)不過FFT應該不會比較快www
AC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include &amp;lt;bits/stdc++.</description></item><item><title>TIOJ-1861</title><link>https://omeletwithoutegg.github.io/2020/05/01/TIOJ-1861/</link><pubDate>Fri, 01 May 2020 21:10:56 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2020/05/01/TIOJ-1861/</guid><description>蘿莉切割問題 https://tioj.ck.tp.edu.tw/problems/1861
Description 請你把一個數字$L$切成$a_1, a_2, \dots, a_n$
切一個數字$x$的代價是$x$，可以把它切成$b, x-b$兩個數字
找出最小的代價
Solution 霍夫曼編碼XD老題目
把切割的過程看成一個二元樹，每個$a_i$都代表一個葉子
其餘的節點代表合併中會出現的數字(?)
那麼總代價就是所有葉子的權重乘上各自的深度的和
我們想要讓這個代價越小越好
可以發現，在最優解$T$中：
沒有節點只有一個兒子，只要不是葉子的節點都恰好有兩個子節點
深度最大的那層節點一定是權重最小的，否則可以直接交換得到更優解
由上面兩點可以發現，權重最小的兩個節點一定都在最深的那一層
並且可以在不影響代價的情況下交換節點使得最小的兩個節點互為兄弟
結論是：每次把最小和次小的節點合併成一個節點，一定可以得到最佳解
(QQ我覺得我不會查也不會寫證明)
要怎麼維護所有節點的最小和次小呢？用一個heap就可以啦
AC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std; const int N = 100025; #define int ll int v[N]; signed main() { ios_base::sync_with_stdio(0), cin.</description></item><item><title>TIOJ-1629</title><link>https://omeletwithoutegg.github.io/2020/02/29/TIOJ-1629/</link><pubDate>Sat, 29 Feb 2020 00:09:33 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2020/02/29/TIOJ-1629/</guid><description>快樂規劃路徑 https://tioj.ck.tp.edu.tw/problems/1629
Description 樹朋友們生活在一個湖邊，湖邊的樹依照順時針方向編號為$1, 2, \dots n$。
他們想要讓自己更快樂，所以發明了一種娛樂方式，就是找到一條路徑遍歷全部$n$棵樹剛好一遍。
要從A樹到B樹唯一的方法就是架一條很長的梯子直直伸過去。
可是當然不是任何兩棵樹都可以架梯子，所以他們會先把所有可能架梯子的樹對(沒有錯字!)給你。
當然，(A,B)表示A可以到B、B也可以到A。
但是給定的遊歷路徑不能出現任兩條梯子交叉，不然可能會讓想要快樂的樹朋友發生危險。
例如上圖粗線所示就是一個合法的快樂路徑。
給你樹的個數以及樹對，請輸出一組快樂路徑。
若有很多組解，樹朋友希望看到字典順序最小的那一組。
$5 \leq n \leq 1000$
Solution 由不能交叉的條件可以推出，在某個時刻已經遍歷過的點一定是環上的一個連續區間
所以可以2D/0D的區間DP，並記錄最小的轉移來源
我的dp$[i][L][0]$代表的是現在站在$i$，往順時鐘方向的$L$個都已經遍歷過了，$dp[i][L][1]$也相似只是換成逆時鐘
因為實在想不到更好的實作方式所以寫的有夠醜，但是只要好好選到最小的轉移來源就會是字典序最小的路徑了
AC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 #include &amp;lt;bits/stdc++.</description></item><item><title>TIOJ-1505</title><link>https://omeletwithoutegg.github.io/2020/02/27/TIOJ-1505/</link><pubDate>Thu, 27 Feb 2020 12:28:06 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2020/02/27/TIOJ-1505/</guid><description>Assssss!! https://tioj.ck.tp.edu.tw/problems/1505
Description 現在有一個正整數構成的除法數列
$
x_1 / x_2 / x_3 / \dots / x_n
$
請問是否有一種加上括號的方法使得最後運算的結果是整數?
$2 \leq n \leq 10^5, 1 \leq x_i \leq 10^9$
Solution 加上括號之後每個數字會被放到分母或分子，想當然而放在分子的數字越多越好
可以發現$x_2$會恰好被放到分母一次，因此在最後他一定是當分母的
而我們可以構造出一個方法讓除了$x_2$最後當分母以外，其他數字都當分子
$$
(x_1 / (((x_2 / x_3) / x_4) / x_5 \dots)) = \frac{x_1 x_3 x_4 x_5 \dots x_n}{x_2}
$$
由於$x_2$最後一定會待在分母，只要檢查其他數字的乘積是否可以被$x_2$整除就好了
記得 long long 的問題
AC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include &amp;lt;cstdio&amp;gt; inline char readchar() { constexpr int B = 1&amp;lt;&amp;lt;20; static char buf[B], *p, *q; if(p == q &amp;amp;&amp;amp; (q=(p=buf)+fread(buf,1,B,stdin)) == buf) return EOF; return *p++; } inline int nextint() { int x = 0, c = readchar(); while(c &amp;lt; &amp;#39;0&amp;#39;) c = readchar(); while(c &amp;gt;= &amp;#39;0&amp;#39;) x=x*10+(c^&amp;#39;0&amp;#39;), c=readchar(); return x; } signed main() { int t = nextint(); while(t--) { int n = nextint(); int res = nextint(), mod = nextint(); for(int i = 2; i &amp;lt; n; i++) res = 1LL * res * nextint() % mod; puts(res ?</description></item><item><title>TIOJ-1219</title><link>https://omeletwithoutegg.github.io/2020/02/25/TIOJ-1219/</link><pubDate>Tue, 25 Feb 2020 09:55:02 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2020/02/25/TIOJ-1219/</guid><description>發糖果囉 https://tioj.ck.tp.edu.tw/problems/1219
Description 求符合$1 \leq x \leq n, 1 \leq y \leq m$且$x,y$的最大公因數是$g$的數對有多少對
有多筆測試資料，$1 \leq n, m, g \leq 50000$
Solution 莫比烏斯反演
lemma $$
\sum_d \mu(d) [d | x] = [x = 1]
$$
拿來簡化 $[\gcd(i,j)=1]$ 的部分，再想辦法換一下$\sum$的位置
$$
\begin{align*}
\sum _ {i=1}^n \sum _ {j=1}^m [\gcd(i, j) = g] &amp;amp;= \sum _ {i=1}^{\lfloor n/g \rfloor} \sum _ {j=1}^{\lfloor m/g \rfloor} [\gcd(i, j) = 1]\newline
\sum _ {i=1}^N \sum _ {j=1}^M [\gcd(i, j) = 1] &amp;amp;= \sum _ {i=1}^N \sum _ {j=1}^M \sum_d \mu(d) \cdot [d | \gcd(i, j)]\newline</description></item><item><title>TIOJ-2140</title><link>https://omeletwithoutegg.github.io/2020/02/25/TIOJ-2140/</link><pubDate>Tue, 25 Feb 2020 09:09:25 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2020/02/25/TIOJ-2140/</guid><description>殿壬愛序列 https://tioj.ck.tp.edu.tw/problems/1102
Description 給你一個長度為$N$的序列$a_1, a_2, \dots, a_N$，並且依序執行$Q$個操作，每個操作可能是
1 x y ：把$a_x$設成$y$
2 L R k ：對於每個$i \in [L, R]$，把$a_i$設成$\lfloor \frac{a_i}{k} \rfloor$。其中$\lfloor x \rfloor$代表不大於$x$的最大整數
3 L R ：請輸出$a_L, a _ {L+1}, \dots, a_R$的絕對眾數，如果絕對眾數不存在請輸出-1。一個數字若為$T$個數字的絕對眾數，代表這個數字至少在$T$個數字中出現$\lfloor \frac{T+2}{2} \rfloor$次。
$1 \leq N, Q \leq 10^5$
$1 \leq L \leq R \leq N$
$1 \leq x \leq N$
$0 \leq a_i, y \leq 10^9$
$1 \leq k \leq 10^9$</description></item><item><title>TIOJ-1102</title><link>https://omeletwithoutegg.github.io/2020/02/25/TIOJ-1102/</link><pubDate>Tue, 25 Feb 2020 08:33:26 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2020/02/25/TIOJ-1102/</guid><description>E.海賊王 https://tioj.ck.tp.edu.tw/problems/1102
Description 你是一位海賊，現在有$P$個敵人與$T$個寶藏等間距圍成一圓形
你必須決定一個發射砲彈的方式
砲彈會波及的範圍是圓形的，每次發射後範圍內的海賊會被殺死，寶藏也會被毀壞
剩下的會重整隊形，同樣等間距圍成一圓形，且半徑不變（炮彈可以波及的半徑大於他們圍成的圈的半徑）
檢查過船上的砲彈存量以後，你發現一次至少要炸死兩個敵方海賊（所以剩三個海賊的話一定要一次打死三個）
你決定寫個程式幫你計算最多可以拿到多少未被毀壞的寶藏
Solution 半徑根本就是垃圾資訊XDD
只要炸的到的範圍比圍成的圈的範圍還要大，每次炸的就是環上的一段區間
總之考慮海賊之間的間隙，本題等價於選取環上許多個不相鄰的間隙使得權重最大
那麼顯然就直接DP，只要記得考慮環形的問題就好
AC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 // __________________ // | ________________ | // || ____ || // || /\ | || // || /__\ | || // || / \ |____ || // ||________________|| // |__________________| // \###################\ // \###################\ // \ ____ \ // \_______\___\_______\ // An AC a day keeps the doctor away.</description></item><item><title>TIOJ-1798</title><link>https://omeletwithoutegg.github.io/2020/02/23/TIOJ-1798/</link><pubDate>Sun, 23 Feb 2020 11:34:03 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2020/02/23/TIOJ-1798/</guid><description>Can You Arrive? https://tioj.ck.tp.edu.tw/problems/1798
Description 地鐵有$N$個站，$M$條軌道，$K$段行駛路線
站與站之間使用軌道連接
保證軌道不會形成環，且$M = N-1$
每段行駛路線代表有一輛車在兩站之間的最短路徑來回發車
也就是說這段路上的任意兩站都是互通的，可以直接抵達不需轉車
現在$Q$位妹子來向你問路，問你能不能從某一站經過任意多次的轉車搭到另一站。
保證兩站不是同一站。
$K \leq N \leq 10^6, M = N-1, Q \leq 10^6$
Solution 每條行駛路線代表的就是在這條路徑上加值
而查詢到不到得了就是查詢路徑上有沒有$0$
可以採用輕重鏈剖分維護樹上路徑和
因為修改都在詢問之前，所以利用前綴和就好，不需要開線段樹
複雜度$\mathcal{O}(N + Q \log N)$
AC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 // __________________ // | ________________ | // || ____ || // || /\ | || // || /__\ | || // || / \ |____ || // ||________________|| // |__________________| // \###################\ // \###################\ // \ ____ \ // \_______\___\_______\ // An AC a day keeps the doctor away.</description></item><item><title>TIOJ-1129</title><link>https://omeletwithoutegg.github.io/2020/02/23/TIOJ-1129/</link><pubDate>Sun, 23 Feb 2020 11:26:04 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2020/02/23/TIOJ-1129/</guid><description>聚集問題 https://tioj.ck.tp.edu.tw/problems/1129
Description 給定二維平面上$N$個點，若編號$i,j$的點之間的距離不大於$C$則他們之間有連邊
問最後的連通塊數量以及每個連通塊的大小
Solution 我想不到比$\mathcal{O}(N^2)$枚舉直接連邊更好的解了XD
比起DFS我更喜歡用DSU因此code是DSU
AC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt; const int N = 4001; int s, n, r; std::pair&amp;lt;int,int&amp;gt; p[N]; int pa[N], sz[N]; std::vector&amp;lt;int&amp;gt; ans; int dis(std::pair&amp;lt;int,int&amp;gt; a, std::pair&amp;lt;int,int&amp;gt; b) {return (a.</description></item><item><title>TIOJ-2124</title><link>https://omeletwithoutegg.github.io/2020/02/22/TIOJ-2124/</link><pubDate>Sat, 22 Feb 2020 20:04:25 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2020/02/22/TIOJ-2124/</guid><description>殿壬看蝴蝶 https://tioj.ck.tp.edu.tw/problems/2124
Description 太長了，略
Solution 看到第五種操作就會想用平衡樹去寫這題
然後仔細看看就會發現第八種操作其實和其他操作都沒什麼關係，只有第三、四種操作會改變以蝴蝶編號為順序的區間和
所以呢對蝴蝶的編號開一個線段樹、對樹的編號開個Splay就能AC了
Splay只需要實現查一個節點在中序是第個、查中序第k個節點是什麼，還有剪切區間
至於區間和就隨便維護吧XD，code如下，我不知道該對裸題做甚麼解釋
寫剪切區間的splay的時候要注意的可能就是不要改到空節點(我是用0代表空節點)的任何值
也小心不要讓合併的時候合併到同一棵splay，出現環
中途有一次一個回傳int的函數忘記回傳東西，在TIOJ上吃SF
AC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 #include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstdlib&amp;gt; const int N = 200025; int n, q, v[N]; struct SplayTree { struct node { int val, sz; int sum; int ch[2], pa; //bool rev; } S[N]; bool dir(int i) {return i==S[S[i].</description></item><item><title>TIOJ-1884</title><link>https://omeletwithoutegg.github.io/2020/02/20/TIOJ-1884/</link><pubDate>Thu, 20 Feb 2020 23:53:21 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2020/02/20/TIOJ-1884/</guid><description>【IOI2015】Boxes 一堆盒子 https://tioj.ck.tp.edu.tw/problems/1884
Description 有$L$個地區排成一環狀，依序編號為$0, 1, \dots, L-1$
從任何一個地區移動到相鄰的地區所需要的時間均為一單位時間
現在有$N$個人需要寄送貨物，他們分別住在編號為$p_1, p_2, \dots, p_n$的地區(已經依非遞減順序排序)
貨物中心位在編號$0$的地區，並且郵差每次只能帶至多$K$件貨物移動
(世界上只有一個郵差&amp;hellip;真辛苦)
身上所有的貨物都送到後，必須回到$0$號地區，才能進行下一輪的送貨
你的任務就是幫送貨的郵差計算他最少要花多少時間
才能從貨物中心出發，寄送完所有貨物，最後再回到貨物中心
(其中可能會回貨物中心很多次以補充貨物)
$
1 \leq K \leq N \leq 10^7,
1 \leq L \leq 10^9,
0 \leq p_i &amp;lt; L
$
Solution 首先有$K=1$的Subtask，可以確定自己對題意的理解
可以發現題目就是要把這$N$個點分成很多堆，每堆不超過$K$個，使得總成本最小
一個關鍵的觀察是分的方式肯定是排序過後切成很多連續區間
不需要考慮$i &amp;lt; x &amp;lt; j$但$x$卻不和$i,j$同一堆的情形，否則可以想辦法交換一下使得答案不會變更差
至此可以列出DP式
$$
dp[i] = \min\limits _ {\max(0, i-k) \leq j &amp;lt; i} { dp[j] + cost(j+1, i) }
$$
其中$cost(l, r) = \min {L, 2p_r, 2(L-p_l)}$</description></item><item><title>TIOJ-1828</title><link>https://omeletwithoutegg.github.io/2020/02/20/TIOJ-1828/</link><pubDate>Thu, 20 Feb 2020 04:56:05 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2020/02/20/TIOJ-1828/</guid><description>控控控之蘿莉控 https://tioj.ck.tp.edu.tw/problems/1828
Description 你走在路上遇到了一個可愛小蘿莉，因為你的控屬性，所以你跑上去問了她的名字：「小妹妹～你叫什麼名字啊？」
她回答：「啊！！！你幹嘛！我不認識你啊你誰啊！！！」
你：「我是你的好哥哥，來和我一起玩吧～」
這時機智的小妹妹拿起手機打了110
你決定要趕快逃跑，以免進入暗無天日的深淵
於是問題來了！
你要跑多快才不會被抓(你只能跑整數的速度)？
因為警察的體力有限，不能跑超過警局外的$10000$單位距離，所以逃出$10000$單位距離就好了
第一行有一個整數$T$代表測資筆數，
每行有三個無號整數$X,Y,Z$
$X$代表你現在跟警察局的距離，
$Y$代表小妹妹跟警察叔叔還要在$Y$秒才會講完電話，
$Z$代表講完電話後警察會馬上用秒速$Z$的速度沖上來追你
$0 \leq X,Y,Z \leq 10^6$
如果講完電話後，你還待在警察局門口，是會被抓的喔
注意你站在距警察局恰$10000$單位距離的點上也還是會被抓的喔
請輸出ㄧ個整數代表你至少要用多少的體力才不會被追悼
如果不管怎麼樣都會被追到請輸出 -1
Solution 是個大特判題呢
唯ㄧ會出現 -1 的case就是$X=Y=0$的時候，也就是ㄧ開始就被追上
首先可以知道人和警察兩個直線的差會與時間成線性
所以最小的差肯定是出現在端點
我們僅需要考慮剛出發那一刻和警察跨過$10000$那一刻，是否有被警察超前過即可
假設$T$是距離講完電話過了$T$秒，並且逃跑的速度是$V$
那麼可以列出式子
$$
X + (Y+T)V &amp;gt; TZ
$$
當$T$是$0$，可以知道$V$的最小值不是$0$就是$1$，取決於$X,Y$是否為0
當警察跨過$10000$時，$T=10000/Z$，移項一下可以得到$V &amp;gt; \frac{(10000-X)Z}{YZ+10000}$
不過注意$Z$必須不為$0$，若$Z$為$0$可以直接特判掉
AC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #pragma g++ optimize(&amp;#34;Ofast&amp;#34;) #pragma loop_opt(on) #include &amp;lt;cstdio&amp;gt; typedef long long ll; const int L = 10000; int solve() { int x, y, z; scanf(&amp;#34;%d%d%d&amp;#34;, &amp;amp;x, &amp;amp;y, &amp;amp;z); if(x == 0 &amp;amp;&amp;amp; y == 0) return -1; if(x &amp;gt; L) return 0; if(!</description></item><item><title>TIOJ-1553</title><link>https://omeletwithoutegg.github.io/2020/02/19/TIOJ-1553/</link><pubDate>Wed, 19 Feb 2020 16:54:42 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2020/02/19/TIOJ-1553/</guid><description>B-Game https://tioj.ck.tp.edu.tw/problems/1553
Description B-Game是個殘酷的兩人卡片對戰遊戲(Battle Game)
檯面上有$n$張卡片，排成環狀，每張卡片有其數值
兩人輪流取卡片，只能選與已經取過的卡片相鄰的卡片，但第一個人不受此限
選完卡片之後，勝負決定在將兩人手中卡片的數值和
若某位玩家得分大於另一位玩家，無論大多少均是勝利
輸出一行包含兩個數
分別是一開始有幾種拿法可以讓先拿的人勝利
與先拿的人最多可以拿到多少
Solution 一開始我沒有注意到環型的條件，送了好多次假解XD
後面還忘記%n，WA到癱軟www
現在假設先手第一步取了某張卡
則剩下的卡片就是環上的一段連續區間，並且不管怎麼拿都會一直保持是連續區間
可以透過奇偶性知道最後一步輪到誰拿，且拿的位置肯定是區間的最左邊或是最右邊
而對手ㄧ定會讓自己分數最低，我們則是讓分數盡量高
因此可以列出簡單的2D/0D轉移式，得到每個區間可以從兩頭拿時先手的最高得分
再加上先手第一步取得的分數就可以知道從每個地方起手先手所能得到的最高分
也就知道在那個位置是否有機會勝利了
AC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include &amp;lt;cstdio&amp;gt; inline int min(int a, int b) {return a&amp;lt;b?a:b;} inline int max(int a, int b) {return a&amp;gt;b?</description></item><item><title>TIOJ-1274</title><link>https://omeletwithoutegg.github.io/2020/02/16/TIOJ-1274/</link><pubDate>Sun, 16 Feb 2020 21:07:18 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2020/02/16/TIOJ-1274/</guid><description> [純屬無聊] Tie Breaker https://tioj.ck.tp.edu.tw/problems/1274
Description 本題考驗你對小向的試煉題敘的理解程度。請回答以下三個問題：
假設2-2的圖來自遊戲「甲」(一個包含五個字母的單字)，2-3的圖來自動畫「乙」(一個包含九個字母的單字 ，請問甲和乙中字母e出現幾次？
假設3-1的圖來自動畫「丙」(包含四個中文字)，3-3的圖來自漫畫「丁」(包含六個中文字) ，請問丙和丁中聲調為二聲的字有幾個？
假設4-1的圖來自動畫「戊」(包含八個中文字，其中第五個字是三聲)，4-2的圖來自動畫「己」(包含四個中文字)，4-3的圖來自動畫「庚」(包含六個中文字) ，且令為己的前兩個字翻譯成英文後的字母數，為戊的第二個字所代表的數字 ，「辛」是「庚」的第一個字。請問「辛」倍的x+y是幾？
Solution 註: 小向的試煉是TIOJ上一系列的題目，可以自行搜尋
甲 = Deemo 乙 = charlotte
第一點的答案 = 3
丙 = 遊戲人生 丁 = 我的英雄學院
第二點的答案 = 4
戊 = 中二病也想談戀愛 己 = 東京闇鴉 庚 = 雙星之陰陽師
第三點的答案 = 2 * (5 + 2) = 14
這題是考驗油度或是google程度，不過casper用猜的猜出答案，好糟糕
AC code 1 2 3 4 5 6 #include &amp;lt;cstdio&amp;gt;int main() { int ans[4] = {-1, 3, 4, 14}, n; scanf(&amp;#34;%d&amp;#34;, &amp;amp;n); printf(&amp;#34;%d\n&amp;#34;, ans[n]); }</description></item><item><title>TIOJ-1511</title><link>https://omeletwithoutegg.github.io/2020/02/15/TIOJ-1511/</link><pubDate>Sat, 15 Feb 2020 13:25:59 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2020/02/15/TIOJ-1511/</guid><description>Problem A. 雷射防護網 https://tioj.ck.tp.edu.tw/problems/1511
Description 考慮在正$n$邊形的頂點中任選三點形成的三角形，請統計分別有幾個銳角三角形、直角三角形和鈍角三角形
注意：兩個三角形被視為不同的，若且唯若三個頂點的編號不完全相同，並且不可以旋轉三角形
$n \leq 10^6$
Solution 簡單排列組合，不過我寫好久還踩到一些坑
直角的case很容易解決，因為斜邊必須要是外接圓的直徑，故$n$得是偶數
而所有$n/2$條直徑對應的直角三角形個數就是$2(n/2-1)$
接著我們先計算鈍角的case
固定鈍角那個頂點，假設三個角的角度分別等於$a, b, c$個邊(因為是正多邊形所以可以這樣統計)，且$a &amp;gt; b,c$
那麼所有鈍角三角形的個數就等於$a+b+c = n$且$a &amp;gt; n/2$的正整數解的個數
此時枚舉$a$，$b+c=n-a$有$n-a-1$組正整數解，可以知道所求即是
$$
\sum _ {a = \left \lfloor n/2 \right \rfloor + 1} ^ {n-2} n-a-1 = \sum _ {i=1}^{n-2 - \left \lfloor n/2 \right \rfloor} i = \frac{(n-2 - \left \lfloor n/2 \right \rfloor) (n-2 - \left \lfloor n/2 \right \rfloor + 1)}{2}</description></item><item><title>TIOJ-1202</title><link>https://omeletwithoutegg.github.io/2020/02/09/TIOJ-1202/</link><pubDate>Sun, 09 Feb 2020 11:37:43 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2020/02/09/TIOJ-1202/</guid><description>重疊的天際線 https://tioj.ck.tp.edu.tw/problems/1202
Description 地平線上有許多房子，而這些房子在夕陽的照射之下形成有趣的輪廓，我們稱之為天際線(Skyline)。為了方便起見，你可以假設所有的房子都是一個位在2D平面上的矩形，並且有一條邊貼在這個假想2D平面上的X軸。
一棟建築可以用三元數組$(L_i, H_i, R_i)$來表示，依序代表該建築物的左界座標、高度、右界座標。
下圖中的八棟建築就是用此方法表示就是
$(1,11,5), (2,6,7), (3,13,9), (12,7,16), (14,3,25), (19,18,22), (23,13,29), (24,4,28)$。
一個天際線也可以用類似的「X-遞增序列」表示出來，例如上面的八棟建築合併之後上方右圖的天際線可表示為：
$(1, 11, 3, 13, 9, 0, 12, 7, 16, 3, 19, 18, 22, 3, 23, 13, 29, 0)$
請你寫一個程式，給你這些房子的位置，請你把它們形成的天際線描述出來。
對於每一筆測試資料，請按照題目以及範例輸出格式輸出天際線的樣子。
請注意，最後一個數字一定是0。也請不要輸出多餘空白。
Solution 考慮所有矩形的邊界上的點，我們只要確定這些點的最大高度就能夠描述這個天際線
更進一步的話題目要求的格式甚至只需要考慮左界這個點
因此我們維護一個 multiset
從左到右考慮所有邊界，對於任一個建築物的高度$H$，都在$L$的時候加進 multiset 裡面然後在$R$的時候刪掉
如果這個點的高度和前一次的答案一樣就不需要加進答案裡面
注意輸出格式QQ，一開始還吃WA好幾次
AC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include &amp;lt;bits/stdc++.</description></item><item><title>TIOJ-1156</title><link>https://omeletwithoutegg.github.io/2020/02/08/TIOJ-1156/</link><pubDate>Sat, 08 Feb 2020 12:29:14 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2020/02/08/TIOJ-1156/</guid><description> 5.高中運動會 https://tioj.ck.tp.edu.tw/problems/1156
Description 夢幻城市每年為全市高中生舉辦一次運動大會。為促進各校同學之間的交流，採用特別的分隊方式：每一個學校的同學，必須被均勻分散到各隊，使得每一隊中該校的人數皆相同。為增加比賽的競爭性，希望分成越多隊越好。你的任務是由各校的人數，決定最多可分成的隊數。
Solution 沒想到全國賽竟然有這麼水的題目XDD，題目所求就是所有學校人數的最大公因數
用 __gcd 就足夠了，不過我覺得這份code寫起來很簡短所以我想貼出來ouo，順便加了個輸入優化
AC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include &amp;lt;cstdio&amp;gt; inline char readchar() { constexpr int B = 1&amp;lt;&amp;lt;20; static char buf[B], *p, *q; if(p == q &amp;amp;&amp;amp; (q=(p=buf)+fread(buf,1,B,stdin)) == buf) return EOF; return *p++; } inline int nextint() { int x = 0, c = readchar(); while(c &amp;lt; &amp;#39;0&amp;#39;) c = readchar(); while(c &amp;gt;= &amp;#39;0&amp;#39;) x=x*10+(c^&amp;#39;0&amp;#39;), c=readchar(); return x; } int gcd(int a, int b) { while(int t = b) b = a%b, a = t; return a; } signed main() { int n = nextint(), g = 0; while(n--) g = gcd(g, nextint()); printf(&amp;#34;%d\n&amp;#34;, g); }</description></item><item><title>TIOJ-1600</title><link>https://omeletwithoutegg.github.io/2020/01/26/TIOJ-1600/</link><pubDate>Sun, 26 Jan 2020 22:51:53 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2020/01/26/TIOJ-1600/</guid><description>爆炸吧現充~ https://tioj.ck.tp.edu.tw/problems/1600
Description 求共有幾個滿足
$$
1 \leq x \leq n,
\exists k &amp;gt; 1, k^2 | x
$$
的$x$
Solution 一開始我的想法是$[\mu(x)=0]$的前綴，想說用杜教篩或莫比烏斯反演什麼的，但怎麼推都推不出來
去問王政祺之後，他說直接枚舉平方數再排容就好，至於排容的係數就直接取$\mu$
令
$$
S_k = \{x | 1 \leq x = k^2t \leq n\}
$$
則答案就是
$$
\begin{matrix}
|\bigcup _ {k} S_k| &amp;amp;= &amp;amp; (|S_2| + |S_3| + |S_5| + |S_7| + \cdots)\newline
&amp;amp;- &amp;amp; (|S_6|+|S _ {10}|+|S _ {14}|+|S _ {15}|+ \cdots)\newline
&amp;amp;+ &amp;amp; (|S _ {30}|+|S _ {42}|+|S _ {66}|+|S _ {70}|+ \cdots)\newline</description></item><item><title>TIOJ-1283</title><link>https://omeletwithoutegg.github.io/2020/01/25/TIOJ-1283/</link><pubDate>Sat, 25 Jan 2020 23:37:00 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2020/01/25/TIOJ-1283/</guid><description>&amp;lt;! &amp;ndash; ### Author: Sean Liu &amp;ndash;&amp;gt;
超大畫框設置 https://tioj.ck.tp.edu.tw/problems/1283
Description 在一個「漸進式框架」當中，你想要找到一個最大面積的矩形位置放置你最喜愛的一幅畫。
當然地，畫框必須掛正，所以矩形的四個邊都必須與框架的邊平行或垂直。
所謂的「漸進式框架」，指的是任何一個水平線截出的框架區段是連續，並且由上往下該區段只會往右移動，如下圖
Solution 這個是蕭梓宏在超級久之前講的四邊形優化題目，筆者發現已經過了一年多了還沒AC就想說來寫看看好了！這一題不難想到，對於每一個在下面的線，都計算是哪一條在上面的線和它搭配會有最佳，再取$\max$就好了。不過，這樣需要$O(MN)$的時間，頗爛。
不過呢，還可以觀察（且證明）一個性質，就是：倘若$L(x)$為下面的線中第$x$條線所對應到的最佳（面積最大）的上面的線的編號，則$L(x + 1) \geq L(x)$！有了這個性質，大概就可以維護一個deque，裡面放一堆東西$(L, R, I)$來維護說：上面第$I$條線可以轉移下面第$L$到第$R$的線為最佳。一開始只有一個$(0, M, 0)$，然後每次進來一個上面的線段就開始判斷（假設目前deque中最後面的元素為$(L, R, I)$，且目前我在第$X$條）：
若$X$和$L$的矩形比$I$和$L$的矩形還大，這代表$(L, R, I)$這個區間可以完全不要了，pop掉
若$X$和$M - 1$的矩形比$I$和$M - 1$的矩形還小（也就是最後一個），則代表我永遠贏不了那一條線，我就直接break了，反正贏不了
否則，開始二分搜說我到哪裡可以贏$(L, R, I)$，也就是說，找一個最小的$m$使得$m$和$I$的矩形小於或等於$m$和$X$的矩形
維護完之後，再掃一次$M$條線取$\max$就好了！
AC code 感覺寫完到AC的時間還不會很久，但是中間有一堆小細節被卡（還有二分搜寫錯、被卡long long、$N, M$要除以二、面積計算出錯等有趣環節），幸好沒有太大的問題！
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 #include &amp;lt;iostream&amp;gt;#include &amp;lt;deque&amp;gt;#define int long long int #define ericxiao ios_base::sync_with_stdio(0);cin.</description></item><item><title>TIOJ-1168</title><link>https://omeletwithoutegg.github.io/2020/01/25/TIOJ-1168/</link><pubDate>Sat, 25 Jan 2020 21:20:17 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2020/01/25/TIOJ-1168/</guid><description>進階的入門 https://tioj.ck.tp.edu.tw/problems/1168
Description 你需要實作五個函式：
1 2 3 4 5 void pop_big(); void pop_small(); void push(int s); int big(); int small(); 其中第一個函式需要將最大的數字移除，第二個函式需要將最小的數字移除，第三個函式需要將一個數加入目前的數字們，第四個函式需要回傳當前的最大值，第五個函式需要回傳當前的最小值。
假設一開始沒有任何數字，請你實作這五個操作。
保證當沒有數字的時候只會呼叫 push ，並且加入的數字 $\leq 10^9$ ，五個函數的總呼叫次數 $\leq 10^6$ 。
Solution 好久之前就一直卡這題總算AC了@_@
最直覺的想法就是開一個multiset或map，但這題的時限超誇張的緊
可以想到利用 priority_queue 維護最大最小
然而假如一個數字在最大堆被pop掉，不容易在最小堆裡面把他給刪除
我一開始的想法是開 unordered_map 之類的紀錄每個數字的個數，想當然而吃了TLE
後來查了解才發現紀錄插入編號並且維護編號幾的被 pop 了就可以
於是我就在 priority_queue 裡面存編號，並且自己寫compare函式
不過這樣寫的locality很差，似乎會讓常數暴增
改成用struct包住之後剩下最後兩筆TLE，試了好久之後才想到 priority_queue 是用 vector 實作，動態開的空間顯然會浪費很多常數，不如自己靜態開一個大陣列
注意到 pop 操作最多就是呼叫次數的一半，所以 heap 只要開 5e5 就好了， push 的時候多出去的可以直接丟掉
至於 popped 陣列應該還是要開到 1e6 ，因為被 pop 的東西有可能編號很大，TIOJ上的測資似乎沒考慮到這個地方所以開 5e5 也能AC</description></item><item><title>TIOJ-1094</title><link>https://omeletwithoutegg.github.io/2020/01/24/TIOJ-1094/</link><pubDate>Fri, 24 Jan 2020 10:33:31 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2020/01/24/TIOJ-1094/</guid><description>C.幼稚國王的獎賞 https://tioj.ck.tp.edu.tw/problems/1094
Description 定義一個非負整數集合的價值是裡面所有數字XOR起來
給定一些非負整數，問你能選出價值最高的子集價值是多少？
Solution 經典題 maximum subset xor
線性基 首先可以把每個數字的二進位看成模2的$k$維向量
span 我們說一群向量$S = {\textbf{v}_ 1, \textbf{v}_ 2, \dots, \textbf{v}_ n}$的線性生成空間是
$$
\textrm{span}(S) = { \sum _ {i=1}^n\lambda _ i \textbf{v} _ i }
$$
也就是說$\textrm{span}(S)$代表的是所有$S$內的元素的有限線性組合
linear independent 對於一組向量${\textbf{v}_ 1, \textbf{v}_ 2, \dots, \textbf{v} _ n}$
若存在不全為$0$的$\lambda_1, \lambda_2, \dots, \lambda_n$使得
$$
\sum _ {i=1}^n\lambda_ i \textbf{v}_ i = \textbf{0}
$$
則我們說這群向量是線性相關的；反之則稱為線性獨立(linear independent)
一組線性相關的向量至少有一個向量可以用其他向量表示
說明: 不失一般性設$\lambda _ 1 \neq 0$，則</description></item><item><title>TIOJ-1408</title><link>https://omeletwithoutegg.github.io/2020/01/14/TIOJ-1408/</link><pubDate>Tue, 14 Jan 2020 21:06:04 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2020/01/14/TIOJ-1408/</guid><description>我很忙 https://tioj.ck.tp.edu.tw/problems/1408
Description 給定$n$個時段$[l_i, r_i)$
問至少有多少單位時間要是忙碌的才能滿足
「每個時段中都有至少$c_i$單位時間是忙碌的」(每單位時間都不是忙碌就是空閒)
註: 題目保證有解
Solution 看到這種很多區間的題目，就會很想把它們照右界從小到大排序
可以想到一個greedy策略
按右界遞增排序好之後，遇到一個時段就看是否已經滿足條件
如果已經滿足了就跳過
如果還沒有的話就必須選一些時間由空閒變為忙碌，而這些時間依照貪心的原則是從越右邊開始選越好
(選左邊的不會對之後右界更大的時段有比較多幫助)
檢查是否滿足條件只要維護區間和
於是我的作法是用一棵線段樹配上一個 stack
每次新插入一個時段，先以線段樹查詢這個區間內忙碌的時間總共是多少
接著對於剩下需要再增加的時間，維持 stack 內是不相交且排序好的一些時段，代表那些時間必須要是忙碌的
只要看目前最右邊的忙碌時段就能處理好
這份AC code中我沒有值域壓縮(因為我懶)
一臉在CF上欠hack
AC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 #include &amp;lt;bits/stdc++.</description></item><item><title>TIOJ-1152</title><link>https://omeletwithoutegg.github.io/2020/01/12/TIOJ-1152/</link><pubDate>Sun, 12 Jan 2020 23:02:02 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2020/01/12/TIOJ-1152/</guid><description>1.銀河帝國旅行社 https://tioj.ck.tp.edu.tw/problems/1152
Description 給一棵樹，找最遠的兩個點的距離
Solution 這裡用類似DP的方法
dfs(i) 回傳一個 {ans, deepest} 分別表示以$i$為根子樹中的答案和從$i$往下走的最遠距離
那ans可以分成有經過$i$的和沒經過的，有經過的就看最深的兩個子樹加起來是多少，沒經過的就遞迴下去算
AC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include &amp;lt;bits/stdc++.h&amp;gt;#define pb emplace_back #define ff first #define ss second using namespace std; int n; vector&amp;lt;int&amp;gt; g[N]; pair&amp;lt;int,int&amp;gt; dfs(int i) { vector&amp;lt;int&amp;gt; tmp{0}; int ans = 0; for(int j: g[i]) { auto p = dfs(j); ans = max(ans, p.</description></item><item><title>TIOJ-2037</title><link>https://omeletwithoutegg.github.io/2019/12/31/TIOJ-2037/</link><pubDate>Tue, 31 Dec 2019 16:06:00 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2019/12/31/TIOJ-2037/</guid><description>警力配置 https://tioj.ck.tp.edu.tw/problems/2037
Description 裸的二分圖匹配
Solution 這邊給匈牙利算法
有一個subtask是給一個點數很多的樹
特判用dp即可
AC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 // __________________ // | ________________ | // || ____ || // || /\ | || // || /__\ | || // || / \ |____ || // ||________________|| // |__________________| // \###################\ // \###################\ // \ ____ \ // \_______\___\_______\ // An AC a day keeps the doctor away.</description></item><item><title>TIOJ-1441</title><link>https://omeletwithoutegg.github.io/2019/12/31/TIOJ-1441/</link><pubDate>Tue, 31 Dec 2019 15:03:27 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2019/12/31/TIOJ-1441/</guid><description>萬里長城 https://tioj.ck.tp.edu.tw/problems/1441
Description 給定一個序列，找出最長的「長城」子序列
一個序列$&amp;lt; a_1,a_2,\dots,a_n &amp;gt;$必須符合下列幾點才算是「長城」
1. n是奇數
2. 若$i$是偶數，則$a_i$必須小於相鄰的項
3. 若$i$是奇數，則$a_i$必須大於相鄰的項
Solution 貪心法
維護一個tail表示前$i$項滿足點2. 3.的最佳解，其結尾是多少
假設下一個項h必須比tail大
若h比tail大，那就直接接上去(並更新tail)，否則就把tail替換成h
反之亦然
證明大概可以用數歸吧(?)我也不太會說明QQ
AC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include &amp;lt;iostream&amp;gt;signed main() { ios_base::sync_with_stdio(0), cin.tie(0); int n, tail = -1, inc = 1, ans = 0; cin &amp;gt;&amp;gt; n; while(n--) { cin &amp;gt;&amp;gt; h; if(h == tail) continue; if(h &amp;lt; tail ^ inc) ++ans, inc = !</description></item><item><title>TIOJ-1567</title><link>https://omeletwithoutegg.github.io/2019/12/29/TIOJ-1567/</link><pubDate>Sun, 29 Dec 2019 21:08:14 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2019/12/29/TIOJ-1567/</guid><description>黑色騎士團的飛彈野望 https://tioj.ck.tp.edu.tw/problems/1567
Description 給定平面上$n$個點，求至少要用幾個圓心在$x$軸上、半徑為$r$的圓才能覆蓋所有點
若不可行輸出-1
Solution 首先我們對每個點都可以知道包覆它的圓的圓心範圍在$x$軸的哪段區間
那題目就轉換成在$x$軸上放一些圓心，使得每個點對應的區間內都至少有一個點被選到
此為greedy經典題，按照右界排序後，由小到大檢查若某個區間還沒有放東西就放一個在它的右界
證明很簡單，右界最小的區間內一定至少要選一個點放
假設沒有選右界$r$而選了某個點$i$放，則改選右界，不會有其他右界更大的區間$I$包含$i$卻不包含$r$
故選右界最小的區間的右界不會錯過最佳解
無解的判斷就是只要有一個點和$x$軸距離超過$r$就不可行，否則顯然至多用$n$個圓可以覆蓋所有點
AC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 // __________________ // | ________________ | // || ____ || // || /\ | || // || /__\ | || // || / \ |____ || // ||________________|| // |__________________| // \###################\ // \###################\ // \ ____ \ // \_______\___\_______\ // An AC a day keeps the doctor away.</description></item><item><title>TIOJ-1726</title><link>https://omeletwithoutegg.github.io/2019/12/23/TIOJ-1726/</link><pubDate>Mon, 23 Dec 2019 22:14:53 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2019/12/23/TIOJ-1726/</guid><description>Dice Wars https://tioj.ck.tp.edu.tw/problems/1726
Description Dice Wars是一款兼具謀略和運氣的遊戲。
遊戲中你扮演紫色的骰子，要攻下其他顏色的骰子的城池，進而統一全地圖。
如今你選到了一張看起來不錯的地圖: 整張地圖呈一條直線，每個位置都有一個顏色勢力佔領。
由於每次移動到相鄰異色的城池都必須經歷一場鏖戰，你想先經過程式計算後再進行遊戲。
你想要每次詢問一個顏色對$(S, T)$，問從任何一個$S$的城池到任一個$T$的城池至少要經過幾場戰鬥。
如果$S$或$T$已經滅亡(地圖中沒有任何一個該勢力)，就輸出$-1$。
Solution 題敘裡面附上的遊戲好好玩www
題目要問的其實就是$\min\limits _ {c_i=S,c_j=T}(|i-j|)$
可以想到對每種顏色開一個 vector 紀錄他們的index
一種naive$\mathcal{O}(nq)$的方法是每次詢問都直接把兩種顏色的兩個 vector merge $\mathcal{O}(n)$合併並計算答案
而另一種naive的算法則是先針對每一種顏色$\mathcal{O}(n)$預處理其對其他顏色的答案，複雜度$\mathcal{O}(n^2+q)$
前者拉低複雜度的關鍵是某種顏色出現很多次
而後者則是會因為太多種顏色而複雜度爛掉
怎麼辦呢？可以不要全部預處理，只針對出現次數超過$k$的顏色做預處理，這些顏色的種類數不會超過$\frac{n}{k}$種
故預處理需要$\mathcal{O}(\frac{n^2}{k})$
而對於詢問的兩個顏色的出現次數都沒有超過$k$的情況，可以直接用上面第一個算法處理
複雜度$\mathcal{O}(qk)$
根據算幾不等式可取$k=\frac{n}{\sqrt{q}}$有複雜度$\mathcal{O}(n\sqrt{q})$
註: 這題我寫的時候 ans 開原生陣列MLE，不知為何用vector陣列會是好的
AC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 #include &amp;lt;bits/stdc++.</description></item><item><title>TIOJ-1674</title><link>https://omeletwithoutegg.github.io/2019/12/19/TIOJ-1674/</link><pubDate>Thu, 19 Dec 2019 10:58:57 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2019/12/19/TIOJ-1674/</guid><description>新專輯 https://tioj.ck.tp.edu.tw/problems/1674
Description 最近你打算訂購$N^2$張水樹奈奈的專輯《極限魅惑IMPACT EXCITER》。
由於份量實在是太多了，你決定分散成$N$份訂單。
然而，不幸的，依據博客來新的訂貨規定，每一位顧客第$k$次下訂單所訂的CD張數必頇是$k$的正整數倍。
換句話說，一位顧客第$5$次訂的CD張數只可能是$5$張、$10$張、$15$張、…依此類推。
當然，原先你把$N^2$張CD分散在$N$份訂單的目的就是為了讓一張訂單中最多只會有$N$張CD。
即使博客來多了這項奇怪的規定，你仍然不打算捨棄你的原則，只是這樣每份訂單訂的數量可能會達不到你原來的期望。
無論如何，你還是下了訂單。為了估計你實際訂下的CD數與你期望訂下的CD數的差別，你決定把每次你少訂的數量加起來。
可是，因為你可能少訂非常多張CD，所以你希望算出少訂的總數量除以$10^9+9$的餘數。
也就是說，如果你總共要訂$3^2$張CD，分成三次訂的話，
那你第一、第二、第三次分別可以訂$3$、$2$、$3$張CD，分別會少訂是$0＋1＋0＝1$張CD。
Solution 仔細讀懂題目之後可以發現題目要求的就是
$$
\sum _ {i=1}^n n\%i
$$
不過$n$可以到$10^{13}$不能直接$\mathcal{O}(n)$跑過去
數論分塊 數論分塊的精神很簡單，不同的$\lfloor n/i \rfloor$數量只有$\mathcal{O}(\sqrt{n})$種
說明:
對於$i \leq \sqrt{n}$，最多只有$\sqrt{n}$種不同的值
對於$i &amp;gt; \sqrt{n}$，$\lfloor n/i \rfloor &amp;lt; \sqrt{n}$最多也只有$\sqrt{n}$種不同的值
怎麼快速枚舉可能的$\lfloor n/i \rfloor$？
1 2 3 4 5 6 for(int i = 1,j,x; i &amp;lt;= n; i = j+1) { x = n/i; j = n/x; // j是最大的數字使得j*x &amp;lt;= n，意即[i,j]區間內正好是所有n/k=x的數字 // use n/i here } 回到剛剛的式子，把他改寫成</description></item><item><title>TIOJ-1035</title><link>https://omeletwithoutegg.github.io/2019/12/18/TIOJ-1035/</link><pubDate>Wed, 18 Dec 2019 08:08:39 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2019/12/18/TIOJ-1035/</guid><description>通關密語 https://tioj.ck.tp.edu.tw/problems/1035
Description 給定兩個長度小於 $5 \times 10^4$ 的小寫英文字母字串 $S,T$
定義「最佳擬合」，就是將 $S$ 經過平移後和 $T$ 比對，同樣的字元數最多的那一種方法。
請輸出一個正整數，代表最佳擬合的方案下，相同的字元有幾個。
ex.
對於
&amp;gt; ababa
&amp;gt; babab
來說，
ababa
=babab
這是一種最佳擬合的方法，$S$經過向左平移之後$S,T$有四個位置的字元相同
Solution naive的$n^2$做法可以AC本題，只要妥當控制常數即可
不過這裡提供一個NTT的$\mathcal{O}(C\cdot n\log n)$解
假設$S$對$T$的平移量是$x$(可以為負的)，題目所求為
$$
\sum _ {i-j = x} [S_i = T_j]
$$
的最大值
那我們枚舉26種英文字母，可以寫成
$$
\sum _ {c \in \sigma} \sum _ {i-j = x} [S_i = c] \cdot [T_j = c]
$$
令$F_i = [S_i = c], G_j = [T _ {-j} = c]$</description></item><item><title>TIOJ-1950</title><link>https://omeletwithoutegg.github.io/2019/12/13/TIOJ-1950/</link><pubDate>Fri, 13 Dec 2019 23:26:11 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2019/12/13/TIOJ-1950/</guid><description>小向的試煉 2-3：轉！(Rotate!) https://tioj.ck.tp.edu.tw/problems/1950
Description 給定長度$N$的排列，問「以交換任意兩個數字的方式排序這個序列需要多少次數」
另外有$M$次修改，每次修改會交換數字$i$和數字$j$的位置，請輸出$M+1$行代表一開始和每次修改過後的答案
Solution 已經知道每個數字應該被放到哪裡了，所以我們可以想到一個排序方法
每次看某個位置$i$的數字$x$，如果和$i$不同的話就把$x$放到位置$x$的地方，再繼續對原本放在位置$x$的地方的數字做同樣的事
可以發現這樣會形成好幾個「環」，例如範測的$(1, 4, 2, 5, 3)$會形成兩個環
$$
\begin{pmatrix}
1
\end{pmatrix}
\begin{pmatrix}
4 &amp;amp; 5 &amp;amp; 3 &amp;amp; 2
\end{pmatrix}
$$
或是$(1, 6, 4, 5, 3, 2)$會形成三個環
$$
\begin{pmatrix}
1
\end{pmatrix}
\begin{pmatrix}
6 &amp;amp; 2
\end{pmatrix}
\begin{pmatrix}
4 &amp;amp; 5 &amp;amp; 3
\end{pmatrix}
$$
也就是說，每個環代表第一個元素要放到第二個元素的位置，第二個元素要放到第三個元素的位置&amp;hellip;以此類推
一個大小$L$的環需要的交換次數是$L-1$，所以把$1\dots n$的排列排序好所需的時間就是$n-($環的個數$)$
用數學一點的講法就是一個置換可以分解成好多不相交的輪換(?)而且方法是唯一的喔
考慮一下交換了兩個數字會發生什麼事:
如果他們在同一個「環」裡面，那那個環就會被切成兩個環
反之則會讓兩個環合在一起，變成一個「環」
示意圖大概就是這樣
要怎麼辦到這件事呢？快速把元素之間連接或者切斷，我們會想到使用鏈結串列，但是這樣無法判斷他們是否在同一個環裡面
退而求其次可以使用二元樹來維護，用$\mathcal{O}(\log n)$獲得可以剪切又可以黏貼序列的神力(?)
我選擇用splay來實作，詳細的原理自己google OwO
AC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 // __________________ // | ________________ | // || ____ || // || /\ | || // || /__\ | || // || / \ |____ || // ||________________|| // |__________________| // \###################\ // \###################\ // \ ____ \ // \_______\___\_______\ // An AC a day keeps the doctor away.</description></item><item><title>TIOJ-1394</title><link>https://omeletwithoutegg.github.io/2019/12/13/TIOJ-1394/</link><pubDate>Fri, 13 Dec 2019 06:36:47 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2019/12/13/TIOJ-1394/</guid><description>黑色騎士團的逆襲野望 https://tioj.ck.tp.edu.tw/problems/1394
Description 自從黑色騎士團上次的最終野望被白色騎士豬殺苦破滅之後，黑色騎士團銷聲滅跡了一陣子，不過他們仍繼續計畫著侵略神聖的大不列顛帝國。
終於他們發現了一個機會：原來大不列顛帝國的命脈就是對外輸出的藥品&amp;rdquo;REBRAIN&amp;rdquo;，只要能控制住它所有的運輸與加工途徑，那大不列顛帝國就完了！
與之前一樣，他們只要佔領一個據點就可以控制與他相鄰的運輸途徑了！
&amp;ldquo;REBRAIN&amp;rdquo;的運輸過程十分有趣，他有一個總工廠來製造&amp;rdquo;REBRAIN&amp;rdquo;的一些半成品，再依序經過幾個有向道路到下個加工地點進行加工，就這樣一直到完成成品，並且為了不讓產品流程出問題，他們的運輸路徑不會出現環狀或逆向的情況。
不過黑色騎士團的人手有限，所以他們希望佔據最少的據點就可以完全控制整個運輸與加工途徑。
註: 雖然是有向邊，不過相鄰的關係依然是互相的；另外雖然沒有講的很清楚，題目是有保證0號節點可以走到所有其他節點
Solution 題目所求是最小點覆蓋，也就是在給定圖上要選幾個點才能保證所有邊都有一個端點被選到
因為這題給的是DAG，所以我們可以考慮用DP的方式做
狀態$dp[i][s]$代表$i$往子孫走的邊都已經保證有端點被選到的答案，若$s=1$代表有選$i$這個點，反之沒有
可以知道如果沒有選$i$這個點，那他的子節點都一定要選，所以
$$dp[i][0] = \sum\limits _ {j\in son(i)} dp[j][1]$$
如果選了$i$這個點，那他的子節點可選可不選，我們就取比較小的那個，有
$$dp[i][1] = 1 + \sum\limits _ {j\in son(i)} \min(dp[j][0],dp[j][1])$$
最後取的答案是0號節點選或不選取$\min$
AC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std; const int N = 33001; int dp[N][2], vis[N]; vector&amp;lt;int&amp;gt; g[N]; void dfs(int i) { if(vis[i]) return; vis[i] = true; dp[i][0] = 0; dp[i][1] = 1; for(int j:g[i]) { dfs(j); dp[i][0] += dp[j][1]; dp[i][1] += min(dp[j][0],dp[j][1]); } } signed main() { ios_base::sync_with_stdio(0), cin.</description></item><item><title>TIOJ-1739</title><link>https://omeletwithoutegg.github.io/2019/12/11/TIOJ-1739/</link><pubDate>Wed, 11 Dec 2019 15:26:33 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2019/12/11/TIOJ-1739/</guid><description>[APIO &amp;lsquo;08] Beads [Interactive] https://tioj.ck.tp.edu.tw/problems/1739
Description 有一個長度$n$的序列$a$，一開始$a_i = i$
接下來有$m$個操作，每個操作只會交換相鄰的兩個數字
接著有$q$個詢問，每次會詢問：第$t$個操作之後，數字$x$被放到哪個位置？
$n,m,q \leq 3 \times 10^5; 1 \leq x \leq n; 1 \leq t \leq m$
Solution 對序列保存不同的版本，當然持久化資料結構砸下去就對啦
是說本來想寫treap不過我實作能力好差QQ
什麼？你想問什麼是持久化？
反正就是用樹來存一個序列啦，然後因為改一個數字時只要改他到根的那條鏈就好了啦，這樣每次修改新增的點數會和樹高一樣
AC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 // __________________ // | ________________ | // || ____ || // || /\ | || // || /__\ | || // || / \ |____ || // ||________________|| // |__________________| // \###################\ // \###################\ // \ ____ \ // \_______\___\_______\ // An AC a day keeps the doctor away.</description></item><item><title>TIOJ-1948</title><link>https://omeletwithoutegg.github.io/2019/12/11/TIOJ-1948/</link><pubDate>Wed, 11 Dec 2019 13:24:35 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2019/12/11/TIOJ-1948/</guid><description>小向的試煉 2-1：洞穴(Cave) https://tioj.ck.tp.edu.tw/problems/1948
Description 小向在洞穴裡偵察到了$N$個烏龍，不知道是本尊還是分身。不過他們在洞穴中都是以每秒1公分的速度前進，只是有的朝著左邊的入口前進，而有的朝著右邊的入口前進。而由於洞穴相當狹窄，兩個相向的烏龍相撞時會回頭。小向大膽猜測，本尊一定會在所有分身都出洞穴被小向打敗後才出洞穴，瞄準小向用盡魔力的那剎那攻擊小向。不過她也沒那麼多時間等所有分身慢慢走出來再找到本尊，所以小向希望能直接用她剛剛偵察到的資訊判斷哪個是本尊。($N\leq10^6$，洞穴的長度$L\leq10^9$)
注意：離開洞穴的定義是從左邊的入口往左走一步或從右邊的入口往右走一步。保證答案唯一，並且所有烏龍都在不同位置。
Solution 首先若不管烏龍的編號，只想知道烏龍最後的位置，兩個烏龍相撞並回頭時可以當作穿過去
顯然地，我們可以知道所有烏龍最晚離開洞穴的時刻，就等於每隻烏龍單獨放在洞穴內離開洞穴的時刻的最大值，我們也能知道最後一隻離開洞穴的烏龍是向左還是向右
接著可以發現在烏龍相撞的過程中，左右順序一定不會變，意思是如果某個編號$i$的烏龍一開始是x座標第$k$大的，那不管經過多少次的相撞，他仍然會是x座標第$k$大的
同時向左的烏龍數量與向右的烏龍數量也不會變
所以，我們可以知道最後一隻烏龍離開洞穴時，一定是左邊全部向左，右邊全部向右，而那隻最後離開的烏龍一定是「向左的烏龍中最右邊的或者向右的烏龍中最左邊的」，也就知道了最後離開的烏龍是x座標第幾大的了
用 nth_element 可以快速找出x座標第$k$大的編號，注意一開始他給的編號沒有按照x座標排序，上述推論必須先照x座標排序才會是對的= =
AC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #pragma g++ optimize(&amp;#34;Ofast&amp;#34;) #pragma loop_opt(on) #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;const int N = 1000001; int n,L,x[N],id[N],cnt; signed main() { int t = -1e9, dir, pos; scanf(&amp;#34;%d%d&amp;#34;,&amp;amp;n,&amp;amp;L); for(int i = 0,d; i &amp;lt; n; i++) { scanf(&amp;#34;%d%d&amp;#34;,x+i,&amp;amp;d); int dis = d ?</description></item><item><title>TIOJ-2017</title><link>https://omeletwithoutegg.github.io/2019/12/06/TIOJ-2017/</link><pubDate>Fri, 06 Dec 2019 13:03:18 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2019/12/06/TIOJ-2017/</guid><description>B.廢文大資料 mining https://tioj.ck.tp.edu.tw/problems/2017
Description 給定一個序列 $a_i$ ，問有多少區間 $[l,r]$ 使得存在一個 $m \leq r$ 滿足 $\sum\limits _ {i=l}^m a_i &amp;lt; 0$？
Solution 先對 $a_i$ 做前綴 $s_k = \sum\limits _ {i=1}^k a_i$
對於一個固定的 $l$ 來說，題目等價於找到一個最小的 $m$ 使得 $s_m - s _ {l-1} &amp;lt; 0$
在 $m$ 之後的 $r$ 都會被算在答案裡面
可以用單調隊列幫每個 $i$ 找到最小的 $i&amp;rsquo;$ 使得 $s _ {i&amp;rsquo;} &amp;lt; s_i$ ，複雜度 $\mathcal{O}(n)$
AC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include &amp;lt;bits/stdc++.</description></item><item><title>TIOJ-1614</title><link>https://omeletwithoutegg.github.io/2019/12/06/TIOJ-1614/</link><pubDate>Fri, 06 Dec 2019 12:51:45 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2019/12/06/TIOJ-1614/</guid><description>販賣機耶 https://tioj.ck.tp.edu.tw/problems/1614
Description 蝴蝶在路旁玩壞一台販賣機，它一次只能投一枚硬幣（故障？）。
重點是：投進一枚x元的硬幣，然後按退幣鈕，居然會吐出一枚價值 $f(x)$ 的硬幣耶！
更神秘的是，天才蝴蝶已經發現 $f(x) = x + (x-b_1) (x-b_2) (x-b_3) \dots (x-b_m)$。
現在蝴蝶手上有 $n$ 枚硬幣，分別是 $a_1 \dots a_n$，請問蝴蝶投進去會賺的硬幣有幾枚？
Solution 題目就是問$f(x)-x = \prod\limits _ {i=1}^m (x-b_i)$是不是正的
然後看有幾個$b_i$小於$x$就可以知道乘積的正負號了(國中數學??)
另外注意$x - b_i = 0$的case，然後也不要亂 unique ，要保持個數的奇偶性。
AC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std; const int N = 100025; int n,m,a[N],b[N]; signed main() { ios_base::sync_with_stdio(0), cin.</description></item><item><title>TIOJ-1927</title><link>https://omeletwithoutegg.github.io/2019/12/06/TIOJ-1927/</link><pubDate>Fri, 06 Dec 2019 10:36:19 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2019/12/06/TIOJ-1927/</guid><description>同步(Sync) https://tioj.ck.tp.edu.tw/problems/1927
Description 在一個多人單向卷軸遊戲中，有$N \leq 10^5$個格子，每個格子都有一個不超過$10^9 + 6$的正整數，代表該格的狀況。
有時遊戲中的兩人會產生「同步」的現象。產生同步的條件是兩人所在的格子的數字$a,b$分別滿足
$$
(ab)^{\frac{p-1}{2}} \equiv 1 \pmod p
$$
其中$p = 10^9 + 7$。產生同步後，兩人會瞬移至下一格。如果在下一格又產生「同步」，則會繼續往下走，直到其中一人超出格子範圍(到了終點了)或者兩人不再同步。
Solution 對於$x \not\equiv 0 \pmod p$，$y = x^{\frac{p-1}{2}} \equiv \pm 1 \pmod p$
因為$y$是$1$的平方根(?)
然後$(ab)^{\frac{p-1}{2}} \equiv a^{(\frac{p-1}{2})} b^{(\frac{p-1}{2})}$
所以可先把所有值先$(p-1)/2$次方，一定會是$\pm 1$，接著他們同步的條件就可以簡化成$a = b$了
考慮到同步必須要是連續的性質，我們聯想到字串演算法中的後綴陣列，這題等價求兩個後綴的LCP，完全是SA的形狀XDD
SA + RMQ資結收工
注意查詢兩個同樣位置的情況，RMQ會查到空區間，不過我們知道這時候的答案顯然就是到尾巴的長度
AC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 // __________________ // | ________________ | // || ____ || // || /\ | || // || /__\ | || // || / \ |____ || // ||________________|| // |__________________| // \###################\ // \###################\ // \ ____ \ // \_______\___\_______\ // An AC a day keeps the doctor away.</description></item><item><title>TIOJ-1774</title><link>https://omeletwithoutegg.github.io/2019/12/05/TIOJ-1774/</link><pubDate>Thu, 05 Dec 2019 21:30:24 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2019/12/05/TIOJ-1774/</guid><description> Ch3. Section 9. 妁艷的頭髮 https://tioj.ck.tp.edu.tw/problems/1774
Solution 裸背包，被值域嚇到XD
不過實際上魔力M只會到2000所以沒差的啦
AC code 1 2 3 4 5 6 7 8 9 10 11 12 #include &amp;lt;iostream&amp;gt;using namespace std; long long n,M,dp[2001]; signed main() { ios_base::sync_with_stdio(0), cin.tie(0); cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; M; for(int i = 0,h,c; i &amp;lt; n; i++) { cin &amp;gt;&amp;gt; h &amp;gt;&amp;gt; c; for(int j = c; j &amp;lt;= M; j++) dp[j] = max(dp[j-c]+h, dp[j]); } cout &amp;lt;&amp;lt; dp[M] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;; }</description></item><item><title>TIOJ-2019</title><link>https://omeletwithoutegg.github.io/2019/12/05/TIOJ-2019/</link><pubDate>Thu, 05 Dec 2019 00:48:51 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2019/12/05/TIOJ-2019/</guid><description>D.番茄大戰爭 https://tioj.ck.tp.edu.tw/problems/2019
Description 兩個人在玩剪刀石頭布，而他們兩個人玩了$T$個回合。兩個人（此處稱為小奕和小安）各自有一個「策略」，分別為兩個字串$A$和$B$。兩個字串皆由R、P、S三個字元組成，分別代表小奕和小安會出石頭、布、剪刀。兩個人都會根據他們的「策略」出題，在第$i$個回合，小奕將會出$A _ {i \mod {|A|}}$，而小安將出$B _ {i \mod{|B|}}$，從$i = 0$開始。請輸出：經過$T$個回合後，兩人分別贏了幾局，平手了幾局。
保證滿足：$1 \leq T \leq 10^9$，$1 \leq |A|, |B| \leq 10^6$，且$A, B$由R、P、S三個字元組成。
Solution 首先，看到$1 \leq T \leq 10^9$當然想說直接給他寫個$\mathcal{O}(T)$，寫了五分鐘之後傳上去——AC——了前幾筆，之後就TLE了。所以，當然就來想怪做法嘍！
先假設$|A| \leq |B|$。第一個想法就是，對於$A$裏頭的每一個字元$A_i$，我都看一次我會遇到哪些字元（$B_i, B _ {i + |A|}, B _ {i + 2\times|A|}, \dots$，也就是所有滿足$(i + k|A|) \mod{|B|} \leq T$的$B _ {(i + k|A|)\mod{|B|}}$，然後再$\mathcal{O}(1)$更新答案。這樣複雜度依然為$\mathcal{O}(T)$，因為還是每一個時間點都有戳到一次，只是改變順序而已了。不過！這個順序很重要，因為可以優化！
若我們看$A_i$，我們先考慮它會遇到那些$B$的字元$$B_i, B _ {i + |A|}, B _ {i + 2\times|A|}, \dots $$，也就是所有的$B _ {i + k|A| \mod{|B|}}$。可以知道，這樣分可以將$B$的所有字元分成若干個相斥的群組$G_t$！具體做法就是，先看$A_i$，如果$B_i$尚未在一個群組裡面，就創立一個新的群組然後將所有的$B _ {i + k|A|}$加進去這個群組裡面。現在，就想要用這個新的資料儲存方式來加快我們的運算。</description></item><item><title>TIOJ-1171</title><link>https://omeletwithoutegg.github.io/2019/12/04/TIOJ-1171/</link><pubDate>Wed, 04 Dec 2019 23:41:02 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2019/12/04/TIOJ-1171/</guid><description>我要成為海賊王 https://tioj.ck.tp.edu.tw/problems/1171
Description 給定一棵樹，一開始所有頂點都是白色的，有$q$次操作，每次操作可以把一個頂點塗成黑色，或者詢問某個頂點$x$到所有黑色頂點的距離和
Solution 可能算是經典題吧，這邊提供兩種寫法: 重心剖分和輕重鍊剖分
重心剖分 重心剖分的核心想法是樹分治，每次拔掉一個點，並統計有經過這個點的答案並遞迴計算沒經過該點的答案
為了確保複雜度，每次拔掉重心是一個好選擇
也許可以發現每個頂點都會當一次重心(?)
並且若把每次拔掉的重心$c$和分治下去的每個子樹找到的重心$c&amp;rsquo;$都連邊，也會是一棵樹，稱為重心樹
假設我要查詢$x$這個點，我們就枚舉$x$在重心樹上的祖先
對於所有黑色頂點$b$來說都可以找到恰一個祖先$c$使得$b,x$最後是被$c$分開的
可以想到紀錄$cnt_c, sum_c$分別代表分治到以$c$為重心的時候的子樹中，黑色節點的數量以及與$c$的距離和
加加減減就能得到答案了
算式好難推QQ去查了YP的題解才知道怎麼寫
記得在重心樹往上爬的時候必須減掉和下一層有關的一些東西，要避免有重複的邊的路徑被計算到
式子可能長得像這樣吧
$$
\sum _ {p\not=croot} sum_q + cnt_q \cdot path(q,x) - sum_p - cnt_p \cdot path(p,q)
$$
其中$q$是$p$在重心樹上的父節點
每次詢問的複雜度是重心樹的深度也就是$\mathcal{O}(\log n)$
輕重鍊剖分 用$b$和$B$代表黑色頂點和他們的集合，$dis_v$代表從根走到$v$的距離
把所求寫成
$$
\sum _ {b\in B} dis_x + \sum _ {b\in B} dis_b - 2\sum _ {b\in B} dis _ {LCA(b,x)} = |B|dis_x + \sum _ {b\in B}dis_b - 2 \sum _ {b\in B} dis _ {LCA(b,x)}</description></item><item><title>TIOJ-1197</title><link>https://omeletwithoutegg.github.io/2019/12/04/TIOJ-1197/</link><pubDate>Wed, 04 Dec 2019 14:18:31 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2019/12/04/TIOJ-1197/</guid><description>排教室問題 https://tioj.ck.tp.edu.tw/problems/1197
Description 某校有M種不同的課程，其中有些課程的時間會有衝堂。如果學校中總共有N間不同的教室，請問共有多少種安排各課程上課教室的方式？最少要用到幾間教室？
$M,N \leq 10$
註: 衝堂的意思是他們不能被安排在同一個教室
Solution 題目可以想成給定一張圖，每個頂點有$k$種顏色可以塗，定義合法塗色是讓相鄰頂點無同色的塗色方式，問有幾種合法塗色的方式以及至少要用多少顏色才能合法塗色
一開始覺得這是暴搜題，但忽然想到可能不連通也可能會有環之後就不太知道怎麼實作
另外題敘好像沒有講到，不過這題讀邊的時候要用EOF讀
這題我的寫法是位元DP，考慮狀態$dp[S][c]$代表$c$之前的顏色都用過了，並且$S$這個subset已經被塗過了
那轉移可以想成把$S$的一個subset$X$都塗上$c$這個顏色，當然$X$中任意兩個頂點都不相鄰(也就是說$X$是獨立集)，式子長得像
$$
dp[S][c] = \sum\limits _ {X \subseteq S, Valid(X)} dp[S \setminus X][c-1]
$$
其中$Valid(X)$代表$X$是否為獨立集，可以先預處理
預處理獨立集可以做到$\mathcal{O}(n \cdot 2^n)$，而後面枚舉$k$次子集則是$\mathcal{O}(k \cdot 3^n)$
註: 一次枚舉複雜度是$\mathcal{O}(3^n)$的原因可以參考 https://cp-algorithms.com/algebra/all-submasks.html
AC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std; const int N = 10; typedef long long ll; int k,n,a,b,valid[1&amp;lt;&amp;lt;N],g[N][N]; ll dp[1&amp;lt;&amp;lt;N][N]; signed main() { scanf(&amp;#34;%d%d&amp;#34;,&amp;amp;n,&amp;amp;k); while(~scanf(&amp;#34;%d%d&amp;#34;,&amp;amp;a,&amp;amp;b)) --a, --b, g[a][b] = g[b][a] = true; for(int s = 0; s &amp;lt; (1&amp;lt;&amp;lt;n); s++) valid[s] = true; for(int s = 0; s &amp;lt; (1&amp;lt;&amp;lt;n); s++) { for(int i = n-1; i &amp;gt;= 0; i--) if(s &amp;amp; (1&amp;lt;&amp;lt;i)) { if(!</description></item><item><title>TIOJ-2021</title><link>https://omeletwithoutegg.github.io/2019/12/04/TIOJ-2021/</link><pubDate>Wed, 04 Dec 2019 11:34:34 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2019/12/04/TIOJ-2021/</guid><description>F.無限兔子問題 https://tioj.ck.tp.edu.tw/problems/2021
Description 令$F_i$是費式數列
給定$s,t$，求$\sum\limits _ {i=s}^t\binom{F_i}{2}$
Solution 這題也是有夠數學OwO
題目所求是$\sum\limits _ {i=s}^t\frac{1}{2}{F_i(F_i - 1)}$
可以想到分別求$\sum\limits _ {i=1}^nF_i$和$\sum\limits _ {i=1}^nF_i^2$
前者可以用
$$
\left[
\begin{matrix}
0 &amp;amp; 1 &amp;amp; 0 \newline
1 &amp;amp; 1 &amp;amp; 0 \newline
1 &amp;amp; 1 &amp;amp; 1
\end{matrix}
\right]
\left[
\begin{matrix}
F _ {i-2} \newline
F _ {i-1} \newline
S _ {i-1}
\end{matrix}
\right] =
\left[
\begin{matrix}
F _ {i-1} \newline
F_i \newline
S_i
\end{matrix}
\right]</description></item><item><title>TIOJ-1282</title><link>https://omeletwithoutegg.github.io/2019/12/04/TIOJ-1282/</link><pubDate>Wed, 04 Dec 2019 09:31:16 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2019/12/04/TIOJ-1282/</guid><description>愛蜜利雅的作業2 https://tioj.ck.tp.edu.tw/problems/1282
Description 給定一個長度$n$的正整數序列，有$q$次操作，每次操作可能會對區間$[l,r]$加上$k$或詢問區間$[l,r]$的最大公因數
$1 \leq n,q \leq 10^5$
Solution 想法是利用區間加值等於對差分的兩個單點修改
然後有一個性質是 $\gcd(a,b) = \gcd(a-b,b)$
所以$[l,r]$區間的GCD會等於$\gcd(\gcd(a _ {l+1}-a_l, a _ {l+2}-a _ {l+1}, \dots, a_r-a _ {r-1}), a_r)$之類的
求$a_r$可以用BIT就好，前面那項我則是用線段樹維護
複雜度$\mathcal{O}(n\log c + q\log n \log c)$
注意算完GCD要加絕對值，因為差分會出現負數，此時__gcd可能回傳負數
AC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 // __________________ // | ________________ | // || ____ || // || /\ | || // || /__\ | || // || / \ |____ || // ||________________|| // |__________________| // \###################\ // \###################\ // \ ____ \ // \_______\___\_______\ // An AC a day keeps the doctor away.</description></item></channel></rss>