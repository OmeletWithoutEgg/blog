<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>cpp on 蛋餅的競程隨筆</title><link>https://omeletwithoutegg.github.io/tags/cpp/</link><description>Recent content in cpp on 蛋餅的競程隨筆</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>Omelet</copyright><lastBuildDate>Sun, 09 Jul 2023 02:26:08 +0800</lastBuildDate><atom:link href="https://omeletwithoutegg.github.io/tags/cpp/index.xml" rel="self" type="application/rss+xml"/><item><title>CF 793f Julia the snail</title><link>https://omeletwithoutegg.github.io/2023/07/09/cf-793f/</link><pubDate>Sun, 09 Jul 2023 02:26:08 +0800</pubDate><guid>https://omeletwithoutegg.github.io/2023/07/09/cf-793f/</guid><description>Codeforces 793 F Julia the snail Description 有 $M$ 個傳送器，第 $i$ 個可以把你從 $l_i$ 傳送到 $r_i$，其中 $l_i, r_i$ 介在 $1, N$ 之間。
你除了傳送以外的移動方式只有向數線的左邊走（把 $x$ 變小）
接著有 $Q$ 筆詢問問，每筆詢問給 $x, y$，
問你從 $x$ 開始走，在不超出 $[x, y]$ 這個區間的前提下可以走最右邊是多右邊。
$r_i$ 全部相異（雖然我感覺好像沒用）
Solution 想了很久之後看官解發現是 $\mathcal{O}(\sqrt{n})$ 氣死
留言說有一個 log 的解但他不願透露
網路上查到很多類似吉如一線段樹的解但我覺得他們都沒什麼說服力
先從 naive 的想法開始說明。
這邊的說明都是用左閉右閉的。
如果把所有被 $[x, y]$ 包含的 $[l_i, r_i]$ 拿出來，那他們會把整個區間分成一些連通塊的感覺。
具體來說，會有一些分界線 $z$，
使得我們可以把 $[l_i, r_i]$ 分成兩部分，一部分完全落在 $[x, z]$ 而另一部分完全落在 $[z+1, y]$。
注意到 $z = y$ 一定是一個合法的分界線（？）</description></item><item><title>Cppbugs</title><link>https://omeletwithoutegg.github.io/2021/09/19/cppbugs/</link><pubDate>Sun, 19 Sep 2021 16:32:00 +0800</pubDate><guid>https://omeletwithoutegg.github.io/2021/09/19/cppbugs/</guid><description>這篇是想放一些神奇的C++語法錯誤
也可能會放基礎的(X
然後可能會是動態更新
lambda capture (Update: 2021/1/21)
這似乎是因為capture到值的時候還沒成功建構func這個變數，所以會出問題
1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include &amp;lt;iostream&amp;gt; #include &amp;lt;functional&amp;gt; using namespace std; signed main() { function&amp;lt;void(void)&amp;gt; func = [=]() { int x; cin &amp;gt;&amp;gt; x; cout &amp;lt;&amp;lt; &amp;#34;ok &amp;#34; &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;; if(x) func(); }; func(); } const reference &amp;amp; implicit conversion (Update: 2021/1/21)
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include &amp;lt;iostream&amp;gt; using namespace std; struct Data { int x; Data(int val = 0) : x(val) {} int calc() { return x * 2 + 3; } }; istream &amp;amp; operator&amp;gt;&amp;gt;(istream &amp;amp;I, const Data &amp;amp;data) { return I &amp;gt;&amp;gt; data.</description></item><item><title>PBDS Split Join Is Slow</title><link>https://omeletwithoutegg.github.io/2021/07/23/pbds-split-join-is-slow/</link><pubDate>Fri, 23 Jul 2021 18:16:13 +0800</pubDate><guid>https://omeletwithoutegg.github.io/2021/07/23/pbds-split-join-is-slow/</guid><description>幫 pbds 上香 如題。
先說結論：
官網的 document 寫說 split 跟 join 時間是「poly-logarithm」，但是其實目前為止 GNU 的 pbds 預設的 split 是 $\mathcal{O}(N)$ 的，請看這篇文章。
不過有一些方法可以讓複雜度變回一次 split $\Theta(\log N)$，但是有一點麻煩。
前言 Policy-Base Data Structure 簡稱 pbds ，是 GCC 提供的一系列資料結構的 template，而今天要談的是當中的 tree 型別。
因為看到別人寫的 pbds 自訂 metadata_type 覺得很酷，因此想要來探索探索 pbds 一番。
大概了解 node_update 怎麼運作之後，我試著去寫了 氣球博覽會，因為需要區間查詢，我使用了 tree::split(key, other) 和 tree::join(other)，沒想到全部吃 TLE，研究一番之後發現下面這樣的 code 就會執行不完了：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include &amp;lt;bits/extc++.</description></item><item><title>jngen</title><link>https://omeletwithoutegg.github.io/2021/01/24/jngen/</link><pubDate>Sun, 24 Jan 2021 01:17:43 +0800</pubDate><guid>https://omeletwithoutegg.github.io/2021/01/24/jngen/</guid><description>jngen 最近在生107北市賽題目的測資想放到TIOJ上面，其中一題是關於找兩個凸包的兩條內公切線交點。
因為不太知道測資怎麼生，又想到之前東東有提過jngen這個東西，因此就把他拿來生成我需要的凸包了。
我覺得他的函式、方法都很乾淨，然後因為生測資仔細看了一下文件，就想說把他貼到部落格推廣一下（X
Usage https://github.com/ifsmirnov/jngen
要使用jngen，你只需要下載jngen.h並引用標頭檔。下載來的標頭檔可以放在 /usr/include 之類的地方，或是跟你的C++原始碼相同目錄當中。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include &amp;#34;jngen.h&amp;#34; #include &amp;lt;iostream&amp;gt; using std::cout, std::endl; int main(int argc, char *argv[]) { registerGen(argc, argv); parseArgs(argc, argv); int n, m; getPositional(n, m); Tree t = Tree::bamboo(n).link(n - 1, Tree::star(m), 0); if (getOpt(&amp;#34;shuffled&amp;#34;, false)) { t.shuffle(); } cout &amp;lt;&amp;lt; t.printN().add1() &amp;lt;&amp;lt; endl; } 下面只會挑這次有用到的主題帶過一些函數，我這次完全沒用到字串、圖論、數學的函式庫。</description></item></channel></rss>