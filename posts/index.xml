<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on 蛋餅的競程隨筆</title><link>https://omeletwithoutegg.github.io/posts/</link><description>Recent content in Posts on 蛋餅的競程隨筆</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>Omelet</copyright><lastBuildDate>Fri, 13 Aug 2021 04:47:43 +0800</lastBuildDate><atom:link href="https://omeletwithoutegg.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>科學班三年之小小紀錄</title><link>https://omeletwithoutegg.github.io/2021/08/13/ckcos-10th/</link><pubDate>Fri, 13 Aug 2021 04:47:43 +0800</pubDate><guid>https://omeletwithoutegg.github.io/2021/08/13/ckcos-10th/</guid><description>CKCOS 10th 身為一個特殊班的學生，在畢業的時候還是會想打一些心得給未來的學弟參考吧。主要是希望對科學班有興趣的人可以了解科學班的一些權益與義務，在做這些決定的時候有更多資訊可以評估，也可以做好一些心理準備。
考進之前 在國小的時候，家長就有帶我去補一些比較超前的課，最主要的是陳立數學，一直上到國二（吧），一開始學的比較接近小學或國中的競賽數學，後來則是變成先修高中數學，大概把高中數學都講過一遍了。
另外還有補過一些物理跟化學，國三的時候因為要會考，跑去補了社會、國文、英文
想要去考的原因主要是被家長說服說可以證明自己的實力，沒有上也可以當成是練習，最後蠻意外的過了。
T分數其實不太記得了，只記得化學跟生物應該都蠻低的，有點靠數學撐起來的感覺。
我猜赫哲應該比我更清楚所以不要問我怎麼準備。
考上之後 在可以進入科學班之後，我有選擇是否要去建中科學班，因為畢竟是男校，也有考慮過要不要去師大附中之類的。不過大家都建議既然考上就去，我也就直接進入這趟不歸路了。
在錄取之後其實就可以不用讀會考了，但那時候我因為想留在班上所以就每天很隨意的寫複習考，後來會考也考了勉強可以進建中的成績。老實說覺得有點浪費時間，如果有考上的學弟記得把這段時間繼續拿來提昇自己，像是讀一些英文小說或是去看一些科普影片，又或者是直接去讀一些自己喜歡的領域的書，大概都比準備會考好。
科學班的特色 競賽 我想擺在第一個講是因為我對這個比較熟悉。
讀書會
建中的很多科競賽都有讀書會在支撐，例如數讀、物讀、資讀等等，真的建議 027 的學弟要好好利用這些資源，在暑假就可以開始聽這些精彩的分享。當然，學成之後也可以為之後的學弟帶來更精彩的分享，傳承薪火。 能力競賽
沒記錯的話科學班的學生好像要至少參加一科校內能力競賽，不過物化生只能選一科參加，通常校內會有初試、複試，接著就是北市能競，最後是全國能競。一年級的時候數學能競有到校內複試，但最後沒有變成校隊，也沒有當上資訊校隊，無緣市賽、全國賽、入營考；二年級成功變成資訊校隊，跑去撈了市賽跟全國賽的禮券回家。 公假
建中的老師大部分都對公假是很寬容的，一二年級能競期間班上幾乎都空的很誇張，直到能競一一結束才陸續回流。要小心的是記得最好跟任課老師還是說一聲，以免無聲無息的被當掉，而且不要請超過兩個月之類的超長假…真的會得奧林匹亞回歸症候群。 APMOC
一年級的時候被老師推薦來參加這個營隊，似乎是特殊班可以推薦一名，但我直到結束之後才知道這個營隊主要是來考試獲得數奧選訓營的資格的XD 我甚至在宿舍打 code 跟打 osu，超放鬆（？）有點對不起數學老師就是了。現在數奧的制度似乎不一樣了，不過如果有這種機會還是要好好注意一下… 所謂超前進度 高一高二上完高中三年課程是科學班標榜的特色之一，但在高三大部分的人並沒有變得比較輕鬆。高三可以去大學修自己有興趣的課，而且必須至少修一堂，但如果不是已經有大學念的人，可能就會因為升學壓力而沒辦法好好選自己想要的課，有些有想法的人可能還會在選課時被質疑。
專題 高一高二的時候我們必須分組完成一個專題，這個專題會在成果發表時上台發表，為此我們會在高一下學期就分組並各自尋找指導教授。高三時，必須完成個別科學研究的報告書，而且是個人完成，因此高三可以說是蠟燭 $N$ 頭燒的情況。我個人的專題真的做得超糟糕，只能說讓我認識到根本不會做科學研究，各位還沒進科班的學弟對於這件義務真的要謹慎思考(X)
畢業學分 科學班的選修學分基本上是多到滿出來，相對的分配給必修學分的時間就比較少。
我在高中有被當掉幾次國文跟一次歷史、一次體育，建議很常公假的人要記得去管畢業必修學分，不然三年級還要努力當學分精算師。
資格考 據說沒考過資格考會被退班，但其實能考進科學班而且有很大概的在聽課大概就可以通過資格考的數理科目了，很不幸的是我沒有通過英文科的標準，明明標準超低但我還是低了個兩三分。幸運的在高二我是IOI代表選手，因此可以免試掉資格考。
比較非學術的活動 聯誼…？ 沒有。至少我沒有參加過，可能太邊緣吧？班上有一些跟景美、北一、中山的line群組，但基本上就是加了一個禮拜之後就冷掉，我猜想要有好關係還是要靠自己嘍。
迎新 校內會有一個數資與科班聯合的迎新，另外還有多校聯合舉辦的數資聯合迎新，可以認識外校同學或是學長姐。
突然有點懷念數資聯合迎新在台大水樂園玩 RPG 的時候呢（？）
科學營 不知道什麼時候開始的傳統，似乎會去找北一的同學一起舉辦一個跟科學有關的營隊，我猜趁這個機會認識人是好機會。
社團 這件事又可以扯很長了，在這邊沒辦法提，總之在資訊社的回憶很多很美好，而且也很好笑。參加各種社團大概是有效與異性接觸的管道(?)
語癖與班上同學 升高中之後換了很多語癖，例如郭、嘍、顯然、電…等等，大部分都是從參加競賽或是同學參加競賽時與其他人碰撞所產生的有趣的火花。和這些強者在同一個班上沒有帶給我很多壓力（第一次段考就習慣後段了），不過我們這一屆來說班上很多同學都很有個性，例如會在班上運球(?!)或是大吼大叫的，有點像還在國中一樣，在高一高二的時候有點小困擾，但他們的實力也都是毋庸置疑的，和這些強者能夠同班實在是很榮幸，尤其是我個人覺得走物奧的人特別有想法，很佩服他們。
結語 高中三年選擇科學班，雖然有許多辛苦的事情，例如很難的數理考題、各種吵雜的班上環境、還有最困難的做專題，但我也享受到了許多科班的權益，例如大量的化學、物理實驗課（雖然我沒有喜歡做實驗），還有與同儕或是學長請教、討論的機會，以及我覺得最有價值的讀書會，在讀書會認識的不管是學長學弟還是同屆，都讓我成長許多。我相信世上沒有完美的選擇，但希望各位選擇與沒有選擇科學班的學弟都能不後悔。
今天晚上是謝師宴，如果有什麼我想補充的會再更新。</description></item><item><title>Debug Template</title><link>https://omeletwithoutegg.github.io/2021/08/08/debug-template/</link><pubDate>Sun, 08 Aug 2021 00:28:51 +0800</pubDate><guid>https://omeletwithoutegg.github.io/2021/08/08/debug-template/</guid><description>除錯模板的重要 這是一篇很短的廢文。
當你發現你寫出的程式有 bug 的時候，就會是你花上很多時間的時候。
尤其是在打 OI 的情況下，付出一點點時間讓 debug 變更簡單是有必要的。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // An AC a day keeps the doctor away. #pragma GCC optimize(&amp;#34;Ofast&amp;#34;) #include &amp;lt;bits/stdc++.h&amp;gt;#ifdef local #define safe std::cerr&amp;lt;&amp;lt;__PRETTY_FUNCTION__&amp;lt;&amp;lt;&amp;#34; line &amp;#34;&amp;lt;&amp;lt;__LINE__&amp;lt;&amp;lt;&amp;#34; safe\n&amp;#34; #define debug(args...) qqbx(#args, args) #define orange(args.</description></item><item><title>PBDS Split Join Is Slow</title><link>https://omeletwithoutegg.github.io/2021/07/23/pbds-split-join-is-slow/</link><pubDate>Fri, 23 Jul 2021 18:16:13 +0800</pubDate><guid>https://omeletwithoutegg.github.io/2021/07/23/pbds-split-join-is-slow/</guid><description>幫 pbds 上香 如題。
先說結論：
官網的 document 寫說 split 跟 join 時間是「poly-logarithm」，但是其實目前為止 GNU 的 pbds 預設的 split 是 $\mathcal{O}(N)$ 的，請看這篇文章。
不過有一些方法可以讓複雜度變回一次 split $\Theta(\log N)$，但是有一點麻煩。
前言 Policy-Base Data Structure 簡稱 pbds ，是 GCC 提供的一系列資料結構的 template，而今天要談的是當中的 tree 型別。
因為看到別人寫的 pbds 自訂 metadata_type 覺得很酷，因此想要來探索探索 pbds 一番。
大概了解 node_update 怎麼運作之後，我試著去寫了 氣球博覽會，因為需要區間查詢，我使用了 tree::split(key, other) 和 tree::join(other)，沒想到全部吃 TLE，研究一番之後發現下面這樣的 code 就會執行不完了：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include &amp;lt;bits/extc++.</description></item><item><title>IOI2021</title><link>https://omeletwithoutegg.github.io/2021/07/01/IOI2021/</link><pubDate>Thu, 01 Jul 2021 07:11:55 +0800</pubDate><guid>https://omeletwithoutegg.github.io/2021/07/01/IOI2021/</guid><description>IOI 2021 只是想打一下IOI的心得而已
可能還是流水帳請多多包含(?)
Before 其實到二模都還很擔心會不會當上國手，還有擔心自己的實力到底有沒有變強
因為一模是因為靠奇怪互動線性遞迴的題目才上去，啊二模唯一寫出來的題目也是IOI根本不考的東西
另外很好笑的是我這學期比前兩個學期還努力追學分，因為之前太混了XD這學期剛好要全部過才夠畢業的學分竟然夠了
謝謝所有即使我交作業很混還是讓我過的老師!
四模拿了一個不錯看的分數，如果我在國手線下150分甚至可以抵回來(?)因為這件事我大概可以claim二階很好追分(並沒有)
因為疫情的關係國培燒雞，我超期待的說，還想說今年想再寫一次國培紀錄QQ
唯一比較算是訓練的東西是tmt(卡恩)和我們google meet討論一些題目
第一次meet的時候是先丟題目討論，然後也講了去年的模考題，像是expected LCS那題好像就是暴力DP(雖然我不知道複雜度是什麼)
ZCK真的超級積極，丟了好多POI或是JOI、CSAcademy的題目，好多題目我都是第一次見
基本上沒有什麼想法，不過就算只是聽解也蠻困難的，有一些證明因為卡恩也是當場想所以有點久，我也沒注意聽就做自己的事了XD
第二次meet主要討論IOI2019，有事前看過題目之後感覺就好一點了(?)不過因為一直想要把line得多一點分所以也沒有太專心(X
感謝卡恩與zisk讓我腦袋有在動(?)
Day0 看到好久沒看到的ZCK與wiwi還有(隔著口罩)呼吸到新鮮空氣心情還不錯
晚上是練習賽
題目都跟去年一樣
唯一不一樣的是一題BFS
結果還不能破台，好好笑
不過差點在賽中因為唬爛弄出正解(?)
結束之後問了一下ZCK解，果然他會只是剛好在兩小時的最後才想到(?)
Day1 day1前一天打了一場div.2寫完ABCD看完F猜他的式子很漂亮就亂推AC了 然後E寫好久總算寫完
這讓我感覺狀態還不錯，對我來說可能寫水題也是一個穩定心情的方法(?)
我們三個人還有監考人員占用一整個會議室，間隔開來坐
原本是用acer的筆電但是後來變成msi的樣子，因為好像跑比較快
開賽的時候先打了模板
ZCK帶來的鍵盤的聲音來讓人滿是壓力XD
然後看紙本題目想
然後&amp;hellip;就沒有然後了
parks看起來有點困難先放著了一下
candies看起來就很經典題，而keys也是沒有什麼想法
一直畫圖交替想兩題，大概花了一小時還是沒有什麼想法
三個人維持了安靜好久，然後ZCK開始動鍵盤的時候有夠可怕
只好姑且先去撈分，撈了keys的基本分跟candies的一點分數
仔細看了parks發現可以弄成類似2SAT的東西不過實作異常麻煩，而且我也忘記tarjan怎麼寫甚至跑去寫kosaraju(?)
不過花了好久拿到了70分，我覺得還算值得
接下來就繼續把candies的分數撈一撈，有一個subtask似乎是我唬爛得到的分數賽後才發現，唬爛就是爽
最後一直在想candies $l=0, r=n-1$ 的subtask就結束了
結束之後有點怕自己又是銅牌命，趕快問分數，結果大家都一樣好好笑，而且都是銀牌左右的分數，看來 day1 實在蠻難的
Day2 day1/2中間似乎吃了雙豚還是山嵐
day2前一天因為睡不著跑去看了IOI2014之類的，然後發現做不出來趕快看解以免影響比賽，好好笑
心中不想太多的雜事，很快就開賽了
打完模板開始讀題目，然後就遇到很欠嘴砲的水題(?)大概在25分鐘內就AC了，有點帶給我小小信心(X
剩下兩題開始讀
registers實在有點長，當然只能先去看dungeons
因為想說贏了好像強度就會加倍，所以原本想說只會贏log次，寫到一半突然覺得怪怪
後來發現應該是「贏了輸過的人的話那麼強度會加倍」，然後就不知道怎麼做了
跑去讀registers題敘發現實在超級長，結果是要實作取min跟排序，感覺就是跟19的vision或是12的odometer這種題一樣噁心
想一想覺得應該可以做很多平行化，而且去年的國培蔡孟宗甚至還講過平行化的bitonic sort，結果今年沒國培，好慘
先做了取min的subtask，實作比較的方式我是先做減法，然後就可以有絕對值，就有min了
平行化大概需要170個操作左右，和最後一個subtask要求150只差一點但是怎麼都壓不過，傷心
後來看著dungeons一直想他怎麼樣會加倍，突然就想到2的冪次分層
也就是說如果現在的強度 $z\in[2^i,2^{i+1})$ 就說現在在第 $i$ 層，那一定會輸 $2^{i+1}$ 以上的人、贏 $2^i$ 以下的人，而一旦贏了中間的人就會跳到下一層!</description></item><item><title>線性遞迴淺淺談</title><link>https://omeletwithoutegg.github.io/2021/02/13/linear-recurrence/</link><pubDate>Sat, 13 Feb 2021 16:28:29 +0800</pubDate><guid>https://omeletwithoutegg.github.io/2021/02/13/linear-recurrence/</guid><description>本篇將會介紹快速求線性遞迴數列某項的方法，以及Berlekamp-Massey演算法和一些在矩陣上的應用。
主要是一個整理資料還有學習筆記的功能，還有老實說這東西算是偏門又毒瘤，追求實用的人不要看XD。
Fast Linear Recurrence 首先先來介紹如何快速求線性遞迴。
定義 已知序列 $ \langle a_n \rangle $ 滿足遞迴關係 $ \displaystyle \forall i \geq k, a_i = \sum _ {j=0} ^ {k-1} s _ j a _ {i-1-j} $ ，並且已經給定 $s$ 跟 $a_0, a_1, \dots, a _ {k-1}$
現在想要求 $ a_n $ 的值，其中 $ 1 \leq k \leq 5000, 0 \leq n \leq 10^9 $
許多人大概會很快想到矩陣快速冪，複雜度是 $ \mathcal{O}(k^3 \log n) $。但我們要更快！
通靈 定義一個函數 $G$，對於形式冪級數 $f(x) = \sum c_i x^i, G(f) = \sum c_i a_i$ 。</description></item><item><title>IOICAMP 2021</title><link>https://omeletwithoutegg.github.io/2021/02/06/IOICamp-2021/</link><pubDate>Sat, 06 Feb 2021 18:07:48 +0800</pubDate><guid>https://omeletwithoutegg.github.io/2021/02/06/IOICamp-2021/</guid><description>IOIC 2021 去年就來過一次了，今年再次造訪這困難的營隊。
其實幾乎沒有什麼特別不一樣的地方，不過我想說還是寫個短短的紀錄。
吃的東西 IOIC有準備早餐、午餐跟晚餐讓我們不用擔心時間太可怕的問題（？）
然後還有下午的點心，大致上都不錯吃，除了有魚刺的便當QQ
可惜的是去年會在吃東西的時候放影片，今年可能是因為疫情怕我們吵雜起來，甚至還讓我們坐梅花座。
上課 這次上課的主題和去年比較起來，好像少了常數優化、隨機、分塊之類的，但是多了flow跟game theory。
老實說很多東西都是聽過但是不那麼熟QQ
喵喵時間不知道選訓有沒有機會再聽到一次(X
而且講義幾乎都是「參考」前幾年的（雖然本來就應該要這樣，滾動式稍微有更新就好）
這次覺得比較有聽到的應該是burnside lemma跟flow還有賽局的東東。雖然賽局的題目好像都跟上課沒什麼關係QQ只要會mex跟xor和通靈（重要）就好。
模擬賽 第一天趣味賽還可以，賽到一個隨機bubble sort的debug題
接下來兩天天都爆炸，真的是實力檢討大會QQ
第四天個人賽其實還不錯，但是就輸balbit，最後忙著猜pA來不及想I或是H QQ通靈難死
第五天，放鬆打（？）反正好幾個人都在我們上面習慣了。
這種長時間的比賽幾乎大家的開題都差不多，然後我很習慣用subtask來確認有沒有寫錯，只有整題的feedback超難@@
最後差一點用題數贏，不過輸在就是輸在DP沒有想好QQ
發獎品的時候拿到的是除蟲網（？）是不是要成為AY傳人了(#
賽後補題 基本上快把全部的題目都補完了，剩下兩題吧（？）
在IOIC的judge搶topcoder好好玩，尤其是在用毒瘤演算法的時候XD
老實說上課幾乎都在刷題或是補題，我覺得這樣也許有點糟糕，不過我相信補題也是一種收穫。</description></item><item><title>jngen</title><link>https://omeletwithoutegg.github.io/2021/01/24/jngen/</link><pubDate>Sun, 24 Jan 2021 01:17:43 +0800</pubDate><guid>https://omeletwithoutegg.github.io/2021/01/24/jngen/</guid><description>jngen 最近在生107北市賽題目的測資想放到TIOJ上面，其中一題是關於找兩個凸包的兩條內公切線交點。
因為不太知道測資怎麼生，又想到之前東東有提過jngen這個東西，因此就把他拿來生成我需要的凸包了。
我覺得他的函式、方法都很乾淨，然後因為生測資仔細看了一下文件，就想說把他貼到部落格推廣一下（X
Usage https://github.com/ifsmirnov/jngen
要使用jngen，你只需要下載jngen.h並引用標頭檔。下載來的標頭檔可以放在 /usr/include 之類的地方，或是跟你的C++原始碼相同目錄當中。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include &amp;#34;jngen.h&amp;#34;#include &amp;lt;iostream&amp;gt; using std::cout, std::endl; int main(int argc, char *argv[]) { parseArgs(argc, argv); int n, m; getPositional(n, m); Tree t = Tree::bamboo(n).link(n - 1, Tree::star(m), 0); if (getOpt(&amp;#34;shuffled&amp;#34;, false)) { t.shuffle(); } cout &amp;lt;&amp;lt; t.printN().add1() &amp;lt;&amp;lt; endl; } 下面只會挑這次有用到的主題帶過一些函數，我這次完全沒用到字串、圖論、數學的函式庫。
Random jngen跟testlib一樣會使用你執行時傳入的參數做一些hash之類的當作偽隨機的種子，所以如果不是每次呼叫main都用不同參數呼叫，就得乾脆把一個種子在一個generator裡面重複利用。</description></item><item><title>Cppbugs</title><link>https://omeletwithoutegg.github.io/2021/01/21/cppbugs/</link><pubDate>Thu, 21 Jan 2021 00:11:31 +0800</pubDate><guid>https://omeletwithoutegg.github.io/2021/01/21/cppbugs/</guid><description>這篇是想放一些神奇的C++語法錯誤
也可能會放基礎的(X
然後可能會是動態更新
lambda capture (Update: 2021/1/21)
這似乎是因為capture到值的時候還沒成功建構func這個變數，所以會出問題
1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include &amp;lt;iostream&amp;gt;#include &amp;lt;functional&amp;gt; using namespace std; signed main() { function&amp;lt;void(void)&amp;gt; func = [=]() { int x; cin &amp;gt;&amp;gt; x; cout &amp;lt;&amp;lt; &amp;#34;ok &amp;#34; &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;; if(x) func(); }; func(); } const reference &amp;amp; implicit conversion (Update: 2021/1/21)
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include &amp;lt;iostream&amp;gt; using namespace std; struct Data { int x; Data(int val = 0) : x(val) {} int calc() { return x * 2 + 3; } }; istream &amp;amp; operator&amp;gt;&amp;gt;(istream &amp;amp;I, const Data &amp;amp;data) { return I &amp;gt;&amp;gt; data.</description></item><item><title>BambooFox CTF 2021</title><link>https://omeletwithoutegg.github.io/2021/01/19/bamboofox-ctf-2021/</link><pubDate>Tue, 19 Jan 2021 12:09:52 +0800</pubDate><guid>https://omeletwithoutegg.github.io/2021/01/19/bamboofox-ctf-2021/</guid><description>BambooFox CTF 2021 這次是第二次參加BambooFox，不過事前都沒有做什麼練習wwww本來想說去OT之前推薦過的網站練習一些基礎，但是忘記是什麼網站了888
依然是跟joy一隊，然後另一個隊友變成casper了
今年似乎是大進步，不過我懷疑只是因為考很多演算法題orz
來講一些有解的題目，很抱歉我不知道怎麼讓我的code折疊起來XD
Gamer&amp;rsquo;s Cipher 一開場先開了 P versus ♯P，雖然查到解法可是精度跟速度都壓不過去，所以只好放棄改開別題。
然後第一個成功的題目就是Gamer&amp;rsquo;s Cipher這一題。
casper說看懂code就解完了（？）不過他沒辦法編譯所以也不知道怎麼辦。
總之我也跑去下載code看，然後查了好一下子怎麼編譯Haskell（記得編譯要加-dynamic的flag），成功編譯之後努力看懂code。
看起來像是用Nimber對字串加密，
明文和密文的長度都是$n=51$，然後他的key必須要是$n$階的原根，所以我寫了一個腳本看哪些是合法的key。
1 2 3 4 5 6 7 8 #!/bin/bash # search possible keys len=51 printf &amp;#34;len = %d\n&amp;#34; $len for i in $(seq 0 255); do echo $i printf &amp;#34;%51s\n%d\n&amp;#34; &amp;#39;&amp;#39; $i | tr &amp;#34; &amp;#34; &amp;#34;a&amp;#34; | ./Main 2&amp;gt;/dev/null &amp;gt;/dev/null &amp;amp;&amp;amp; printf &amp;#34;i = %d\n\n&amp;#34; $i &amp;gt;&amp;gt; possible.txt done 但是關鍵的加密部份怎麼樣都不確定我看的對不對，所以我先把nimber的乘法表弄成一個文字檔存起來，再另外寫一個python跟Haskell的輸出比對</description></item><item><title>TIOJ 1597</title><link>https://omeletwithoutegg.github.io/2020/12/30/TIOJ-1597/</link><pubDate>Wed, 30 Dec 2020 12:57:24 +0800</pubDate><guid>https://omeletwithoutegg.github.io/2020/12/30/TIOJ-1597/</guid><description>變動的過路費 https://tioj.ck.tp.edu.tw/problems/1597
Description 給你一張有向圖，每個邊會有隨時間變動的權重，並且邊的權重對時間是一個線性函數。
再給你兩個點 $A,B$，現在你想要從 $A$ 走到 $B$ 再走回 $A$，
問你在時間 $[0, D-1]$ 中，最長的最短路徑和最短的最短路徑相差多少。
保證在時間內的邊權都是非負整數，並且答案不會超過long long。
Solution 這題很久以前就跟蕭梓宏討論過了，不過我怎麼寫都會吃WA 0分
今天#define int ll結果就拿了67分XD仔細檢查才發現原來一條邊的邊權可以不在int的範圍內但我卻用了int
忘記開long long真的Orz
因為線性函數的和還是線性函數，考慮所有的「路徑」，他們都代表一條對時間的線性函數。
而某個時間點的最短路徑就是這些直線的 $\min$。也就是說，所有時間點的最短路徑是所有路徑的線性函數的下凸包(lower envelope)
把這個凸包建出來似乎不是可行的（？）所以就考慮三分搜找出最大值。至於最小值一定是在端點，所以相減就是答案了。
好像有卡一些常數QQ我還得判如果dijkstra跑到終點就return、三分搜遇到相同就break;之類的，不知道是不是TIOJ主機變慢了QQ
AC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 #pragma GCC optmize(&amp;#34;Ofast&amp;#34;) #include &amp;lt;bits/stdc++.</description></item><item><title>TIOJ 1284</title><link>https://omeletwithoutegg.github.io/2020/12/23/TIOJ-1284/</link><pubDate>Wed, 23 Dec 2020 13:31:04 +0800</pubDate><guid>https://omeletwithoutegg.github.io/2020/12/23/TIOJ-1284/</guid><description>賽車問題 https://tioj.ck.tp.edu.tw/submissions/231136
Description 現在有 $n$ 輛往右邊跑的賽車，每一輛都有其固定的車速以及起始位置。
你想要知道在從現在開始的所有時刻中，什麼時候最領先的車子跟最落後的車子的距離會最短。
可以假設車速都不相同
Solution 首先每個車的位置對於時間是一個一次函數，而「每個時刻最前面的車的位置」和「每個時刻最後面的車的位置」就是這些直線形成的上下凸包（envelope）
這題可以用三分搜寫掉（？）
不過可以把凸包真的建出來做。最佳的答案一定會出現在凸包的頂點上，或是邊界（也就是時刻=0的時候）
於是建出來之後用雙指標依照x由小到大檢查上下凸包的距離就可以了，記得要處理邊界的case。
這樣雖然時間複雜度還是有 $\log$ ，不過是 sort 的 $\log n$。
AC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 #include &amp;lt;bits/stdc++.</description></item><item><title>Miku Cursor on Arch Linux</title><link>https://omeletwithoutegg.github.io/2020/12/10/arch-miku-mouse/</link><pubDate>Thu, 10 Dec 2020 17:05:06 +0800</pubDate><guid>https://omeletwithoutegg.github.io/2020/12/10/arch-miku-mouse/</guid><description>在Arch的初音游標 因為在Windows有下載一個可愛的初音游標，但是之前換成Ubuntu後就沒有把他裝回來，覺得很可惜。
因此現在換成Arch之後，想說應該有一些社群的package可以用了，直接抓來就好，但是怎麼google都google不到？
因此大概花了半天去解決他，想說在這邊做個小筆記以免下次重裝的時候重摸一遍。
找到巴哈姆特上面的原始檔（是.ani跟.cur） 利用cursor-converter把.ani和.cur換成x-cursor的icon類型 手動把對應的圖案複製到 ~/.icons/$THEME/cursors 裡面
如果不知道哪個檔名是什麼的話，可以先複製別的theme的資料夾，接著用 xcur2png 換成 png看某個檔案實際上是對應哪個圖案。 加上 index.theme。反正只要有Name就可以了吧我猜 中間踩了各種怪東西XD
我原本先去下載了其他主題，想說看別的主題的游標應該是什麼對應到什麼，尤其是有動畫的。
不過似乎有動畫的游標和沒動畫的檔名一樣QQ
然後有找到一個ani2png，但是畫質會爆炸而且沒有幫忙放到對應的位置（雖然最後也是我們自己放到對應的位置）
接著找到CSDN上面有人說用CursorXP從Windows上面把游標主題包起來，接著在Linux下載一個用來轉換成icon類型的Perl腳本，
會轉換成一個tar.gz然後就可以安裝的樣子了，不過還是偏糟，從Windows上面看就發現畫質還是大小大爆炸了
最後終於走對路，找到github上面一個比較新的repo是把.ani跟.cur轉成linux的x-cursor檔案
真是要感謝他們www
話說我發現其實可以直接把檔案放到github上面，這樣也可以推廣或是找人來修改(X
裡面有好多icon是從breeze主題抄過來的，畢竟應該都是很少看到的icon所以應該不會影響太大，但是想包成AUR或是什麼的時候好像就得在乎一點一致性ㄌ，所以希望放到github上之後有人可以把其他那些icon改成統一的風格owo</description></item><item><title>Hugo Framework</title><link>https://omeletwithoutegg.github.io/2020/11/25/hugo-framework/</link><pubDate>Wed, 25 Nov 2020 11:20:47 +0800</pubDate><guid>https://omeletwithoutegg.github.io/2020/11/25/hugo-framework/</guid><description>Hugo! 似乎因為casper而嘗試從hexo跳槽到hugo。
hexo似乎是對windows比較友善？檔名都一堆底線之類的
啊hugo好像是對macOS比較友善QQ
Startup Hugo沒有預設的theme，所以如果不想無中生有一定要裝一個theme。
我原本用的Hexo Theme Cactus在Hugo也有人維護一個theme，不過feature就沒有那麼多了。
總之試著寫一個markdown然後 hugo server
驚訝的發現他超快XDD應該說是Hexo太慢了，我想node.js天生本來就有一些缺點吧。
既然可以拋棄噁心的 node_modules 還有底線，而且還可以讓他 generate 的時間變超快，我決定試看看能不能把整個網站從Hexo改成用Hugo寫，並且同時大部份東西仍然保持跟之前相同，例如Repo、網址、code highlight、search/tag feature等等
一些遇到的問題 Hard Line Break 這個蠻可怕的。在用Hexo的時候沒什麼感覺，但是我的Markdown全部都是用直接換行來換行；而Hugo預設不是，也就是說他應該要用兩個空格或是反斜線的方式來換行。這其實是Markdown預設的換行方式，但是真的很不習慣，不知道該怎麼說。而且也不可能一個一個檔案調整XD Solution:
一開始查到可以在 config.html 裡面加 1 2 [blackfriday] extensions = [&amp;#34;hardLineBreak&amp;#34;] 不過都沒有效。後來才知道Blackfriday是Hugo原本拿來render markdown的東西，而某次更新之後已經換成Goldmark這個套件了。 基於我找不到怎麼在Goldmark加上 Hard Line Break 的選項，我選擇改回用Blackfriday render就好。 1 2 [markup] defaultMarkdownHandler = &amp;#34;blackfriday&amp;#34; 沒有search Solution:
Google了一陣子。中間找到這個使用Fuse.js的一個實作，不知道為什麼是放在討論區：https://gist.github.com/eddiewebb/735feb48f50f0ddd65ae5606a1cb41ae
雖然蠻快找到，不過我踩了很多雷。
首先是他寫法是 define &amp;quot;footerfiles&amp;quot;，但是我的theme的基底模板沒有block &amp;quot;footerfiles&amp;quot;的區塊。所以我目前是把那段script跟他定義的main放在一起。</description></item><item><title>TIOJ-1978</title><link>https://omeletwithoutegg.github.io/2020/11/22/TIOJ-1978/</link><pubDate>Sun, 22 Nov 2020 21:39:59 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2020/11/22/TIOJ-1978/</guid><description>邀請函（Invitation） https://tioj.ck.tp.edu.tw/problems/1978
Description 給你一張圖，求出最大點獨立集。
點數最多80
Solution 我本來一直以為這題是一般圖最大匹配，不過今天仔細看之後發現不是，而且一般圖沒有最大匹配=最小點覆蓋的結論。
不過有最大點獨立集$+$最小點覆蓋$=|V|$。
吳邦一教授講過關於最小點覆蓋的一個回溯法，於是我想說把他拿來用。
其實這個演算法也很簡單，就每次挑最大degree的點出來要選或者不選就好，這樣的話複雜度聽起來會是$\mathcal{O}(2^n)$之類的。
不過我們可以先做以下幾個處理(簡化)
degree 0的點直接拔掉。 degree 1的點，選他不如選他唯一的鄰居 剩下假設最大的degree是2，那所有點的degree都是2了，也就是說是一堆環，可以判掉 於是乎我們只剩下最大degree至少是3的case了。
如果不選那個點的話，那他的鄰居都必須要選，可以列出遞迴式$T(n) = T(n-1) + T(n-4) + f(n)$，$n$代表還沒決定要不要選的點的數量，$f(n)$代表維護上面那些東西需要的時間。
解這個遞迴式可以直接DP，或是利用特徵方程式$\lambda^n = \lambda^{n-1} + \lambda^{n-4} \Rightarrow \lambda^4 - \lambda^3 - 1 = 0$，他最大的實根大約是1.38左右，所以我們dfs的複雜度最多是$\mathcal{O}(1.38^n f(n))$。用蠻naive的寫法$f(n)$會是$\mathcal{O}(n)$(我也不知道怎麼快速維護XD)，$n=80$代進去$80 \cdot 1.38^{80}$似乎幾乎是不行，不過不知道為什麼會AC而且竟然只輸BB跟塗大為的submission XD
寫完之後，身為admin看到幾乎所有人都是用random，心情很複雜(#
還有BB跟waynetuinfor的演算法似乎是轉成clique在做，不知道大學打ICPC有沒有機會搞懂。
AC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 // __________________ // | ________________ | // || ____ || // || /\ | || // || /__\ | || // || / \ |____ || // ||________________|| // |__________________| // \###################\ // \###################\ // \ ____ \ // \_______\___\_______\ // An AC a day keeps the doctor away.</description></item><item><title>二分圖最大權匹配</title><link>https://omeletwithoutegg.github.io/2020/11/16/Maximum-Weight-Bipartite-Matching/</link><pubDate>Mon, 16 Nov 2020 13:31:22 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2020/11/16/Maximum-Weight-Bipartite-Matching/</guid><description>我只是想做一下筆記
然後我還是不會縮花/帶花樹演算法，所以我也不會一般圖最大權匹配
先備知識 看得懂$\sum$
然後會(不帶權)二分圖匹配的匈牙利演算法
Kuhn Munkres 這裡介紹KM演算法，而若要求解二分圖上的最大權匹配等相關問題可以透過下面的演算法轉換成KM的模型。
KM演算法是用來求一張完全二分圖的最大權完美匹配的演算法，其中邊的權重都是非負的。
演算法轉換 最大權匹配 $\to$ 最大權完全二分圖完美匹配(非負邊權)
把不存在的邊以及負邊權的邊邊權設成0 最大權完美匹配(有負邊權) $\to$ 最大權完全二分圖完美匹配(非負邊權)
把不存在的邊邊權設成0，並且把剩下每條邊的邊權加上一個夠大的數$M$，這樣就會傾向於選出儘量多邊。最後的答案記得要扣掉這些$M$ 可以想想看為什麼上面兩種轉換是對的
把問題敘述再好好的寫一遍
Description 給你一張完全二分圖 $K _ {n,n}$ ，每條邊 $e = (x_i,y_j)$ 有邊權 $w _ e$
請選出 $n$ 條邊 $e_1, e_2, \cdots e_n$ 兩兩不共端點，使得邊權和$\sum\limits _ {i=1}^n w _ {e _ i}$最大
對偶問題 首先引入頂標的概念。對於每個頂點$v$我們維護一個數字$L_v$，稱為頂標。
在演算法的過程中，我們必須妥當的維護頂標，使得對於所有邊$e=(a,b)$都有$L_a+L_b \geq w_e$
那麼很顯然的，對於任何一種合法的頂標來說，頂標的總和會大於等於最大權完美匹配的值。
因為對於任何匹配$M$都有$\sum\limits _ {e\in M} w_e \leq \sum\limits _ {e\in M, e = (a,b)} (L_a + L_b) \leq \sum\limits _ {v\in V} L_v$</description></item><item><title>ARC-106</title><link>https://omeletwithoutegg.github.io/2020/10/26/ARC-106/</link><pubDate>Mon, 26 Oct 2020 19:44:23 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2020/10/26/ARC-106/</guid><description>AtCoder Regular Contest 106 最近一直被ZCK推坑，vir了好幾場ARC
然後打完AGC才發現自己rating太低unrated，爛死XD
結果打完這場還是不到能夠rated的標準1200 QQ
然後想說寫一下題解好了 :P
A. 106 Statement 給你$N$，問你有沒有正整數$A,B$使得$3^A+5^B = N$，$N \leq 10^{18}$
Solution 因為$A,B$最多都是$\log$量級的所以亂枚舉就好了
基本上也不太會溢位
AC CODE
B. Values Statement 給你一張無向圖，還有每個點一開始寫的數字$a_i$
每次可以把兩個相鄰的點$x,y$一個數字+1一個數字-1
問你是否能讓最後第$i$個點寫的數字是$b_i$
$1 \leq N \leq 2 \times 10^5$
$0 \leq M \leq 2 \times 10^5$
$-10^9 \leq a_i, b_i \leq 10^9$
Solution 只要一個連通塊裡$a_i$的總和和$b_i$的總和相同就做的到
於是用 dsu 維護總和
AC CODE
C. Solutions 一開始想說這題題敘很長先跑去做 pD
結果是水題，不過還是WA慘QQ
Statement 「給你$N$個線段，請選出最多條兩兩完全不相交的線段。。」
現在有兩種演算法$A,B$分別嘗試解決上述問題：
$A$演算法：按照右界由小到大排序，並按照順序考慮線段。如果現在考慮的線段不會和當前的解的任何一條相交，則將其加入當前的解中。輸出最後的解的大小 $B$演算法：按照左界由小到大排序，並按照順序考慮線段。如果現在考慮的線段不會和當前的解的任何一條相交，則將其加入當前的解中。輸出最後的解的大小 請構造一組輸出使得「$A$輸出的答案 - $B$輸出的答案 = $M$」</description></item><item><title>Recent</title><link>https://omeletwithoutegg.github.io/2020/10/06/after-IOI/</link><pubDate>Tue, 06 Oct 2020 23:25:02 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2020/10/06/after-IOI/</guid><description>好久又沒有發文了
來講講上一次發文之後我都在做什麼好了
Before IOI 首先在8/17開始所謂的賽前集訓
總共為期三周，分別在台南、新竹和台北
在台南的前幾天是一個奇怪的教授要我們寫爛題目
還得用PC2 judge，不過我們最後都變成在玩python in one line了
之後他又講了有關點連通、邊連通跟degree之類的關係
後來吳邦一教授來講課，他講了一些IOI的題目還有一些常見的trick，例如四邊形之類的
那時候就能看出來我超爛(((
週末是在師大上王柄豐的課
這時似乎已經累計很多他丟的題目沒寫了QQ
下一個禮拜是在清大和交大
第一天韓永楷教授早上早上上的有點基礎，不過下午上的東西還蠻有趣的
另外有遇到吳宗達跟盧可瑜(?) 還聽到了奇怪的洋蔥式資料結構
第二天是蔡孟宗教授講parametric search跟matroid之類的東西
雖然matroid和submodular的東西我是幾乎聽不懂，不過我覺得這天的課都還算是有趣
第三天是蔡錫鈞教授，我一開始感覺他不是很友善，然後外加上我超想睡，而且其實頗難的，課聽進去的沒有多少QQ
下午的時候謝旻錚教授找了hank來跟我們virtual IOI2017
想當然而我被打爆，而且AY還贏了hank，超強orzzzz
晚上被教授請客XD不過餐廳有點太高級不敢吃什麼東西
周五的時候謝旻錚教授講了一些計算幾何的東西，感覺只要提到簡單多邊形就是超級噁心的@@
回到台北之後都是王柄豐的課了
終於聽到了toptree，不過還沒有實作過QQ
然後也把之前ICPC的題目程式碼給補了一點點
啊IOI也vir了幾場 可是總感覺沒有胸有成竹的感覺
只能說IOI比成這樣真的是自己練習不足啊
在集訓完到IOI這中間有空一個禮拜，而且還是在開學期間，實在有夠尷尬
總之我把他當成有公假，而我們的校內賽初賽也是在這個禮拜，正好可以回去確認狀況以及去校內培訓玩玩(?)
話說我們這屆的人能出校內賽其實算神奇
原因是因為我們幾個有進過全國賽不會在北市賽佔到建中的名額，所以老師就找我們來出題目
雖然我們出的題目好像沒有說很好QQ
不過初賽感覺問題比較像是當天流程沒有仔細check好QQ
After IOI 回到教室有種更尷尬的感覺
不過總之周一下午跟著蕭梓宏他們跑去台大上了微積分一
前面幾堂講的實在好基礎(#)
另外我周三和周五的早上有去旁聽線性代數
上了幾天的課之後
我發現我就算沒去台大修課，大家也剛好會去，因為班上沒人自然就沒辦法上課
再加上我也沒有修這學期的數理課程，事實上我幾乎沒有課需要上啊OAO
要擔心的只有國文/英文/藝術與生活/體育，我覺得英文應該是最佳選擇
我上微積分的第二個禮拜就開始感覺困難了orz
總之希望是可以好好修完
校內賽複賽變成是有點尷尬，因為我們流程是我們出題、老師選題，啊又剛好沒選到太多水題或是學長的題目QQ
我覺得我應該當初直接寫出來說推薦可以直接選哪些題
而且老實說也應該出幾題培訓有講過的東西，自己的盲點真的自己看不到@@
大家當天的分數普遍都很低
不過至少最後預期會進的人大部份都進了，還算是幸運
在中秋連假的時候我買了一把新鍵盤，是ducky one的60%紅軸，用起來真的只能說超爽的wwww紅軸軟又軟，啊鍵位也都整個習慣了之後小巧的它就很有魅力wwww
現在我的書包裡面除了筆電跟軟軟以外還多了鍵盤這個常駐物品
Esc離手指超近而且方向鍵又被拔掉超爽的XDDDD
可是有一個重大問題是用注音打字的時候我習慣按方向鍵XDD 所以還是得跑去弄組合鍵
總之，希望我以後還能夠常常用到這把鍵盤，還有希望他能陪我很久</description></item><item><title>國培 week 2</title><link>https://omeletwithoutegg.github.io/2020/08/05/TOI-2020-7-26-weekend/</link><pubDate>Wed, 05 Aug 2020 11:39:26 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2020/08/05/TOI-2020-7-26-weekend/</guid><description>國培第二周 原本的課是在周六和周日的上午
似乎因為需要電力檢修還是什麼的都被移到周日了
週日 上課的教授是王柄豐，他都會先丟給我們一些題目然後過幾個小時再來叫我們上台
原本是兩天各三題ICPC final的題目，不過全都被移到周日總共是六題
我也忘記他丟哪些題目了，不過我記得我早上上去講一個rerooting+分塊凸包優化的算法之後就被重剖作法電爆了QQ
下午我找到一題最短路去講，後來以為只會經過一條邊不用跑最短路，結果被教授抓到假解XD不過只要跑最短路應該是對的
教授也跟我們說，上他的課想到一個做法不一定要急著實作出來，只要把想法確認好就好
花了整個早上實作分塊凸包優化的我直接中槍QQ
END 中午第一次在國培吃便當XDD 好油(?)
之前都是吃拉麵(#
另外我們這禮拜有配飯吃看動畫，油上加油呢
看了RE:0、魔王什麼的、史萊姆，還有格里爾的賢者時間XD，超污
晚上跑去吃山嵐，第一次點赤湯，沒想到意外的不那麼辣，看起來明明是全紅的www
然後東東曹宸睿好像要趕去報到AIS3就散會ㄌ</description></item><item><title>國培 week 1</title><link>https://omeletwithoutegg.github.io/2020/07/20/TOI-2020-7-18-weekend/</link><pubDate>Mon, 20 Jul 2020 09:35:32 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2020/07/20/TOI-2020-7-18-weekend/</guid><description>國培第一週 週五 前一天東東跟曹宸睿跑去住宿，似乎是住在捷絲旅（好好），不過他們的晚餐費只有一百元XD
至於我則是在考完資格考後又忙著去YTP初賽，並且發現自己被最後一題電爆QQ
因為17號是鳥人食雞日所以我拉一些人去ㄘ鳥人，加上加點的總共可以有八片雞肉叉燒，超爽。
週六 前一天不知道吃了什麼毒超早睡OAO可是起床又超晚，最後遲到了十幾分鐘到，不過好像是沒差owo
早上是王弘倫教授講IOI的詳細規則，詳細到我不知道怎麼形容。
他還講了四模pC的題解(?)還有丟一題 Christmas 類似斜率優化但是好像有四邊形優化的性質，總之一整個好強OAO。
下午跑去西門町訂做西裝，原本以為會是常常看到的那種沒什麼裝潢普通店面（海派那種），結果是一家看起來超高級的西裝店，
好像叫ElegaZzle，之前應該是完全沒聽說過
我們一群人都是穿著T-shirt加短褲還有布鞋，我一整個鄉下人長見識了(?)
選定布料還有樣式的時候選有夠久，三個人一起選還是有選擇障礙，尤其因為選擇超多，大概有幾十種布料可以選擇
選了西裝的布料後又得選領口的樣式、襯衫的布料、襯衫的樣式、鈕扣、袖口要繡上的名字blablabla。
總之做了很困難的選擇之後來到更困難的部分：量尺寸
我超胖QQ太sad了，一開始大概量了一個尺寸換上去後肚子那邊好緊（眼睛也看的出來）
然後我還被要求在門口量尺寸QQ，超級羞恥play(#
順帶一提這家店有一個很酷的房間可以掃描人體的3D模型，還有跟手機的藍芽弄一些特效，聽說曹宸睿的手機有閃退一次XD
我們每一餐的餐費是一百元，我們決定把午餐和晚餐合在一起變成兩百元，這樣就可以ㄘ拉麵了，
話說我這天也沒吃早餐，只靠一餐拉麵果腹，爽！
好笑的是今天又跑去ㄘ鳥人（因為西門町太近ㄌ而且他們上次剛好錯過）
這天嘗試了辛白湯，實在是頗辣的不過還不錯吃啦
然後後來跑去踩踩安利美特、又走到北車地下街Y區，看到好多軟軟&amp;lt;3&amp;lt;3
不過都沒買任何東西感覺有點浪費時間(#
噢，最覺得浪費時間的可能是我跑去打音遊另外兩個人站在後面看的尷尬時間。
周日 隔天早上沒有課，他們兩個又說晚半小時到，於是我想說可以安心吃早餐慢慢出門， 結果我還是晚他們到XD
因為我前一天不小心玩壞OJDL，所以這個早上花了不少時間來修。
一切的主因都是因為沒事update東西QQ，造成的影響到現在還沒修完
這天修好的 bug 好像是因為沙盒有限制記憶體之類的，但是 update 之後的執行檔編譯出來不知道為什麼就爆炸了(?)
好像在 g++ 的選項加個 -static 就修好了，完全不知道為什麼之前不會出事更新就會出事。
下午的講師是張經略教授（對就是加菲貓教授）
他仍然超酷，講的主題是 subexponential algorithms。首先講了subset sum和0/1背包的meet in the middle作法，中途還一直說「這個部分我不會……所以時間複雜度就是 $2^{N/2}$ + 我不會 + $2^{N/2} \cdot (N/2)$ ……」，超好笑，O(我不會)的演算法。接著講了一個 $O^{ \star }(3^{N/2})$ 的3-SAT確定性演算法，並且還有講了 $O^{ \star }(3^{N/4})$的隨機演算法和一個O(我不會)的隨機演算法XD。
接下來就變成討論「1-median selection in metric space」的一大堆東西， 這個問題主要是在問給一堆點，你要找到與其他點平均距離最小的一個點，很神奇的是可以隨機選一個夠多點的subset，然後對每個點只算與這個subset的平均距離之類的，會得到一個近似解。</description></item><item><title>Using-Vim</title><link>https://omeletwithoutegg.github.io/2020/07/08/Using-Vim/</link><pubDate>Wed, 08 Jul 2020 01:15:12 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2020/07/08/Using-Vim/</guid><description>vim ?! vim : 古老的編輯器
來由 之前 ZCK 很早就開始一直推坑 vim ，而我大概是在開始瘋狂玩 OJDL 之後才開始使用 vim 的
因為在遠端 server 上改 code 最直接的方式就是使用遠端主機上的 vim 直接在 ssh 的介面改
所以經過幾個月(我也不知道具體多久)我大概熟悉 vim 了之後，在我的筆電上也裝了 gvim
因為是 windows 的所以用起來很怪，不過經過 Google 一些設定之後變得正常一些了
至於我的筆電呢，我覺得裝 linux 的必要性還沒有麻煩性高(X
而且感覺arch &amp;gt; Ubuntu但是裝了arch又會因為更新速度出現各種神奇的事件
所以姑且先不裝(?)
一些心得 我覺得 vim 的優點可能就是讓你可以只使用鍵盤編輯文件，
再來就是你可以依照自己的喜好更改 vimrc 或是安裝插件
此外記憶這些快捷鍵也是很有成就感的事情(?)
變魔法的快速鍵就跟突然講起德語或上古漢語一樣吸引人目光
my vimrc 附上我自己的 vimrc
一開始我沒有裝任何插件，後來查到一篇使用 Vundle 的就去載了
最後跟風(?)改成用 vim-plug 管理所有插件
物色自己喜歡的插件真的很難，可能害我熬夜了好幾次QQ
不知道過了一段時間之後我的 vimrc 又會變成什麼樣子
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 set nocompatibleset encoding=utf8set fileencoding=utf8&amp;#34;&amp;#34;&amp;#34; Plugins, use &amp;#39;vim-plug&amp;#39; to manage pluginscall plug#begin(&amp;#39;~/.</description></item><item><title>TIOJ-1764</title><link>https://omeletwithoutegg.github.io/2020/05/12/TIOJ-1764/</link><pubDate>Tue, 12 May 2020 15:31:47 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2020/05/12/TIOJ-1764/</guid><description>Ch2. Section 9. 補魔力的條件 https://tioj.ck.tp.edu.tw/problems/1764
Description 現在有排成一直線的$N$個格子，從左到右編號為$1 \dots N$，每個格子都有自己的高度 一開始你站在第一格，每次移動都只能往編號大的格子跳，目標是走到第$N$格 假設第$i$個格子的高度是$x_i$，從格子$i$跳到格子$j$需要耗費$\max(0, (j-i)+(x_j-x_i))$的力氣
請問在花最少力氣到達終點的前提下，他最多可以跳幾次? Solution 先考慮最小化力氣
令$x_i+i = v_i$，簡單的列出DP式
$$
dp[i] = \min _ {j &amp;lt; i}(dp[j] + \max(0,v_j-v_i))
$$
這樣的複雜度是$\mathcal{O}(N^2)$
不過可以分case討論
$$
dp[i] = \min(
\min _ {j &amp;lt; i \wedge v_j \geq v_i}(dp[j]+v_j)-v_i,
\min _ {j &amp;lt; i \wedge v_j &amp;lt; v_i}(dp[j])
)
$$
就可以用資料結構$\mathcal{O}(N \log N)$維護了
那麼最多可以跳的次數也可以一邊維護
也就是說如果力氣不同就選力氣小的，力氣相同則選跳的次數多的，可以直接用pair做就好
這邊寫的是值域壓縮之後用BIT維護前後綴min OAO
AC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #pragma GCC optimize(&amp;#34;Ofast&amp;#34;) #pragma loop_opt(on) #include &amp;lt;bits/stdc++.</description></item><item><title>TIOJ-1633</title><link>https://omeletwithoutegg.github.io/2020/05/08/TIOJ-1633/</link><pubDate>Fri, 08 May 2020 13:43:30 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2020/05/08/TIOJ-1633/</guid><description>序列維護問題 https://tioj.ck.tp.edu.tw/problems/1633
Description 有一個由1到N的數字排成的序列。
可是你對於現在這個排列很不滿意，決定透過一些操作改變這個序列。
你現在有兩種操作：
REV L R ：把L到R所有數字反轉順序，例如1 2 3 4變成4 3 2 1 SWAP L1 R1 L2 R2：把L1到R1所有數字跟L2到R2所有數字交換位置，但順序不變。 你總共進行了M次操作，請輸出最後序列的樣子。
Solution 平衡二元樹裸題，我用的是Treap
要反轉的話可以打懶標(?)然後記得push
AC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 #pragma GCC optimize(&amp;#34;Ofast&amp;#34;) #pragma loop_opt(on) #include &amp;lt;cstdio&amp;gt;#include &amp;lt;random&amp;gt; const int N = 130025; inline char readchar() { constexpr int B = 1&amp;lt;&amp;lt;20; static char buf[B], *p, *q; if(p == q &amp;amp;&amp;amp; (q=(p=buf)+fread(buf,1,B,stdin)) == buf) return EOF; return *p++; } inline int nextint() { int x = 0, c = readchar(); while(c &amp;lt; &amp;#39;0&amp;#39;) c = readchar(); while(c &amp;gt;= &amp;#39;0&amp;#39;) x=x*10+(c^&amp;#39;0&amp;#39;), c=readchar(); return x; } inline void readuntil(char *s, char esc = &amp;#39;\n&amp;#39;) { char c = readchar(); while(c !</description></item><item><title>TOI-2!</title><link>https://omeletwithoutegg.github.io/2020/05/07/TOI-2/</link><pubDate>Thu, 07 May 2020 20:26:47 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2020/05/07/TOI-2/</guid><description>二階奇幻之旅 原本一段剛好和一階撞到，可以免考，但是因為疫情的緣故又錯過了
不過在我們從一階回來之後傳出師大那邊有確診的消息，而且還跟我們用過同一間教室(?)
所以我們就剛好利用防疫公假得到免考的資格，嘻嘻
防疫公假? 在自主健康管理的這段期間，我除了家裡基本上都待在王政祺家地下室
寒假的時候去那邊都是在打桌遊，不過這個禮拜去不是在刷題就是在刷題XD
有戳了一些POI還是BOI，不過POI真的好怪，什麼官解一兩百行特判的數學題之類的
AY來的時候他會丟CF的題目，然後帶我們吃超多拉麵
不過我真的對蒜不行&amp;gt;&amp;lt;
二階 總之防疫公假結束之後就無縫接軌二階
因為師大有確診所以我們原本應該是要待在家裡邊防疫邊線上上課
我們的住宿和披薩全都因為疫情泡湯QAQ，變成線上授課
啊我們上課就不是重點喔@@我覺得能夠不管任何外部事務，只專心互相討論題目、或者耍廢才是我心目中(?)的選訓營QQ
非新北、台北的學生可以有一晚的住宿，我好想要飯店早餐(
既然我們都覺得教授上的課不是重點，能夠和其他電神互相討論才是選訓營最大的好處&amp;gt;&amp;lt;
於是我們建中一群人就借用了電教和創客教室來討論(?)
有些南部人待在台北的也跟著來ㄌ，這一團變得超熱鬧
捯捯捯捯捯捯捯 AY跑去新竹跟東東和balbit刷題的樣子，第二個禮拜double學長也跑下去
模考的時候他們再跑上來
總之我們好像每次模考就會吃一兩次拉麵XD好爽
課程 在二階上的有些課很奇怪，比如說什麼KMP和SA，或者建凸包求面積之類的
雖然從北市賽到入營考考的字串題好像只有AC自動機那題，可是在二階教這些超奇怪的吧XD
有一堂課是教授會丟題目給我們寫，給一個很大的測資然後要我們找出答案之類的
去年似乎是舉手讓教授看，不過今年是用google meet，答案直接打在聊天室，沒有避嫌超奇怪啦
雖然是教分治的教授，不過有丟了一些有趣的DP題目
這次也聽到了Level Ancestor的做法，Ladder Algorithm好神奇喔
不過RMQ的O(N)O(1)也聽了好幾遍，已經聽膩了
國手們來講課的時候AY好像弄了一個DC的bot，於是我們後面就開始duel
休閒娛樂 什麼是duel呢?
就是讓bot選一題然後兩個人比誰先想出來然後AC XD
我好像沒有duel的太積極ww不過AY和balbit似乎超常對決
不知道從誰開始玩BTD battles的，我們幾乎每天都玩(到二階結束還在玩)
03t教的策略超強，可是我還是常常玩到破產，只能打五元的，超可憐又一直遇到金錢幾百萬的對手，怎麼贏?
另外因為沒有被關在師大，吃飯就成了一個問題
我們除了在建中的熱食部吃以外，也去吃了好幾家拉麵，有點罪惡感XD
啊也因為沒有被關在師大，我就可以順理成章的在晚上去打音遊，真爽(現在sdvx中毒中:P)
模考 模考在師大本部舉行，地點是一個會議室(汗)
而且跟全國賽一樣是用筆電，不過這次升級成電競筆電了(不如把預算拿去幫我們弄住宿或上課空間QQ)
三模難度超高QQ，本來以為自己被電爆不過似乎拿到最高分，因為拿到一題FWT的56分@@可惜我沒拿滿
剩下pCpD幾乎沒人拿到分數，超可怕
我pA沒有把手做的分數拿滿有點可惜(?)
四模的話，pA看起來是可以做的題目(幸好進位制不是負的)，花了一些時間丟上去部分分確定是對的之後優化個兩三次就AC了
剩下的題目都做不出來QQ原本以為pB是可以做的DP但是出來好像大家都不會
pC沒有拿滿很可惜，pD也是和大家一樣沒想法不過可惜我沒去拿一條鏈的case
接下來? 因為我在學校嘗試待了一個禮拜之後發現真的待不太下去(這就是奧林匹亞回歸症候群嗎&amp;hellip;)
於是成功的用準備資奧的理由請了假，罪惡感爆棚呢XD
現在該做的事可能就是編講義、寫題解吧，希望自己不要頹廢OvO</description></item><item><title>TIOJ-1039</title><link>https://omeletwithoutegg.github.io/2020/05/06/TIOJ-1039/</link><pubDate>Wed, 06 May 2020 16:36:03 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2020/05/06/TIOJ-1039/</guid><description>B.魔術數字 https://tioj.ck.tp.edu.tw/problems/1039
Description 超級長orz
總之名次的比較是看勝率，勝率的定義是「勝場數/(勝場數+敗場數)」
而兩隊魔術數字$M$的定義如下：
假設A隊的勝率領先B隊，只要A隊再贏除了B隊以外的隊伍$M$場，就算$B$隊剩下的所有場次都贏也不能得到和A相等的勝率
假設$M$大於A隊對上除了B隊以外的隊伍剩下的場次，那我們說A隊對B隊的魔術數字尚未點亮
否則我們說A隊對B隊的魔術數字是$M$
如果$M$歸零的話，表示A隊不管怎麼樣名次都會超過B隊
對於每一筆測試資料，請輸出一排版過的戰績表。依n支球隊的戰績排名順序輸出n行。除了第1名球隊以外，若發生勝率相同的情形，請依球隊在原資料的出現順序為輸出順序，但其排名則應並列。格式請參考範例輸出。隊名，勝率，魔術數字分別以一個空格來間隔，而隊名部分不足9個字元的部分則需填入空格。勝率固定輸出到小數點後三位(四捨五入)。第一名球隊不需要輸出魔術數字，請你分別計算出第一名球隊對其他球隊的魔術數字。若對其他球隊的魔術數字尚未點亮，請輸出--。若魔術數字已點亮，則輸出M以及該數字。測試資料之間請留一個空行。
Solution 呃&amp;hellip;就是一大堆噁心輸出
注意勝率的定義不包括和局QQ
計算魔術數字的方法就是用while迴圈一直加，跑到在題敘指定的情況下A隊的勝率會大於B隊的勝率
噢名次的地方也是要注意QQ很容易沒注意就寫錯
還有他的空行是在測試資料之間(?)雖然我不知道有沒有差啦
AC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include &amp;lt;cstdio&amp;gt;#include &amp;lt;cmath&amp;gt;#include &amp;lt;algorithm&amp;gt;struct Team { char name[10]; int W, T, L, id; double rate; friend bool operator&amp;lt;(const Team &amp;amp;a, const Team &amp;amp;b) { return a.</description></item><item><title>TIOJ-1404</title><link>https://omeletwithoutegg.github.io/2020/05/04/TIOJ-1404/</link><pubDate>Mon, 04 May 2020 21:05:10 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2020/05/04/TIOJ-1404/</guid><description>照亮的山景 https://tioj.ck.tp.edu.tw/problems/1404
Description 在一片山的上空，高度為$T$處有$N$個處於不同水平位置的燈泡，如上圖所示。
如果山的邊界上某一點與第$i$盞燈的連線不經過任何山稜線上的一點，我們稱第$i$盞燈可以照亮該點。
請問在所有$M$盞燈中，至少要打開幾盞燈，才能照亮山上每一個轉折點，或者打開所有的燈也無法照亮所有轉折點？
$1 \leq M, N \leq 10^5$
所有座標的絕對值小於$10^5$
Solution 發現到每個燈泡可以照到的範圍可能會長的非常奇怪
於是我們轉換思維，考慮每個轉折點如果要被照到要有什麼條件
可以發現，對於每個轉折點來說有一個區間，只要區間內有一個燈泡有開，這個轉折點就會被照到
找出那些區間之後這題就是經典的greedy題目了（按照右界由小到大，有拿過的跳過沒拿過的拿右界那個點）
那麼要怎麼找出這些區間呢？某個轉折點$p_i$對應的右界，正好是他和他右邊所有其他點所連出的射線中斜率最大者
維護一個上凸包能夠找到對應的那個點，再用直線求交點公式找出高度恰好是$T$的位置就好
左界也是同樣方式處理
因為題目給定的點已經幫我們排序好了，所以做凸包是$\mathcal{O}(M)$，而greedy的部分也可以做到$\mathcal{O}(N)$不過我這邊是放了$\mathcal{O}(N\log N)$的，因為找到交點之後必須二分搜求出到底涵蓋了哪些燈泡
總複雜度是$\mathcal{O}((M+N)\log N)$
AC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 #include &amp;lt;bits/stdc++.</description></item><item><title>TIOJ-1628</title><link>https://omeletwithoutegg.github.io/2020/05/03/TIOJ-1628/</link><pubDate>Sun, 03 May 2020 15:02:18 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2020/05/03/TIOJ-1628/</guid><description>組合布丁 https://tioj.ck.tp.edu.tw/problems/1628
Description 記得在快樂暑假營開始前，你曾經說過：「只要我有一次比賽沒有破台，就要請全快樂營的人吃布丁。」
好吧，蚯蚓太威了，你終究是沒有破台。
根據小道消息，你得知了這次的快樂暑假營總共有 $n$ 個人報名，
但是實際上會出席的只有 $k$ 個人，因此你只要請 $k$ 個人吃布丁就好。
而報名的第 $i$ 個人只會願意吃 $t_i$ 口味的布丁(用一個 int 範圍內的整數表示)。
假設你不確定究竟誰會出席，那有幾種不同的布丁組合可能會出現在你的採買清單上 ?
喔對了，因為答案可能太大了，所以你決定只要知道答案除以 $M$ 的餘數就好。
輸入包含多筆測資
$$
1 \leq n, k \leq 5000, 1 \leq M &amp;lt; 2^{31}
$$
Solution 兩種布丁組合不同，若且唯若某一種布丁的數量不同
因此我們枚舉每個布丁的數量去做計數背包就好了
可以用前綴和甚至FFT加速(?)不過FFT應該不會比較快www
AC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include &amp;lt;bits/stdc++.</description></item><item><title>TIOJ-1861</title><link>https://omeletwithoutegg.github.io/2020/05/01/TIOJ-1861/</link><pubDate>Fri, 01 May 2020 21:10:56 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2020/05/01/TIOJ-1861/</guid><description>蘿莉切割問題 https://tioj.ck.tp.edu.tw/problems/1861
Description 請你把一個數字$L$切成$a_1, a_2, \dots, a_n$
切一個數字$x$的代價是$x$，可以把它切成$b, x-b$兩個數字
找出最小的代價
Solution 霍夫曼編碼XD老題目
把切割的過程看成一個二元樹，每個$a_i$都代表一個葉子
其餘的節點代表合併中會出現的數字(?)
那麼總代價就是所有葉子的權重乘上各自的深度的和
我們想要讓這個代價越小越好
可以發現，在最優解$T$中：
沒有節點只有一個兒子，只要不是葉子的節點都恰好有兩個子節點 深度最大的那層節點一定是權重最小的，否則可以直接交換得到更優解 由上面兩點可以發現，權重最小的兩個節點一定都在最深的那一層
並且可以在不影響代價的情況下交換節點使得最小的兩個節點互為兄弟
結論是：每次把最小和次小的節點合併成一個節點，一定可以得到最佳解
(QQ我覺得我不會查也不會寫證明)
要怎麼維護所有節點的最小和次小呢？用一個heap就可以啦
AC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std; const int N = 100025; #define int ll int v[N]; signed main() { ios_base::sync_with_stdio(0), cin.tie(0); int n,ans; while(cin &amp;gt;&amp;gt; n) { ans = 0; for(int i = 0; i &amp;lt; n; i++) cin &amp;gt;&amp;gt; v[i]; std::priority_queue&amp;lt;int,vector&amp;lt;int&amp;gt;,greater&amp;lt;int&amp;gt;&amp;gt; pq(v,v+n); while(pq.</description></item><item><title>TOI-1!</title><link>https://omeletwithoutegg.github.io/2020/04/30/TOI-1/</link><pubDate>Thu, 30 Apr 2020 18:23:34 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2020/04/30/TOI-1/</guid><description>選訓生活(?) 最近部落格停更好久喔&amp;gt;&amp;lt;
不知道有沒有沒有追蹤我facebook的人在看我的部落格，嘻嘻
入營考當天? 我和蕭梓宏還有王品翔一起去師大看好戲(X)
然後電石似乎在旁邊寫作業和嘴砲(?)
不過記分板上沒有每個人的名字，只有學校和編號
幸好遇到一個奇怪的家長有拍名單之類的XD 讓我們能夠對照
最後結果是AY破台拿第一，除了03t以外的建中高二應該都進了一階
我們之後分團去ㄘ了拉麵！
一階 懷著新奇的心情來到這個地方，報到時我好像是蠻晚進去的幾個(因為林哲宇帶路)
一開始我本來想說可以打osu，因為去年似乎好多人那樣刷時間?
不過晚上看到好多人在刷題，我超怕www
於是就開始寫不知道甚麼題目
課程 有幾堂是教授講課，首先是入營考的題解，不過好像被發現有一題假解XDD
之後有一個是張經略教授，他會在白板上畫加菲貓而且上課超級high(他自嗨功力很高)
有一堂課是國手經驗分享，bert和minson說了好多奇怪的趣聞(?)
第一個禮拜幾乎所有人都出現了(?) BB、電石、吳聖福、王彥仁好幾位都有來講題目or分享奇怪心得
從一模隔天開始，剩下的教授幾乎都是線上上課，所以我後來幾乎沒有在上課QQ
O(N)O(1)RMQ 教了幾百遍聽到不想再聽(X)
教室似乎因為防疫的關係換了三次左右，有點煩躁
第一個禮拜我刷的比較多應該還是TIOJ，畢竟我還是覺得我刷不動POI(?)
不過第二個禮拜開始刷一些BOI，想說練一下喇分能力
可是不知道是題目問題還是我的個性幾乎不是直接想到滿分解就是只有不到三十的部分分QQ
POI和JOI仍然還在我的實力的很上方
話說一模附近幾天剛好是JOISC，不過難到炸，我完全寫不出啥
飲食住宿 我們的飯店是台大捷絲旅，對面就是哈拉星球XDD，可惜沒有辦法去打QQ
然後我的室友是暘典，好像有點自然的就稍微變熟不過還是很不熟(?)
早餐是飯店的早餐，這十四天每天早上吃這個真的超級爽耶，我超愛炒蛋和炸的東西
午餐和晚餐在師大的學餐吃，我覺得中餐真的就是該吃早餐部XD
joy一直推薦西西里雞腿堡加蛋加起司，不過我覺得沒有傳言那麼好吃
晚餐就只剩西餐廳跟自助餐兩個選，我覺得西餐廳的拉麵超級糟糕，丼飯也只是勉強能吃ww
自助餐則是超級尷尬的選擇，不好吃也不難吃，不過很容易就超過預算90元要自掏腰包www
在吃飯的時候基本上都會打牌，因為這似乎是無聊的選訓生活中少數的消遣(?) (雖然我現在覺得選訓一點都不無聊QQ)
最常打的是拿破崙，ericxiao真的大師，啊seanliu到第二個禮拜才發現他知道的比牌大小規則是錯的XD超好笑
此外因為那時候mini metro限免，大家一窩蜂去下載來玩
吃完飯之後我幾乎都會買微舒打，好爽喔
在飯店，有時候晚上會和祺他人在其他房玩狼人殺或打拿破崙之類的(?)
有時也會有淇怪的人來我們房間玩(?)
每天晚上點名的時候有零食和飲料，算是填填牙縫(
晚上沒什麼消遣，除了打牌玩狼人殺，或者打code以外，也可以跟人聊天 &amp;lt;3
模考 如同國手們分享經驗時所說的，我覺得我正好就是那些在北市賽、全國賽也許表現得好，但是是第一次模考的菜雞
他們提到說賽中要多喝水、多上廁所，也要記得補充血糖，轉換轉換心情並讓大腦保持清醒
其實這些我在500days那本書就看過了好幾次，不過我還是當作重要的一些策略記著
一模的時候我雖然打得很差，可是我沒有想到什麼特別的原因讓我打爛，單純只是我都沒有想法而已
因為還沒踏進棺材所以晚上也不是特別難過，不過看到打得比我好的說什麼我很強就覺得超級不爽= =想打人(例如joy)
看到別人分數比自己高還是會超級羨慕的吧
二模因為pC出一大堆問題所以大家好像都打得很爛，不過我pC是最後才碰的所以幸運沒有踩雷
而且還是因為pD測資爛撈到一個AC= =現在回去看每一場都有憐憫我的分數
模考的難度聽說比以往難，然後我實際寫也是感覺真的很難(雖然我沒去過以前的)，可能跟一些div 1的場次一樣吧?
不過撈部分分的能力應該才是真正決勝的地方，有請品翔喇分大師分享入營考0AC的經驗
列舉事項 因為一階遇到很多酷哥，所以我要從facebook抄過來那段列舉
幾件神奇的事情：
thomaswang和ericxiao分別站在爛梗光譜的兩端 西餐廳的拉麵超糟 午餐吃早餐部唯一真理吧 天天喝微舒打好爽 吃飯店的早餐有夠爽 晚餐或晚上超常打拿破崙 seanliu打了兩個禮拜竟然有規則不知道 然後蕭電超強 YoJaHuang&amp;amp;品翔歌神了吧 實中的人都超酷 除了tommydong比較正常一點 仲群病毒大家都一直學www 「我燒雞」 「呃 我弱」 casperwang洗澡專家 不過還是教不會品翔 好多東西都是第一次接觸到 例如十二人狼人殺或是學生餐廳的點餐方法www 待續&amp;hellip; 因為打這篇的時候我在學校努力上課(?</description></item><item><title>TIOJ-1629</title><link>https://omeletwithoutegg.github.io/2020/02/29/TIOJ-1629/</link><pubDate>Sat, 29 Feb 2020 00:09:33 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2020/02/29/TIOJ-1629/</guid><description>快樂規劃路徑 https://tioj.ck.tp.edu.tw/problems/1629
Description 樹朋友們生活在一個湖邊，湖邊的樹依照順時針方向編號為$1, 2, \dots n$。
他們想要讓自己更快樂，所以發明了一種娛樂方式，就是找到一條路徑遍歷全部$n$棵樹剛好一遍。
要從A樹到B樹唯一的方法就是架一條很長的梯子直直伸過去。
可是當然不是任何兩棵樹都可以架梯子，所以他們會先把所有可能架梯子的樹對(沒有錯字!)給你。
當然，(A,B)表示A可以到B、B也可以到A。
但是給定的遊歷路徑不能出現任兩條梯子交叉，不然可能會讓想要快樂的樹朋友發生危險。
例如上圖粗線所示就是一個合法的快樂路徑。
給你樹的個數以及樹對，請輸出一組快樂路徑。
若有很多組解，樹朋友希望看到字典順序最小的那一組。
$5 \leq n \leq 1000$
Solution 由不能交叉的條件可以推出，在某個時刻已經遍歷過的點一定是環上的一個連續區間
所以可以2D/0D的區間DP，並記錄最小的轉移來源
我的dp$[i][L][0]$代表的是現在站在$i$，往順時鐘方向的$L$個都已經遍歷過了，$dp[i][L][1]$也相似只是換成逆時鐘
因為實在想不到更好的實作方式所以寫的有夠醜，但是只要好好選到最小的轉移來源就會是字典序最小的路徑了
AC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 #include &amp;lt;bits/stdc++.</description></item><item><title>TIOJ-1505</title><link>https://omeletwithoutegg.github.io/2020/02/27/TIOJ-1505/</link><pubDate>Thu, 27 Feb 2020 12:28:06 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2020/02/27/TIOJ-1505/</guid><description>Assssss!! https://tioj.ck.tp.edu.tw/problems/1505
Description 現在有一個正整數構成的除法數列
$
x_1 / x_2 / x_3 / \dots / x_n
$
請問是否有一種加上括號的方法使得最後運算的結果是整數?
$2 \leq n \leq 10^5, 1 \leq x_i \leq 10^9$
Solution 加上括號之後每個數字會被放到分母或分子，想當然而放在分子的數字越多越好
可以發現$x_2$會恰好被放到分母一次，因此在最後他一定是當分母的
而我們可以構造出一個方法讓除了$x_2$最後當分母以外，其他數字都當分子
$$
(x_1 / (((x_2 / x_3) / x_4) / x_5 \dots)) = \frac{x_1 x_3 x_4 x_5 \dots x_n}{x_2}
$$
由於$x_2$最後一定會待在分母，只要檢查其他數字的乘積是否可以被$x_2$整除就好了
記得 long long 的問題
AC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include &amp;lt;cstdio&amp;gt; inline char readchar() { constexpr int B = 1&amp;lt;&amp;lt;20; static char buf[B], *p, *q; if(p == q &amp;amp;&amp;amp; (q=(p=buf)+fread(buf,1,B,stdin)) == buf) return EOF; return *p++; } inline int nextint() { int x = 0, c = readchar(); while(c &amp;lt; &amp;#39;0&amp;#39;) c = readchar(); while(c &amp;gt;= &amp;#39;0&amp;#39;) x=x*10+(c^&amp;#39;0&amp;#39;), c=readchar(); return x; } signed main() { int t = nextint(); while(t--) { int n = nextint(); int res = nextint(), mod = nextint(); for(int i = 2; i &amp;lt; n; i++) res = 1LL * res * nextint() % mod; puts(res ?</description></item><item><title>TIOJ-1219</title><link>https://omeletwithoutegg.github.io/2020/02/25/TIOJ-1219/</link><pubDate>Tue, 25 Feb 2020 09:55:02 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2020/02/25/TIOJ-1219/</guid><description>發糖果囉 https://tioj.ck.tp.edu.tw/problems/1219
Description 求符合$1 \leq x \leq n, 1 \leq y \leq m$且$x,y$的最大公因數是$g$的數對有多少對
有多筆測試資料，$1 \leq n, m, g \leq 50000$
Solution 莫比烏斯反演
lemma $$
\sum_d \mu(d) [d | x] = [x = 1]
$$
拿來簡化 $[\gcd(i,j)=1]$ 的部分，再想辦法換一下$\sum$的位置
$$
\begin{align*}
\sum _ {i=1}^n \sum _ {j=1}^m [\gcd(i, j) = g] &amp;amp;= \sum _ {i=1}^{\lfloor n/g \rfloor} \sum _ {j=1}^{\lfloor m/g \rfloor} [\gcd(i, j) = 1]\newline
\sum _ {i=1}^N \sum _ {j=1}^M [\gcd(i, j) = 1] &amp;amp;= \sum _ {i=1}^N \sum _ {j=1}^M \sum_d \mu(d) \cdot [d | \gcd(i, j)]\newline</description></item><item><title>TIOJ-2140</title><link>https://omeletwithoutegg.github.io/2020/02/25/TIOJ-2140/</link><pubDate>Tue, 25 Feb 2020 09:09:25 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2020/02/25/TIOJ-2140/</guid><description>殿壬愛序列 https://tioj.ck.tp.edu.tw/problems/1102
Description 給你一個長度為$N$的序列$a_1, a_2, \dots, a_N$，並且依序執行$Q$個操作，每個操作可能是
1 x y ：把$a_x$設成$y$
2 L R k ：對於每個$i \in [L, R]$，把$a_i$設成$\lfloor \frac{a_i}{k} \rfloor$。其中$\lfloor x \rfloor$代表不大於$x$的最大整數
3 L R ：請輸出$a_L, a _ {L+1}, \dots, a_R$的絕對眾數，如果絕對眾數不存在請輸出-1。一個數字若為$T$個數字的絕對眾數，代表這個數字至少在$T$個數字中出現$\lfloor \frac{T+2}{2} \rfloor$次。
$1 \leq N, Q \leq 10^5$
$1 \leq L \leq R \leq N$
$1 \leq x \leq N$
$0 \leq a_i, y \leq 10^9$</description></item><item><title>TIOJ-1102</title><link>https://omeletwithoutegg.github.io/2020/02/25/TIOJ-1102/</link><pubDate>Tue, 25 Feb 2020 08:33:26 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2020/02/25/TIOJ-1102/</guid><description>E.海賊王 https://tioj.ck.tp.edu.tw/problems/1102
Description 你是一位海賊，現在有$P$個敵人與$T$個寶藏等間距圍成一圓形
你必須決定一個發射砲彈的方式
砲彈會波及的範圍是圓形的，每次發射後範圍內的海賊會被殺死，寶藏也會被毀壞
剩下的會重整隊形，同樣等間距圍成一圓形，且半徑不變（炮彈可以波及的半徑大於他們圍成的圈的半徑）
檢查過船上的砲彈存量以後，你發現一次至少要炸死兩個敵方海賊（所以剩三個海賊的話一定要一次打死三個）
你決定寫個程式幫你計算最多可以拿到多少未被毀壞的寶藏
Solution 半徑根本就是垃圾資訊XDD
只要炸的到的範圍比圍成的圈的範圍還要大，每次炸的就是環上的一段區間
總之考慮海賊之間的間隙，本題等價於選取環上許多個不相鄰的間隙使得權重最大
那麼顯然就直接DP，只要記得考慮環形的問題就好
AC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 // __________________ // | ________________ | // || ____ || // || /\ | || // || /__\ | || // || / \ |____ || // ||________________|| // |__________________| // \###################\ // \###################\ // \ ____ \ // \_______\___\_______\ // An AC a day keeps the doctor away.</description></item><item><title>TIOJ-1798</title><link>https://omeletwithoutegg.github.io/2020/02/23/TIOJ-1798/</link><pubDate>Sun, 23 Feb 2020 11:34:03 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2020/02/23/TIOJ-1798/</guid><description>Can You Arrive? https://tioj.ck.tp.edu.tw/problems/1798
Description 地鐵有$N$個站，$M$條軌道，$K$段行駛路線
站與站之間使用軌道連接
保證軌道不會形成環，且$M = N-1$
每段行駛路線代表有一輛車在兩站之間的最短路徑來回發車
也就是說這段路上的任意兩站都是互通的，可以直接抵達不需轉車
現在$Q$位妹子來向你問路，問你能不能從某一站經過任意多次的轉車搭到另一站。
保證兩站不是同一站。
$K \leq N \leq 10^6, M = N-1, Q \leq 10^6$
Solution 每條行駛路線代表的就是在這條路徑上加值
而查詢到不到得了就是查詢路徑上有沒有$0$
可以採用輕重鏈剖分維護樹上路徑和
因為修改都在詢問之前，所以利用前綴和就好，不需要開線段樹
複雜度$\mathcal{O}(N + Q \log N)$
AC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 // __________________ // | ________________ | // || ____ || // || /\ | || // || /__\ | || // || / \ |____ || // ||________________|| // |__________________| // \###################\ // \###################\ // \ ____ \ // \_______\___\_______\ // An AC a day keeps the doctor away.</description></item><item><title>TIOJ-1129</title><link>https://omeletwithoutegg.github.io/2020/02/23/TIOJ-1129/</link><pubDate>Sun, 23 Feb 2020 11:26:04 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2020/02/23/TIOJ-1129/</guid><description>聚集問題 https://tioj.ck.tp.edu.tw/problems/1129
Description 給定二維平面上$N$個點，若編號$i,j$的點之間的距離不大於$C$則他們之間有連邊
問最後的連通塊數量以及每個連通塊的大小
Solution 我想不到比$\mathcal{O}(N^2)$枚舉直接連邊更好的解了XD
比起DFS我更喜歡用DSU因此code是DSU
AC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt; const int N = 4001; int s, n, r; std::pair&amp;lt;int,int&amp;gt; p[N]; int pa[N], sz[N]; std::vector&amp;lt;int&amp;gt; ans; int dis(std::pair&amp;lt;int,int&amp;gt; a, std::pair&amp;lt;int,int&amp;gt; b) {return (a.</description></item><item><title>TIOJ-2124</title><link>https://omeletwithoutegg.github.io/2020/02/22/TIOJ-2124/</link><pubDate>Sat, 22 Feb 2020 20:04:25 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2020/02/22/TIOJ-2124/</guid><description>殿壬看蝴蝶 https://tioj.ck.tp.edu.tw/problems/2124
Description 太長了，略
Solution 看到第五種操作就會想用平衡樹去寫這題
然後仔細看看就會發現第八種操作其實和其他操作都沒什麼關係，只有第三、四種操作會改變以蝴蝶編號為順序的區間和
所以呢對蝴蝶的編號開一個線段樹、對樹的編號開個Splay就能AC了
Splay只需要實現查一個節點在中序是第個、查中序第k個節點是什麼，還有剪切區間
至於區間和就隨便維護吧XD，code如下，我不知道該對裸題做甚麼解釋
寫剪切區間的splay的時候要注意的可能就是不要改到空節點(我是用0代表空節點)的任何值
也小心不要讓合併的時候合併到同一棵splay，出現環
中途有一次一個回傳int的函數忘記回傳東西，在TIOJ上吃SF
AC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 #include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstdlib&amp;gt; const int N = 200025; int n, q, v[N]; struct SplayTree { struct node { int val, sz; int sum; int ch[2], pa; //bool rev; } S[N]; bool dir(int i) {return i==S[S[i].</description></item><item><title>TIOJ-1884</title><link>https://omeletwithoutegg.github.io/2020/02/20/TIOJ-1884/</link><pubDate>Thu, 20 Feb 2020 23:53:21 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2020/02/20/TIOJ-1884/</guid><description>【IOI2015】Boxes 一堆盒子 https://tioj.ck.tp.edu.tw/problems/1884
Description 有$L$個地區排成一環狀，依序編號為$0, 1, \dots, L-1$
從任何一個地區移動到相鄰的地區所需要的時間均為一單位時間
現在有$N$個人需要寄送貨物，他們分別住在編號為$p_1, p_2, \dots, p_n$的地區(已經依非遞減順序排序)
貨物中心位在編號$0$的地區，並且郵差每次只能帶至多$K$件貨物移動
(世界上只有一個郵差&amp;hellip;真辛苦)
身上所有的貨物都送到後，必須回到$0$號地區，才能進行下一輪的送貨
你的任務就是幫送貨的郵差計算他最少要花多少時間
才能從貨物中心出發，寄送完所有貨物，最後再回到貨物中心
(其中可能會回貨物中心很多次以補充貨物)
$
1 \leq K \leq N \leq 10^7,
1 \leq L \leq 10^9,
0 \leq p_i &amp;lt; L
$
Solution 首先有$K=1$的Subtask，可以確定自己對題意的理解
可以發現題目就是要把這$N$個點分成很多堆，每堆不超過$K$個，使得總成本最小
一個關鍵的觀察是分的方式肯定是排序過後切成很多連續區間
不需要考慮$i &amp;lt; x &amp;lt; j$但$x$卻不和$i,j$同一堆的情形，否則可以想辦法交換一下使得答案不會變更差
至此可以列出DP式
$$
dp[i] = \min\limits _ {\max(0, i-k) \leq j &amp;lt; i} { dp[j] + cost(j+1, i) }
$$
其中$cost(l, r) = \min {L, 2p_r, 2(L-p_l)}$</description></item><item><title>TIOJ-1828</title><link>https://omeletwithoutegg.github.io/2020/02/20/TIOJ-1828/</link><pubDate>Thu, 20 Feb 2020 04:56:05 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2020/02/20/TIOJ-1828/</guid><description>控控控之蘿莉控 https://tioj.ck.tp.edu.tw/problems/1828
Description 你走在路上遇到了一個可愛小蘿莉，因為你的控屬性，所以你跑上去問了她的名字：「小妹妹～你叫什麼名字啊？」
她回答：「啊！！！你幹嘛！我不認識你啊你誰啊！！！」
你：「我是你的好哥哥，來和我一起玩吧～」
這時機智的小妹妹拿起手機打了110
你決定要趕快逃跑，以免進入暗無天日的深淵
於是問題來了！
你要跑多快才不會被抓(你只能跑整數的速度)？
因為警察的體力有限，不能跑超過警局外的$10000$單位距離，所以逃出$10000$單位距離就好了
第一行有一個整數$T$代表測資筆數，
每行有三個無號整數$X,Y,Z$
$X$代表你現在跟警察局的距離，
$Y$代表小妹妹跟警察叔叔還要在$Y$秒才會講完電話，
$Z$代表講完電話後警察會馬上用秒速$Z$的速度沖上來追你
$0 \leq X,Y,Z \leq 10^6$
如果講完電話後，你還待在警察局門口，是會被抓的喔
注意你站在距警察局恰$10000$單位距離的點上也還是會被抓的喔
請輸出ㄧ個整數代表你至少要用多少的體力才不會被追悼
如果不管怎麼樣都會被追到請輸出 -1
Solution 是個大特判題呢
唯ㄧ會出現 -1 的case就是$X=Y=0$的時候，也就是ㄧ開始就被追上
首先可以知道人和警察兩個直線的差會與時間成線性
所以最小的差肯定是出現在端點
我們僅需要考慮剛出發那一刻和警察跨過$10000$那一刻，是否有被警察超前過即可
假設$T$是距離講完電話過了$T$秒，並且逃跑的速度是$V$
那麼可以列出式子
$$
X + (Y+T)V &amp;gt; TZ
$$
當$T$是$0$，可以知道$V$的最小值不是$0$就是$1$，取決於$X,Y$是否為0
當警察跨過$10000$時，$T=10000/Z$，移項一下可以得到$V &amp;gt; \frac{(10000-X)Z}{YZ+10000}$
不過注意$Z$必須不為$0$，若$Z$為$0$可以直接特判掉
AC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #pragma g++ optimize(&amp;#34;Ofast&amp;#34;) #pragma loop_opt(on) #include &amp;lt;cstdio&amp;gt; typedef long long ll; const int L = 10000; int solve() { int x, y, z; scanf(&amp;#34;%d%d%d&amp;#34;, &amp;amp;x, &amp;amp;y, &amp;amp;z); if(x == 0 &amp;amp;&amp;amp; y == 0) return -1; if(x &amp;gt; L) return 0; if(!</description></item><item><title>TIOJ-1553</title><link>https://omeletwithoutegg.github.io/2020/02/19/TIOJ-1553/</link><pubDate>Wed, 19 Feb 2020 16:54:42 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2020/02/19/TIOJ-1553/</guid><description>B-Game https://tioj.ck.tp.edu.tw/problems/1553
Description B-Game是個殘酷的兩人卡片對戰遊戲(Battle Game)
檯面上有$n$張卡片，排成環狀，每張卡片有其數值
兩人輪流取卡片，只能選與已經取過的卡片相鄰的卡片，但第一個人不受此限
選完卡片之後，勝負決定在將兩人手中卡片的數值和
若某位玩家得分大於另一位玩家，無論大多少均是勝利
輸出一行包含兩個數
分別是一開始有幾種拿法可以讓先拿的人勝利
與先拿的人最多可以拿到多少
Solution 一開始我沒有注意到環型的條件，送了好多次假解XD
後面還忘記%n，WA到癱軟www
現在假設先手第一步取了某張卡
則剩下的卡片就是環上的一段連續區間，並且不管怎麼拿都會一直保持是連續區間
可以透過奇偶性知道最後一步輪到誰拿，且拿的位置肯定是區間的最左邊或是最右邊
而對手ㄧ定會讓自己分數最低，我們則是讓分數盡量高
因此可以列出簡單的2D/0D轉移式，得到每個區間可以從兩頭拿時先手的最高得分
再加上先手第一步取得的分數就可以知道從每個地方起手先手所能得到的最高分
也就知道在那個位置是否有機會勝利了
AC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include &amp;lt;cstdio&amp;gt; inline int min(int a, int b) {return a&amp;lt;b?a:b;} inline int max(int a, int b) {return a&amp;gt;b?</description></item><item><title>TIOJ-1274</title><link>https://omeletwithoutegg.github.io/2020/02/16/TIOJ-1274/</link><pubDate>Sun, 16 Feb 2020 21:07:18 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2020/02/16/TIOJ-1274/</guid><description>[純屬無聊] Tie Breaker https://tioj.ck.tp.edu.tw/problems/1274
Description 本題考驗你對小向的試煉題敘的理解程度。請回答以下三個問題：
假設2-2的圖來自遊戲「甲」(一個包含五個字母的單字)，2-3的圖來自動畫「乙」(一個包含九個字母的單字 ，請問甲和乙中字母e出現幾次？ 假設3-1的圖來自動畫「丙」(包含四個中文字)，3-3的圖來自漫畫「丁」(包含六個中文字) ，請問丙和丁中聲調為二聲的字有幾個？ 假設4-1的圖來自動畫「戊」(包含八個中文字，其中第五個字是三聲)，4-2的圖來自動畫「己」(包含四個中文字)，4-3的圖來自動畫「庚」(包含六個中文字) ，且令為己的前兩個字翻譯成英文後的字母數，為戊的第二個字所代表的數字 ，「辛」是「庚」的第一個字。請問「辛」倍的x+y是幾？ Solution 註: 小向的試煉是TIOJ上一系列的題目，可以自行搜尋
甲 = Deemo 乙 = charlotte
第一點的答案 = 3
丙 = 遊戲人生 丁 = 我的英雄學院
第二點的答案 = 4
戊 = 中二病也想談戀愛 己 = 東京闇鴉 庚 = 雙星之陰陽師
第三點的答案 = 2 * (5 + 2) = 14
這題是考驗油度或是google程度，不過casper用猜的猜出答案，好糟糕
AC code 1 2 3 4 5 6 #include &amp;lt;cstdio&amp;gt;int main() { int ans[4] = {-1, 3, 4, 14}, n; scanf(&amp;#34;%d&amp;#34;, &amp;amp;n); printf(&amp;#34;%d\n&amp;#34;, ans[n]); }</description></item><item><title>TIOJ-1511</title><link>https://omeletwithoutegg.github.io/2020/02/15/TIOJ-1511/</link><pubDate>Sat, 15 Feb 2020 13:25:59 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2020/02/15/TIOJ-1511/</guid><description>Problem A. 雷射防護網 https://tioj.ck.tp.edu.tw/problems/1511
Description 考慮在正$n$邊形的頂點中任選三點形成的三角形，請統計分別有幾個銳角三角形、直角三角形和鈍角三角形
注意：兩個三角形被視為不同的，若且唯若三個頂點的編號不完全相同，並且不可以旋轉三角形
$n \leq 10^6$
Solution 簡單排列組合，不過我寫好久還踩到一些坑
直角的case很容易解決，因為斜邊必須要是外接圓的直徑，故$n$得是偶數
而所有$n/2$條直徑對應的直角三角形個數就是$2(n/2-1)$
接著我們先計算鈍角的case
固定鈍角那個頂點，假設三個角的角度分別等於$a, b, c$個邊(因為是正多邊形所以可以這樣統計)，且$a &amp;gt; b,c$
那麼所有鈍角三角形的個數就等於$a+b+c = n$且$a &amp;gt; n/2$的正整數解的個數
此時枚舉$a$，$b+c=n-a$有$n-a-1$組正整數解，可以知道所求即是
$$
\sum _ {a = \left \lfloor n/2 \right \rfloor + 1} ^ {n-2} n-a-1 = \sum _ {i=1}^{n-2 - \left \lfloor n/2 \right \rfloor} i = \frac{(n-2 - \left \lfloor n/2 \right \rfloor) (n-2 - \left \lfloor n/2 \right \rfloor + 1)}{2}
$$</description></item><item><title>TIOJ-1202</title><link>https://omeletwithoutegg.github.io/2020/02/09/TIOJ-1202/</link><pubDate>Sun, 09 Feb 2020 11:37:43 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2020/02/09/TIOJ-1202/</guid><description>重疊的天際線 https://tioj.ck.tp.edu.tw/problems/1202
Description 地平線上有許多房子，而這些房子在夕陽的照射之下形成有趣的輪廓，我們稱之為天際線(Skyline)。為了方便起見，你可以假設所有的房子都是一個位在2D平面上的矩形，並且有一條邊貼在這個假想2D平面上的X軸。
一棟建築可以用三元數組$(L_i, H_i, R_i)$來表示，依序代表該建築物的左界座標、高度、右界座標。
下圖中的八棟建築就是用此方法表示就是
$(1,11,5), (2,6,7), (3,13,9), (12,7,16), (14,3,25), (19,18,22), (23,13,29), (24,4,28)$。
一個天際線也可以用類似的「X-遞增序列」表示出來，例如上面的八棟建築合併之後上方右圖的天際線可表示為：
$(1, 11, 3, 13, 9, 0, 12, 7, 16, 3, 19, 18, 22, 3, 23, 13, 29, 0)$
請你寫一個程式，給你這些房子的位置，請你把它們形成的天際線描述出來。
對於每一筆測試資料，請按照題目以及範例輸出格式輸出天際線的樣子。
請注意，最後一個數字一定是0。也請不要輸出多餘空白。
Solution 考慮所有矩形的邊界上的點，我們只要確定這些點的最大高度就能夠描述這個天際線
更進一步的話題目要求的格式甚至只需要考慮左界這個點
因此我們維護一個 multiset
從左到右考慮所有邊界，對於任一個建築物的高度$H$，都在$L$的時候加進 multiset 裡面然後在$R$的時候刪掉
如果這個點的高度和前一次的答案一樣就不需要加進答案裡面
注意輸出格式QQ，一開始還吃WA好幾次
AC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include &amp;lt;bits/stdc++.</description></item><item><title>TIOJ-1156</title><link>https://omeletwithoutegg.github.io/2020/02/08/TIOJ-1156/</link><pubDate>Sat, 08 Feb 2020 12:29:14 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2020/02/08/TIOJ-1156/</guid><description>5.高中運動會 https://tioj.ck.tp.edu.tw/problems/1156
Description 夢幻城市每年為全市高中生舉辦一次運動大會。為促進各校同學之間的交流，採用特別的分隊方式：每一個學校的同學，必須被均勻分散到各隊，使得每一隊中該校的人數皆相同。為增加比賽的競爭性，希望分成越多隊越好。你的任務是由各校的人數，決定最多可分成的隊數。
Solution 沒想到全國賽竟然有這麼水的題目XDD，題目所求就是所有學校人數的最大公因數
用 __gcd 就足夠了，不過我覺得這份code寫起來很簡短所以我想貼出來ouo，順便加了個輸入優化
AC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include &amp;lt;cstdio&amp;gt; inline char readchar() { constexpr int B = 1&amp;lt;&amp;lt;20; static char buf[B], *p, *q; if(p == q &amp;amp;&amp;amp; (q=(p=buf)+fread(buf,1,B,stdin)) == buf) return EOF; return *p++; } inline int nextint() { int x = 0, c = readchar(); while(c &amp;lt; &amp;#39;0&amp;#39;) c = readchar(); while(c &amp;gt;= &amp;#39;0&amp;#39;) x=x*10+(c^&amp;#39;0&amp;#39;), c=readchar(); return x; } int gcd(int a, int b) { while(int t = b) b = a%b, a = t; return a; } signed main() { int n = nextint(), g = 0; while(n--) g = gcd(g, nextint()); printf(&amp;#34;%d\n&amp;#34;, g); }</description></item><item><title>TIOJ-1600</title><link>https://omeletwithoutegg.github.io/2020/01/26/TIOJ-1600/</link><pubDate>Sun, 26 Jan 2020 22:51:53 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2020/01/26/TIOJ-1600/</guid><description>爆炸吧現充~ https://tioj.ck.tp.edu.tw/problems/1600
Description 求共有幾個滿足
$$
1 \leq x \leq n,
\exists k &amp;gt; 1, k^2 | x
$$
的$x$
Solution 一開始我的想法是$[\mu(x)=0]$的前綴，想說用杜教篩或莫比烏斯反演什麼的，但怎麼推都推不出來
去問王政祺之後，他說直接枚舉平方數再排容就好，至於排容的係數就直接取$\mu$
令
$$
S_k = \{x | 1 \leq x = k^2t \leq n\}
$$
則答案就是
$$
\begin{matrix}
|\bigcup _ {k} S_k| &amp;amp;= &amp;amp; (|S_2| + |S_3| + |S_5| + |S_7| + \cdots)\newline
&amp;amp;- &amp;amp; (|S_6|+|S _ {10}|+|S _ {14}|+|S _ {15}|+ \cdots)\newline
&amp;amp;+ &amp;amp; (|S _ {30}|+|S _ {42}|+|S _ {66}|+|S _ {70}|+ \cdots)\newline</description></item><item><title>TIOJ-1283</title><link>https://omeletwithoutegg.github.io/2020/01/25/TIOJ-1283/</link><pubDate>Sat, 25 Jan 2020 23:37:00 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2020/01/25/TIOJ-1283/</guid><description>&amp;lt;! &amp;ndash; ### Author: Sean Liu &amp;ndash;&amp;gt;
超大畫框設置 https://tioj.ck.tp.edu.tw/problems/1283
Description 在一個「漸進式框架」當中，你想要找到一個最大面積的矩形位置放置你最喜愛的一幅畫。
當然地，畫框必須掛正，所以矩形的四個邊都必須與框架的邊平行或垂直。
所謂的「漸進式框架」，指的是任何一個水平線截出的框架區段是連續，並且由上往下該區段只會往右移動，如下圖
Solution 這個是蕭梓宏在超級久之前講的四邊形優化題目，筆者發現已經過了一年多了還沒AC就想說來寫看看好了！這一題不難想到，對於每一個在下面的線，都計算是哪一條在上面的線和它搭配會有最佳，再取$\max$就好了。不過，這樣需要$O(MN)$的時間，頗爛。
不過呢，還可以觀察（且證明）一個性質，就是：倘若$L(x)$為下面的線中第$x$條線所對應到的最佳（面積最大）的上面的線的編號，則$L(x + 1) \geq L(x)$！有了這個性質，大概就可以維護一個deque，裡面放一堆東西$(L, R, I)$來維護說：上面第$I$條線可以轉移下面第$L$到第$R$的線為最佳。一開始只有一個$(0, M, 0)$，然後每次進來一個上面的線段就開始判斷（假設目前deque中最後面的元素為$(L, R, I)$，且目前我在第$X$條）：
若$X$和$L$的矩形比$I$和$L$的矩形還大，這代表$(L, R, I)$這個區間可以完全不要了，pop掉 若$X$和$M - 1$的矩形比$I$和$M - 1$的矩形還小（也就是最後一個），則代表我永遠贏不了那一條線，我就直接break了，反正贏不了 否則，開始二分搜說我到哪裡可以贏$(L, R, I)$，也就是說，找一個最小的$m$使得$m$和$I$的矩形小於或等於$m$和$X$的矩形 維護完之後，再掃一次$M$條線取$\max$就好了！
AC code 感覺寫完到AC的時間還不會很久，但是中間有一堆小細節被卡（還有二分搜寫錯、被卡long long、$N, M$要除以二、面積計算出錯等有趣環節），幸好沒有太大的問題！
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 #include &amp;lt;iostream&amp;gt;#include &amp;lt;deque&amp;gt;#define int long long int #define ericxiao ios_base::sync_with_stdio(0);cin.</description></item><item><title>IOICamp-2020</title><link>https://omeletwithoutegg.github.io/2020/01/25/IOICamp-2020/</link><pubDate>Sat, 25 Jan 2020 23:08:29 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2020/01/25/IOICamp-2020/</guid><description>2020 IOIC 小記 五天都11點回家 好累喔
不過聽到很多神奇技巧和神奇題目(?)
Day 1 早上是常數優化與電腦結構，看到一些毒瘤的東東還有會造成我常數大的一些寫法
中午有貓貓時間，電仁分享了他競程的心得之後，丟給我們一些題目
可是我幾乎都不會做QQ
下午塗大為的DP&amp;amp;圖論，速度超快的www趕火車
聽到有點快要睡著，超難
晚上趣味賽有一個隊友還沒來QQ，不過這種類型的題目真棒
空白、tab和換行不算edit distance的規則沒有想到能讓註解佔了好多除蟲題的名額XD
Day 2 資料結構初階OwO!
直接從前一天下午的惡夢變成舒適的溫水浴，於是我決定自己翻講義刷題
可是圖論超煩躁，DP我也不會SCC我也一直寫爛，搞了快半天AC不了半題WTF
最後還被卡記憶體，直接怒不寫了QQ
下午原本是數學被換成根號算法，因為蔣立元有講過蠻多的所以YP這堂還算友善(?)
聽到很多有趣的題目，不過可惜我前一天自己看講義被捏到一些QQ
除了2的冪次分層(不知道怎麼用)以外都蠻喜歡的
因為分塊就是優美的暴力(O)
第一場個人賽，實在是打的有點差
pA被我擱置，聽到解法之後覺得超顯然QQ為甚麼我賽中不開啊
開場就碰pF，碰到結尾還AC不了，到底三小
我已經自認locality很好了欸QAQ而且取模乘法加法都有好好寫啊 早知道就多試一點順序了
pC開的極慢，DP式一直推不出來，有夠爛，還一直亂猜加一減一吃WA吃滿
pE水題太慢看到ww在附中練習賽有寫過所以速速AC
pD樹重心，推導一下式子之後想到二分搜祖先再加上去(題解後感覺這個解超爛QQ)
pG是樹上莫隊裸題，但我不知道為甚麼沒自信寫(X)
時間全都砸在pB，想到一個實作又臭又長的作法，花了好久實作之後TLE
到結束沒時間再寫出一題QQ
結束之後YP跟我說我差一點AC pB，要用degree分塊才不會爛掉(我就爛)
Day 3 早上字串，幾乎都是聽了n遍之後已經大概知道的東西(?)
AC前一天pB之後有點不知道要做啥
於是我試著刻了AC自動機，參考了一下講義上的code之後傳到TIOJ 1306得到SF
我想說是不是我空間開錯，怎麼開都會SF，看了一下其他人的AC code發現他們都開4e5
然後我開了還是SF，後來才發現是我有地方寫錯@_@
後面唯一覺得有興趣的後綴自動機仍然沒有聽懂(?)雖然之前在講師小莫的blog上面看過了不過還是感覺好複雜
隨機和近似實在是不太容易通靈出來，有些只要直覺的隨便亂做多次一點就足夠AC
但是竟然有要先自己創造另一個題目的算法XD太難啦
團體賽總算是有了第三個隊友
pH是裸題，pI是水題，隊友找出來之後我趕緊水掉
剩下根本找不出來甚麼題目可做XD
pD是簡單DP，可是我一直WA，還好隊友有提醒我一些鬼邊界狀況
剩下時間花了好多開pJ，結果還漏看一個條件，而且在樹上的想法也是錯的QQ
pB以為是簡單結論題沒想到原來是奇怪的經典題(?)
pC也應該猜一猜在賽中寫出來的，有點可惜
Day 4 電石的資結進階，除了Pattern以外都有稍微聽過(線段樹優化建圖是在某一次蕭梓宏選的virtual場看到的XD)
CDQ分治更是直接聽電石本人講過ww
Pattern這東西好神奇喔，我想還要好久我才能通透，感覺題目再一些變化的話我就看不出來了
下午是數學，但在上課之前出現神秘講師短短的講了Splay和LCT就不見了XD(聽說他是原本FFT的講師?)
中堂休息之後突然就切換到數學模式，頓時有種我不會數學的感覺，明明聽過那麼多東西卻無法好好應用
(也許我應該去精進我的數學實力? 要怎麼讀啊?)
個人賽一開始有想法只有pB，看到Scoreboard上面大家都AC pD就猜是水結論題直接給他猜結論下去XDD
接著花時間把pB寫掉了，雖然看到一些人在丟pC不過沒什麼想法，反而翻到pE是今天電石上課直接講過的東西XD</description></item><item><title>TIOJ-1168</title><link>https://omeletwithoutegg.github.io/2020/01/25/TIOJ-1168/</link><pubDate>Sat, 25 Jan 2020 21:20:17 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2020/01/25/TIOJ-1168/</guid><description>進階的入門 https://tioj.ck.tp.edu.tw/problems/1168
Description 你需要實作五個函式：
1 2 3 4 5 void pop_big(); void pop_small(); void push(int s); int big(); int small(); 其中第一個函式需要將最大的數字移除，第二個函式需要將最小的數字移除，第三個函式需要將一個數加入目前的數字們，第四個函式需要回傳當前的最大值，第五個函式需要回傳當前的最小值。
假設一開始沒有任何數字，請你實作這五個操作。
保證當沒有數字的時候只會呼叫 push ，並且加入的數字 $\leq 10^9$ ，五個函數的總呼叫次數 $\leq 10^6$ 。
Solution 好久之前就一直卡這題總算AC了@_@
最直覺的想法就是開一個multiset或map，但這題的時限超誇張的緊
可以想到利用 priority_queue 維護最大最小
然而假如一個數字在最大堆被pop掉，不容易在最小堆裡面把他給刪除
我一開始的想法是開 unordered_map 之類的紀錄每個數字的個數，想當然而吃了TLE
後來查了解才發現紀錄插入編號並且維護編號幾的被 pop 了就可以
於是我就在 priority_queue 裡面存編號，並且自己寫compare函式
不過這樣寫的locality很差，似乎會讓常數暴增
改成用struct包住之後剩下最後兩筆TLE，試了好久之後才想到 priority_queue 是用 vector 實作，動態開的空間顯然會浪費很多常數，不如自己靜態開一個大陣列
注意到 pop 操作最多就是呼叫次數的一半，所以 heap 只要開 5e5 就好了， push 的時候多出去的可以直接丟掉
至於 popped 陣列應該還是要開到 1e6 ，因為被 pop 的東西有可能編號很大，TIOJ上的測資似乎沒考慮到這個地方所以開 5e5 也能AC</description></item><item><title>TIOJ-1094</title><link>https://omeletwithoutegg.github.io/2020/01/24/TIOJ-1094/</link><pubDate>Fri, 24 Jan 2020 10:33:31 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2020/01/24/TIOJ-1094/</guid><description>C.幼稚國王的獎賞 https://tioj.ck.tp.edu.tw/problems/1094
Description 定義一個非負整數集合的價值是裡面所有數字XOR起來
給定一些非負整數，問你能選出價值最高的子集價值是多少？
Solution 經典題 maximum subset xor
線性基 首先可以把每個數字的二進位看成模2的$k$維向量
span 我們說一群向量$S = {\textbf{v}_ 1, \textbf{v}_ 2, \dots, \textbf{v}_ n}$的線性生成空間是
$$
\textrm{span}(S) = { \sum _ {i=1}^n\lambda _ i \textbf{v} _ i }
$$
也就是說$\textrm{span}(S)$代表的是所有$S$內的元素的有限線性組合
linear independent 對於一組向量${\textbf{v}_ 1, \textbf{v}_ 2, \dots, \textbf{v} _ n}$
若存在不全為$0$的$\lambda_1, \lambda_2, \dots, \lambda_n$使得
$$
\sum _ {i=1}^n\lambda_ i \textbf{v}_ i = \textbf{0}
$$
則我們說這群向量是線性相關的；反之則稱為線性獨立(linear independent)
一組線性相關的向量至少有一個向量可以用其他向量表示
說明: 不失一般性設$\lambda _ 1 \neq 0$，則</description></item><item><title>TIOJ-1408</title><link>https://omeletwithoutegg.github.io/2020/01/14/TIOJ-1408/</link><pubDate>Tue, 14 Jan 2020 21:06:04 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2020/01/14/TIOJ-1408/</guid><description>我很忙 https://tioj.ck.tp.edu.tw/problems/1408
Description 給定$n$個時段$[l_i, r_i)$
問至少有多少單位時間要是忙碌的才能滿足
「每個時段中都有至少$c_i$單位時間是忙碌的」(每單位時間都不是忙碌就是空閒)
註: 題目保證有解
Solution 看到這種很多區間的題目，就會很想把它們照右界從小到大排序
可以想到一個greedy策略
按右界遞增排序好之後，遇到一個時段就看是否已經滿足條件
如果已經滿足了就跳過
如果還沒有的話就必須選一些時間由空閒變為忙碌，而這些時間依照貪心的原則是從越右邊開始選越好
(選左邊的不會對之後右界更大的時段有比較多幫助)
檢查是否滿足條件只要維護區間和
於是我的作法是用一棵線段樹配上一個 stack
每次新插入一個時段，先以線段樹查詢這個區間內忙碌的時間總共是多少
接著對於剩下需要再增加的時間，維持 stack 內是不相交且排序好的一些時段，代表那些時間必須要是忙碌的
只要看目前最右邊的忙碌時段就能處理好
這份AC code中我沒有值域壓縮(因為我懶)
一臉在CF上欠hack
AC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 #include &amp;lt;bits/stdc++.</description></item><item><title>TIOJ-1152</title><link>https://omeletwithoutegg.github.io/2020/01/12/TIOJ-1152/</link><pubDate>Sun, 12 Jan 2020 23:02:02 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2020/01/12/TIOJ-1152/</guid><description>1.銀河帝國旅行社 https://tioj.ck.tp.edu.tw/problems/1152
Description 給一棵樹，找最遠的兩個點的距離
Solution 這裡用類似DP的方法
dfs(i) 回傳一個 {ans, deepest} 分別表示以$i$為根子樹中的答案和從$i$往下走的最遠距離
那ans可以分成有經過$i$的和沒經過的，有經過的就看最深的兩個子樹加起來是多少，沒經過的就遞迴下去算
AC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include &amp;lt;bits/stdc++.h&amp;gt;#define pb emplace_back #define ff first #define ss second using namespace std; int n; vector&amp;lt;int&amp;gt; g[N]; pair&amp;lt;int,int&amp;gt; dfs(int i) { vector&amp;lt;int&amp;gt; tmp{0}; int ans = 0; for(int j: g[i]) { auto p = dfs(j); ans = max(ans, p.</description></item><item><title>bamboofox-ctf</title><link>https://omeletwithoutegg.github.io/2020/01/02/bamboofox-ctf/</link><pubDate>Thu, 02 Jan 2020 15:00:23 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2020/01/02/bamboofox-ctf/</guid><description>這次打跨年CTF應該是我第一次打一個正常的CTF吧（？）
感覺好多有趣的題目www
https://ctf.bamboofox.cs.nctu.edu.tw/
Solved Problems Welcome Joy說看題目給的影片就有flag了
Web newbie 被作業解掉，好像往source code的註解裡面找就對了
Land-1 良心題
直接copy全國模擬賽的code，送我們這些有打的人免費分數
Land-2碰了好久一直CE，QQ
I can&amp;rsquo;t see you 給了一個 what.rar ，Joy說不知道密碼不過丟到網路上某個工具就解開了XD(密碼是blind，聽說有人直接猜出來)
之後會看到一張白底有黑點的圖片，對照盲人點字可以拿到flag
How2decompyle 題目給了一個沒有副檔名的檔案
因為題目名稱裡面有py，嘗試把他丟到google找到的decompyler之類的東西?
不過因為沒有副檔名他不吃，他只吃.py和.pyc(這時我們才知道我們大概拿到.pyc，是byte code XDD)
於是改副檔名再丟一樣的地方就得到原始的.py檔了
讀一下發現怎麼讓他跑出flag之後跑一跑就AC了(?)
Happy New Year 賽中新增的題目，直接給flag ww
Tree 作業丟給我的(?)
解壓縮他給的檔案之後發現看起來很欠DFS，確定葉節點是檔案可以直接讀之後就想寫個DFS
不過shell的遞迴我不會，想說用python，不過還是要查套件:(，爛死
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from os import chdir from glob import glob def dfs(s): s = s[0] #print(&amp;#39;s = &amp;#39;, s) typ = s[-1] #print(typ) if typ == &amp;#39;+&amp;#39;: return dfs(glob(s+&amp;#34;/0_*&amp;#34;)) + dfs(glob(s+&amp;#34;/1_*&amp;#34;)) if typ == &amp;#39;x&amp;#39;: return dfs(glob(s+&amp;#34;/0_*&amp;#34;)) * dfs(glob(s+&amp;#34;/1_*&amp;#34;)) if typ == &amp;#39;r&amp;#39;: #print(&amp;#39;path = &amp;#39;, s) return int(open(s).</description></item><item><title>TIOJ-2037</title><link>https://omeletwithoutegg.github.io/2019/12/31/TIOJ-2037/</link><pubDate>Tue, 31 Dec 2019 16:06:00 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2019/12/31/TIOJ-2037/</guid><description>警力配置 https://tioj.ck.tp.edu.tw/problems/2037
Description 裸的二分圖匹配
Solution 這邊給匈牙利算法
有一個subtask是給一個點數很多的樹
特判用dp即可
AC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 // __________________ // | ________________ | // || ____ || // || /\ | || // || /__\ | || // || / \ |____ || // ||________________|| // |__________________| // \###################\ // \###################\ // \ ____ \ // \_______\___\_______\ // An AC a day keeps the doctor away.</description></item><item><title>TIOJ-1441</title><link>https://omeletwithoutegg.github.io/2019/12/31/TIOJ-1441/</link><pubDate>Tue, 31 Dec 2019 15:03:27 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2019/12/31/TIOJ-1441/</guid><description>萬里長城 https://tioj.ck.tp.edu.tw/problems/1441
Description 給定一個序列，找出最長的「長城」子序列
一個序列$&amp;lt; a_1,a_2,\dots,a_n &amp;gt;$必須符合下列幾點才算是「長城」
n是奇數 若$i$是偶數，則$a_i$必須小於相鄰的項 若$i$是奇數，則$a_i$必須大於相鄰的項 Solution 貪心法
維護一個tail表示前$i$項滿足點2. 3.的最佳解，其結尾是多少
假設下一個項h必須比tail大
若h比tail大，那就直接接上去(並更新tail)，否則就把tail替換成h
反之亦然
證明大概可以用數歸吧(?)我也不太會說明QQ
AC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include &amp;lt;iostream&amp;gt;signed main() { ios_base::sync_with_stdio(0), cin.tie(0); int n, tail = -1, inc = 1, ans = 0; cin &amp;gt;&amp;gt; n; while(n--) { cin &amp;gt;&amp;gt; h; if(h == tail) continue; if(h &amp;lt; tail ^ inc) ++ans, inc = !</description></item><item><title>Modulo-Arithmetic</title><link>https://omeletwithoutegg.github.io/2019/12/30/Modulo-Arithmetic/</link><pubDate>Mon, 30 Dec 2019 13:25:22 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2019/12/30/Modulo-Arithmetic/</guid><description>同餘算數 定義 $$m | (a-b) \Leftrightarrow a \equiv b \pmod m$$
或者說$a,b$同餘於$m$
基本性質 當一個題目要求答案模一個數字$m$時
通常我們都可以不用先算出一個很大的答案再取模
利用下面的規則能夠在計算的過程中一邊取模(加減乘不會改變等價關係)
設
$$
\left \{
\begin{matrix}
a_0 \equiv a_1 \pmod m\newline
b_0 \equiv b_1 \pmod m
\end{matrix}
\right .
$$
則易得到
$$
\left \{
\begin{matrix}
a_0 \pm b_0 \equiv a_1 \pm b_1 \pmod m\newline
a_0b_0 \equiv a_1b_1 \pmod m
\end{matrix}
\right .
$$
模逆元 在一般實數的除法時，如果我們想知道除以$a$的結果，可以看成乘上倒數$1/a$
也就是說找一個$x$使得$ax = 1$
而在模$m$的情況下，我們同樣也可以用一個使得$ax \equiv 1$的$x$來代替除以$a$的運算，稱為模逆元
(如果常常打CF的話應該常常看見上面模逆元的敘述)
求取模逆元$x = a^{-1}$只要把同餘關係改寫成$ax = my+1$就可以用擴展歐幾里得求解了</description></item><item><title>TIOJ-1567</title><link>https://omeletwithoutegg.github.io/2019/12/29/TIOJ-1567/</link><pubDate>Sun, 29 Dec 2019 21:08:14 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2019/12/29/TIOJ-1567/</guid><description>黑色騎士團的飛彈野望 https://tioj.ck.tp.edu.tw/problems/1567
Description 給定平面上$n$個點，求至少要用幾個圓心在$x$軸上、半徑為$r$的圓才能覆蓋所有點
若不可行輸出-1
Solution 首先我們對每個點都可以知道包覆它的圓的圓心範圍在$x$軸的哪段區間
那題目就轉換成在$x$軸上放一些圓心，使得每個點對應的區間內都至少有一個點被選到
此為greedy經典題，按照右界排序後，由小到大檢查若某個區間還沒有放東西就放一個在它的右界
證明很簡單，右界最小的區間內一定至少要選一個點放
假設沒有選右界$r$而選了某個點$i$放，則改選右界，不會有其他右界更大的區間$I$包含$i$卻不包含$r$
故選右界最小的區間的右界不會錯過最佳解
無解的判斷就是只要有一個點和$x$軸距離超過$r$就不可行，否則顯然至多用$n$個圓可以覆蓋所有點
AC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 // __________________ // | ________________ | // || ____ || // || /\ | || // || /__\ | || // || / \ |____ || // ||________________|| // |__________________| // \###################\ // \###################\ // \ ____ \ // \_______\___\_______\ // An AC a day keeps the doctor away.</description></item><item><title>FFT-NTT</title><link>https://omeletwithoutegg.github.io/2019/12/25/FFT-NTT/</link><pubDate>Wed, 25 Dec 2019 14:56:54 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2019/12/25/FFT-NTT/</guid><description>捲積方法 OAO 本篇的重點應該是放在理解與使用與競程相關的捲積，其中會利用到FFT或NTT加速
這邊先定義一下捲積$ * $是什麼
$$
(a * b) _ x = \sum _ {i+j=x} a_i b_j
$$
實際上就等價於我們常見的多項式乘法
naive的做法是$\mathcal{O}(n^2)$，顯然不夠令人滿意
1 2 3 4 5 for(int i = 0; i &amp;lt; A.size(); i++) { for(int j = 0; j &amp;lt; B.size(); j++) { res[i+j] += A[i] * B[j]; } } DFT 先假設我們有兩個多項式
$$
A(x) = \sum a_i x^i, B(x) = \sum b_i x^i\newline
C(x) = A(x)B(x)</description></item><item><title>Sieving-Method</title><link>https://omeletwithoutegg.github.io/2019/12/24/Sieving-Method/</link><pubDate>Tue, 24 Dec 2019 12:41:46 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2019/12/24/Sieving-Method/</guid><description>!待補QQ
質數篩與快樂的積性函數 想必大家都精通各種質數篩法，最簡單的$\mathcal{O}(n\sqrt{n})$就不提啦
$n\log n$篩 1 2 3 4 5 for(int i = 2; i &amp;lt;= n; i++) { for(int j = i*2; j &amp;lt;= n; j+=i) { sieve[j] = 1; } } $\sum \frac{1}{i}$的調和級數是$\mathcal{O}(\log n)$量級的，故複雜度為$\mathcal{O}(n\log n)$
這個寫法也可以很簡單的統計每個數字的因數個數
1 for(int i = 1; i &amp;lt;= n; i++) for(int j = i; j &amp;lt;= n; j+=i) ++d[j]; 其中 d[i] 代表 i 的因數個數
容易發現$\sum\limits _ {i=1}^n d[i]$也是$\mathcal{O}(n\log n)$量級的</description></item><item><title>TIOJ-1726</title><link>https://omeletwithoutegg.github.io/2019/12/23/TIOJ-1726/</link><pubDate>Mon, 23 Dec 2019 22:14:53 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2019/12/23/TIOJ-1726/</guid><description>Dice Wars https://tioj.ck.tp.edu.tw/problems/1726
Description Dice Wars是一款兼具謀略和運氣的遊戲。
遊戲中你扮演紫色的骰子，要攻下其他顏色的骰子的城池，進而統一全地圖。
如今你選到了一張看起來不錯的地圖: 整張地圖呈一條直線，每個位置都有一個顏色勢力佔領。
由於每次移動到相鄰異色的城池都必須經歷一場鏖戰，你想先經過程式計算後再進行遊戲。
你想要每次詢問一個顏色對$(S, T)$，問從任何一個$S$的城池到任一個$T$的城池至少要經過幾場戰鬥。
如果$S$或$T$已經滅亡(地圖中沒有任何一個該勢力)，就輸出$-1$。
Solution 題敘裡面附上的遊戲好好玩www
題目要問的其實就是$\min\limits _ {c_i=S,c_j=T}(|i-j|)$
可以想到對每種顏色開一個 vector 紀錄他們的index
一種naive$\mathcal{O}(nq)$的方法是每次詢問都直接把兩種顏色的兩個 vector merge $\mathcal{O}(n)$合併並計算答案
而另一種naive的算法則是先針對每一種顏色$\mathcal{O}(n)$預處理其對其他顏色的答案，複雜度$\mathcal{O}(n^2+q)$
前者拉低複雜度的關鍵是某種顏色出現很多次
而後者則是會因為太多種顏色而複雜度爛掉
怎麼辦呢？可以不要全部預處理，只針對出現次數超過$k$的顏色做預處理，這些顏色的種類數不會超過$\frac{n}{k}$種
故預處理需要$\mathcal{O}(\frac{n^2}{k})$
而對於詢問的兩個顏色的出現次數都沒有超過$k$的情況，可以直接用上面第一個算法處理
複雜度$\mathcal{O}(qk)$
根據算幾不等式可取$k=\frac{n}{\sqrt{q}}$有複雜度$\mathcal{O}(n\sqrt{q})$
註: 這題我寫的時候 ans 開原生陣列MLE，不知為何用vector陣列會是好的
AC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 #include &amp;lt;bits/stdc++.</description></item><item><title>TIOJ-1674</title><link>https://omeletwithoutegg.github.io/2019/12/19/TIOJ-1674/</link><pubDate>Thu, 19 Dec 2019 10:58:57 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2019/12/19/TIOJ-1674/</guid><description>新專輯 https://tioj.ck.tp.edu.tw/problems/1674
Description 最近你打算訂購$N^2$張水樹奈奈的專輯《極限魅惑IMPACT EXCITER》。
由於份量實在是太多了，你決定分散成$N$份訂單。
然而，不幸的，依據博客來新的訂貨規定，每一位顧客第$k$次下訂單所訂的CD張數必頇是$k$的正整數倍。
換句話說，一位顧客第$5$次訂的CD張數只可能是$5$張、$10$張、$15$張、…依此類推。
當然，原先你把$N^2$張CD分散在$N$份訂單的目的就是為了讓一張訂單中最多只會有$N$張CD。
即使博客來多了這項奇怪的規定，你仍然不打算捨棄你的原則，只是這樣每份訂單訂的數量可能會達不到你原來的期望。
無論如何，你還是下了訂單。為了估計你實際訂下的CD數與你期望訂下的CD數的差別，你決定把每次你少訂的數量加起來。
可是，因為你可能少訂非常多張CD，所以你希望算出少訂的總數量除以$10^9+9$的餘數。
也就是說，如果你總共要訂$3^2$張CD，分成三次訂的話，
那你第一、第二、第三次分別可以訂$3$、$2$、$3$張CD，分別會少訂是$0＋1＋0＝1$張CD。
Solution 仔細讀懂題目之後可以發現題目要求的就是
$$
\sum _ {i=1}^n n%i
$$
不過$n$可以到$10^{13}$不能直接$\mathcal{O}(n)$跑過去
數論分塊 數論分塊的精神很簡單，不同的$\lfloor n/i \rfloor$數量只有$\mathcal{O}(\sqrt{n})$種
說明:
對於$i \leq \sqrt{n}$，最多只有$\sqrt{n}$種不同的值
對於$i &amp;gt; \sqrt{n}$，$\lfloor n/i \rfloor &amp;lt; \sqrt{n}$最多也只有$\sqrt{n}$種不同的值
怎麼快速枚舉可能的$\lfloor n/i \rfloor$？
1 2 3 4 5 6 for(int i = 1,j,x; i &amp;lt;= n; i = j+1) { x = n/i; j = n/x; // j是最大的數字使得j*x &amp;lt;= n，意即[i,j]區間內正好是所有n/k=x的數字 // use n/i here } 回到剛剛的式子，把他改寫成</description></item><item><title>TIOJ-1035</title><link>https://omeletwithoutegg.github.io/2019/12/18/TIOJ-1035/</link><pubDate>Wed, 18 Dec 2019 08:08:39 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2019/12/18/TIOJ-1035/</guid><description>通關密語 https://tioj.ck.tp.edu.tw/problems/1035
Description 給定兩個長度小於 $5 \times 10^4$ 的小寫英文字母字串 $S,T$
定義「最佳擬合」，就是將 $S$ 經過平移後和 $T$ 比對，同樣的字元數最多的那一種方法。
請輸出一個正整數，代表最佳擬合的方案下，相同的字元有幾個。
ex.
對於
ababa
babab
來說，
ababa
=babab
這是一種最佳擬合的方法，$S$經過向左平移之後$S,T$有四個位置的字元相同
Solution naive的$n^2$做法可以AC本題，只要妥當控制常數即可
不過這裡提供一個NTT的$\mathcal{O}(C\cdot n\log n)$解
假設$S$對$T$的平移量是$x$(可以為負的)，題目所求為
$$
\sum _ {i-j = x} [S_i = T_j]
$$
的最大值
那我們枚舉26種英文字母，可以寫成
$$
\sum _ {c \in \sigma} \sum _ {i-j = x} [S_i = c] \cdot [T_j = c]
$$
令$F_i = [S_i = c], G_j = [T _ {-j} = c]$</description></item><item><title>TIOJ-1171-LCT</title><link>https://omeletwithoutegg.github.io/2019/12/14/TIOJ-1171-LCT/</link><pubDate>Sat, 14 Dec 2019 23:50:21 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2019/12/14/TIOJ-1171-LCT/</guid><description>動態樹的奮鬥 為了這題的Link-Cut-Tree解我花了不只一整天XD
壓常實在是神奇的事，把 long long 改成 int 再加上幾個 pragma 終於成功壓過唯一奇怪的那筆= =
而且 push 竟然還不能用遞迴寫，到底三小
LCT怎麼這麼可撥XD
不過壓過去那筆之後其他筆的執行時間加起來超少，值得了
註: 模板是參考日月卦長那裡的，大概不會有時間會為這篇補上解說吧，大家自己google
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 #pragma g++ optimize(&amp;#34;Ofast&amp;#34;) #pragma loop_opt(on) #include &amp;lt;cstdio&amp;gt;#include &amp;lt;bitset&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std; typedef long long ll; const int N = 100025; inline char readchar() { const static int B = 1&amp;lt;&amp;lt;20; static char buf[B], *p, *q; // p,q would be initialized with nullptr if(p == q &amp;amp;&amp;amp; (q=(p=buf)+fread(buf,1,B,stdin)) == buf) return EOF; return *p++; } inline int nextint() { int x = 0, c = readchar(); while(&amp;#39;0&amp;#39;&amp;gt;c || c&amp;gt;&amp;#39;9&amp;#39;) c = readchar(); while(&amp;#39;0&amp;#39;&amp;lt;=c&amp;amp;&amp;amp;c&amp;lt;=&amp;#39;9&amp;#39;) x = x*10 + (c^&amp;#39;0&amp;#39;), c = readchar(); return x; } // \sum{cnt[p] * w[p]} struct LinkCutTree { // Splay struct node { ll ws, sum; int laz, cnt, w; int ch[2], pa; } S[N]; bool isroot(int x) { // is the root of the splay tree return S[S[x].</description></item><item><title>TIOJ-1950</title><link>https://omeletwithoutegg.github.io/2019/12/13/TIOJ-1950/</link><pubDate>Fri, 13 Dec 2019 23:26:11 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2019/12/13/TIOJ-1950/</guid><description>小向的試煉 2-3：轉！(Rotate!) https://tioj.ck.tp.edu.tw/problems/1950
Description 給定長度$N$的排列，問「以交換任意兩個數字的方式排序這個序列需要多少次數」
另外有$M$次修改，每次修改會交換數字$i$和數字$j$的位置，請輸出$M+1$行代表一開始和每次修改過後的答案
Solution 已經知道每個數字應該被放到哪裡了，所以我們可以想到一個排序方法
每次看某個位置$i$的數字$x$，如果和$i$不同的話就把$x$放到位置$x$的地方，再繼續對原本放在位置$x$的地方的數字做同樣的事
可以發現這樣會形成好幾個「環」，例如範測的$(1, 4, 2, 5, 3)$會形成兩個環
$$
\begin{pmatrix}
1
\end{pmatrix}
\begin{pmatrix}
4 &amp;amp; 5 &amp;amp; 3 &amp;amp; 2
\end{pmatrix}
$$
或是$(1, 6, 4, 5, 3, 2)$會形成三個環
$$
\begin{pmatrix}
1
\end{pmatrix}
\begin{pmatrix}
6 &amp;amp; 2
\end{pmatrix}
\begin{pmatrix}
4 &amp;amp; 5 &amp;amp; 3
\end{pmatrix}
$$
也就是說，每個環代表第一個元素要放到第二個元素的位置，第二個元素要放到第三個元素的位置&amp;hellip;以此類推
一個大小$L$的環需要的交換次數是$L-1$，所以把$1\dots n$的排列排序好所需的時間就是$n-($環的個數$)$
用數學一點的講法就是一個置換可以分解成好多不相交的輪換(?)而且方法是唯一的喔
考慮一下交換了兩個數字會發生什麼事:
如果他們在同一個「環」裡面，那那個環就會被切成兩個環
反之則會讓兩個環合在一起，變成一個「環」
示意圖大概就是這樣
要怎麼辦到這件事呢？快速把元素之間連接或者切斷，我們會想到使用鏈結串列，但是這樣無法判斷他們是否在同一個環裡面
退而求其次可以使用二元樹來維護，用$\mathcal{O}(\log n)$獲得可以剪切又可以黏貼序列的神力(?)
我選擇用splay來實作，詳細的原理自己google OwO
AC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 // __________________ // | ________________ | // || ____ || // || /\ | || // || /__\ | || // || / \ |____ || // ||________________|| // |__________________| // \###################\ // \###################\ // \ ____ \ // \_______\___\_______\ // An AC a day keeps the doctor away.</description></item><item><title>TIOJ-1394</title><link>https://omeletwithoutegg.github.io/2019/12/13/TIOJ-1394/</link><pubDate>Fri, 13 Dec 2019 06:36:47 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2019/12/13/TIOJ-1394/</guid><description>黑色騎士團的逆襲野望 https://tioj.ck.tp.edu.tw/problems/1394
Description 自從黑色騎士團上次的最終野望被白色騎士豬殺苦破滅之後，黑色騎士團銷聲滅跡了一陣子，不過他們仍繼續計畫著侵略神聖的大不列顛帝國。
終於他們發現了一個機會：原來大不列顛帝國的命脈就是對外輸出的藥品&amp;quot;REBRAIN&amp;quot;，只要能控制住它所有的運輸與加工途徑，那大不列顛帝國就完了！
與之前一樣，他們只要佔領一個據點就可以控制與他相鄰的運輸途徑了！
&amp;ldquo;REBRAIN&amp;quot;的運輸過程十分有趣，他有一個總工廠來製造&amp;quot;REBRAIN&amp;quot;的一些半成品，再依序經過幾個有向道路到下個加工地點進行加工，就這樣一直到完成成品，並且為了不讓產品流程出問題，他們的運輸路徑不會出現環狀或逆向的情況。
不過黑色騎士團的人手有限，所以他們希望佔據最少的據點就可以完全控制整個運輸與加工途徑。
註: 雖然是有向邊，不過相鄰的關係依然是互相的；另外雖然沒有講的很清楚，題目是有保證0號節點可以走到所有其他節點
Solution 題目所求是最小點覆蓋，也就是在給定圖上要選幾個點才能保證所有邊都有一個端點被選到
因為這題給的是DAG，所以我們可以考慮用DP的方式做
狀態$dp[i][s]$代表$i$往子孫走的邊都已經保證有端點被選到的答案，若$s=1$代表有選$i$這個點，反之沒有
可以知道如果沒有選$i$這個點，那他的子節點都一定要選，所以
$$dp[i][0] = \sum\limits _ {j\in son(i)} dp[j][1]$$
如果選了$i$這個點，那他的子節點可選可不選，我們就取比較小的那個，有
$$dp[i][1] = 1 + \sum\limits _ {j\in son(i)} \min(dp[j][0],dp[j][1])$$
最後取的答案是0號節點選或不選取$\min$
AC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std; const int N = 33001; int dp[N][2], vis[N]; vector&amp;lt;int&amp;gt; g[N]; void dfs(int i) { if(vis[i]) return; vis[i] = true; dp[i][0] = 0; dp[i][1] = 1; for(int j:g[i]) { dfs(j); dp[i][0] += dp[j][1]; dp[i][1] += min(dp[j][0],dp[j][1]); } } signed main() { ios_base::sync_with_stdio(0), cin.</description></item><item><title>TIOJ-1739</title><link>https://omeletwithoutegg.github.io/2019/12/11/TIOJ-1739/</link><pubDate>Wed, 11 Dec 2019 15:26:33 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2019/12/11/TIOJ-1739/</guid><description>[APIO &amp;lsquo;08] Beads [Interactive] https://tioj.ck.tp.edu.tw/problems/1739
Description 有一個長度$n$的序列$a$，一開始$a_i = i$
接下來有$m$個操作，每個操作只會交換相鄰的兩個數字
接著有$q$個詢問，每次會詢問：第$t$個操作之後，數字$x$被放到哪個位置？
$n,m,q \leq 3 \times 10^5; 1 \leq x \leq n; 1 \leq t \leq m$
Solution 對序列保存不同的版本，當然持久化資料結構砸下去就對啦
是說本來想寫treap不過我實作能力好差QQ
什麼？你想問什麼是持久化？
反正就是用樹來存一個序列啦，然後因為改一個數字時只要改他到根的那條鏈就好了啦，這樣每次修改新增的點數會和樹高一樣
AC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 // __________________ // | ________________ | // || ____ || // || /\ | || // || /__\ | || // || / \ |____ || // ||________________|| // |__________________| // \###################\ // \###################\ // \ ____ \ // \_______\___\_______\ // An AC a day keeps the doctor away.</description></item><item><title>TIOJ-1948</title><link>https://omeletwithoutegg.github.io/2019/12/11/TIOJ-1948/</link><pubDate>Wed, 11 Dec 2019 13:24:35 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2019/12/11/TIOJ-1948/</guid><description>小向的試煉 2-1：洞穴(Cave) https://tioj.ck.tp.edu.tw/problems/1948
Description 小向在洞穴裡偵察到了$N$個烏龍，不知道是本尊還是分身。不過他們在洞穴中都是以每秒1公分的速度前進，只是有的朝著左邊的入口前進，而有的朝著右邊的入口前進。而由於洞穴相當狹窄，兩個相向的烏龍相撞時會回頭。小向大膽猜測，本尊一定會在所有分身都出洞穴被小向打敗後才出洞穴，瞄準小向用盡魔力的那剎那攻擊小向。不過她也沒那麼多時間等所有分身慢慢走出來再找到本尊，所以小向希望能直接用她剛剛偵察到的資訊判斷哪個是本尊。($N\leq10^6$，洞穴的長度$L\leq10^9$)
注意：離開洞穴的定義是從左邊的入口往左走一步或從右邊的入口往右走一步。保證答案唯一，並且所有烏龍都在不同位置。
Solution 首先若不管烏龍的編號，只想知道烏龍最後的位置，兩個烏龍相撞並回頭時可以當作穿過去
顯然地，我們可以知道所有烏龍最晚離開洞穴的時刻，就等於每隻烏龍單獨放在洞穴內離開洞穴的時刻的最大值，我們也能知道最後一隻離開洞穴的烏龍是向左還是向右
接著可以發現在烏龍相撞的過程中，左右順序一定不會變，意思是如果某個編號$i$的烏龍一開始是x座標第$k$大的，那不管經過多少次的相撞，他仍然會是x座標第$k$大的
同時向左的烏龍數量與向右的烏龍數量也不會變
所以，我們可以知道最後一隻烏龍離開洞穴時，一定是左邊全部向左，右邊全部向右，而那隻最後離開的烏龍一定是「向左的烏龍中最右邊的或者向右的烏龍中最左邊的」，也就知道了最後離開的烏龍是x座標第幾大的了
用 nth_element 可以快速找出x座標第$k$大的編號，注意一開始他給的編號沒有按照x座標排序，上述推論必須先照x座標排序才會是對的= =
AC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #pragma g++ optimize(&amp;#34;Ofast&amp;#34;) #pragma loop_opt(on) #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;const int N = 1000001; int n,L,x[N],id[N],cnt; signed main() { int t = -1e9, dir, pos; scanf(&amp;#34;%d%d&amp;#34;,&amp;amp;n,&amp;amp;L); for(int i = 0,d; i &amp;lt; n; i++) { scanf(&amp;#34;%d%d&amp;#34;,x+i,&amp;amp;d); int dis = d ?</description></item><item><title>Iterative-SegmentTree</title><link>https://omeletwithoutegg.github.io/2019/12/07/Iterative-SegmentTree/</link><pubDate>Sat, 07 Dec 2019 20:48:20 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2019/12/07/Iterative-SegmentTree/</guid><description>迭代式線段樹 先備知識: 線段樹(帶懶標) + 位元運算(吧)
如果讀者還不知道線段樹的原理最好看遞迴的(?)
單點修改 例題仍然是萬年RMQ
給定一個長度$n$的序列，請支援以下操作
將位置$p$的值改為$x$ 查詢區間$[l,r)$的最大值 完美二元樹 首先假定$n$是2的冪次，思考可能可以簡單一些
我們一樣用1當根，並且節點i的左右子樹會是i*2和i*2+1或寫成i&amp;lt;&amp;lt;1, i&amp;lt;&amp;lt;1|1
1 2 const int N = 1&amp;lt;&amp;lt;18; int tr[N&amp;lt;&amp;lt;1], n; 對於初始化來說，可以發現葉子節點對應的都是長度$1$的區間，正好是原序列的值，所以可以直接讀入或另外傳入賦值給 tr[i+n]，接著可以用遞減的順序把其他長度的區間的答案算好
1 2 3 4 void build(int v[]) { for(int i = 0; i &amp;lt; n; i++) tr[i+n] = v[i]; for(int i = n-1; i &amp;gt; 0; i--) tr[i] = max(tr[i&amp;lt;&amp;lt;1], tr[i&amp;lt;&amp;lt;1|1]); } 更新一個節點$p$，那麼只有$p$的所有祖先的答案會被影響到</description></item><item><title>TIOJ-2017</title><link>https://omeletwithoutegg.github.io/2019/12/06/TIOJ-2017/</link><pubDate>Fri, 06 Dec 2019 13:03:18 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2019/12/06/TIOJ-2017/</guid><description>B.廢文大資料 mining https://tioj.ck.tp.edu.tw/problems/2017
Description 給定一個序列 $a_i$ ，問有多少區間 $[l,r]$ 使得存在一個 $m \leq r$ 滿足 $\sum\limits _ {i=l}^m a_i &amp;lt; 0$？
Solution 先對 $a_i$ 做前綴 $s_k = \sum\limits _ {i=1}^k a_i$
對於一個固定的 $l$ 來說，題目等價於找到一個最小的 $m$ 使得 $s_m - s _ {l-1} &amp;lt; 0$
在 $m$ 之後的 $r$ 都會被算在答案裡面
可以用單調隊列幫每個 $i$ 找到最小的 $i'$ 使得 $s _ {i'} &amp;lt; s_i$ ，複雜度 $\mathcal{O}(n)$
AC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include &amp;lt;bits/stdc++.</description></item><item><title>TIOJ-1614</title><link>https://omeletwithoutegg.github.io/2019/12/06/TIOJ-1614/</link><pubDate>Fri, 06 Dec 2019 12:51:45 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2019/12/06/TIOJ-1614/</guid><description>販賣機耶 https://tioj.ck.tp.edu.tw/problems/1614
Description 蝴蝶在路旁玩壞一台販賣機，它一次只能投一枚硬幣（故障？）。
重點是：投進一枚x元的硬幣，然後按退幣鈕，居然會吐出一枚價值 $f(x)$ 的硬幣耶！
更神秘的是，天才蝴蝶已經發現 $f(x) = x + (x-b_1) (x-b_2) (x-b_3) \dots (x-b_m)$。
現在蝴蝶手上有 $n$ 枚硬幣，分別是 $a_1 \dots a_n$，請問蝴蝶投進去會賺的硬幣有幾枚？
Solution 題目就是問$f(x)-x = \prod\limits _ {i=1}^m (x-b_i)$是不是正的
然後看有幾個$b_i$小於$x$就可以知道乘積的正負號了(國中數學??)
另外注意$x - b_i = 0$的case，然後也不要亂 unique ，要保持個數的奇偶性。
AC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std; const int N = 100025; int n,m,a[N],b[N]; signed main() { ios_base::sync_with_stdio(0), cin.</description></item><item><title>Fast-IO</title><link>https://omeletwithoutegg.github.io/2019/12/06/Fast-IO/</link><pubDate>Fri, 06 Dec 2019 11:16:37 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2019/12/06/Fast-IO/</guid><description>常用的輸入(出)優化 cin / cout 因為C++ template的性質，不同變數型別的輸出方式都大同小異，算是實用
競程的時候記得開下面兩個東西
1 ios_base::sync_with_stdio(0), cin.tie(0); 開了之後就不要使用 stdio 裡面的東西啦
另外若非互動題也不要使用 endl 之類會flush的函式，請用 '\n' 代替
scanf / printf 常用的也就那些
1 2 3 4 5 6 7 8 9 10 11 #include &amp;lt;cstdio&amp;gt;int main() { int x,y; long long L; scanf(&amp;#34;%d%d%lld&amp;#34;, &amp;amp;x, &amp;amp;y, &amp;amp;L); printf(&amp;#34;%lld\n&amp;#34;, x+y+L); char s[100]; scanf(&amp;#34;%s&amp;#34;, s); for(int i = 0; s[i]; i++) s[i] = (s[i]-&amp;#39;a&amp;#39;+1)%26+&amp;#39;a&amp;#39;; printf(&amp;#34;%s\n&amp;#34;, s); } 值得注意的是 iostream 的空間有點大，所以想要壓空間用 stdio 就對了</description></item><item><title>TIOJ-1927</title><link>https://omeletwithoutegg.github.io/2019/12/06/TIOJ-1927/</link><pubDate>Fri, 06 Dec 2019 10:36:19 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2019/12/06/TIOJ-1927/</guid><description>同步(Sync) https://tioj.ck.tp.edu.tw/problems/1927
Description 在一個多人單向卷軸遊戲中，有$N \leq 10^5$個格子，每個格子都有一個不超過$10^9 + 6$的正整數，代表該格的狀況。
有時遊戲中的兩人會產生「同步」的現象。產生同步的條件是兩人所在的格子的數字$a,b$分別滿足
$$
(ab)^{\frac{p-1}{2}} \equiv 1 \pmod p
$$
其中$p = 10^9 + 7$。產生同步後，兩人會瞬移至下一格。如果在下一格又產生「同步」，則會繼續往下走，直到其中一人超出格子範圍(到了終點了)或者兩人不再同步。
Solution 對於$x \not\equiv 0 \pmod p$，$y = x^{\frac{p-1}{2}} \equiv \pm 1 \pmod p$
因為$y$是$1$的平方根(?)
然後$(ab)^{\frac{p-1}{2}} \equiv a^{(\frac{p-1}{2})} b^{(\frac{p-1}{2})}$
所以可先把所有值先$(p-1)/2$次方，一定會是$\pm 1$，接著他們同步的條件就可以簡化成$a = b$了
考慮到同步必須要是連續的性質，我們聯想到字串演算法中的後綴陣列，這題等價求兩個後綴的LCP，完全是SA的形狀XDD
SA + RMQ資結收工
注意查詢兩個同樣位置的情況，RMQ會查到空區間，不過我們知道這時候的答案顯然就是到尾巴的長度
AC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 // __________________ // | ________________ | // || ____ || // || /\ | || // || /__\ | || // || / \ |____ || // ||________________|| // |__________________| // \###################\ // \###################\ // \ ____ \ // \_______\___\_______\ // An AC a day keeps the doctor away.</description></item><item><title>TIOJ-1774</title><link>https://omeletwithoutegg.github.io/2019/12/05/TIOJ-1774/</link><pubDate>Thu, 05 Dec 2019 21:30:24 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2019/12/05/TIOJ-1774/</guid><description>Ch3. Section 9. 妁艷的頭髮 https://tioj.ck.tp.edu.tw/problems/1774
Solution 裸背包，被值域嚇到XD
不過實際上魔力M只會到2000所以沒差的啦
AC code 1 2 3 4 5 6 7 8 9 10 11 12 #include &amp;lt;iostream&amp;gt;using namespace std; long long n,M,dp[2001]; signed main() { ios_base::sync_with_stdio(0), cin.tie(0); cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; M; for(int i = 0,h,c; i &amp;lt; n; i++) { cin &amp;gt;&amp;gt; h &amp;gt;&amp;gt; c; for(int j = c; j &amp;lt;= M; j++) dp[j] = max(dp[j-c]+h, dp[j]); } cout &amp;lt;&amp;lt; dp[M] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;; }</description></item><item><title>TIOJ-2019</title><link>https://omeletwithoutegg.github.io/2019/12/05/TIOJ-2019/</link><pubDate>Thu, 05 Dec 2019 00:48:51 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2019/12/05/TIOJ-2019/</guid><description>D.番茄大戰爭 https://tioj.ck.tp.edu.tw/problems/2019
Description 兩個人在玩剪刀石頭布，而他們兩個人玩了$T$個回合。兩個人（此處稱為小奕和小安）各自有一個「策略」，分別為兩個字串$A$和$B$。兩個字串皆由R、P、S三個字元組成，分別代表小奕和小安會出石頭、布、剪刀。兩個人都會根據他們的「策略」出題，在第$i$個回合，小奕將會出$A _ {i \mod {|A|}}$，而小安將出$B _ {i \mod{|B|}}$，從$i = 0$開始。請輸出：經過$T$個回合後，兩人分別贏了幾局，平手了幾局。
保證滿足：$1 \leq T \leq 10^9$，$1 \leq |A|, |B| \leq 10^6$，且$A, B$由R、P、S三個字元組成。
Solution 首先，看到$1 \leq T \leq 10^9$當然想說直接給他寫個$\mathcal{O}(T)$，寫了五分鐘之後傳上去——AC——了前幾筆，之後就TLE了。所以，當然就來想怪做法嘍！
先假設$|A| \leq |B|$。第一個想法就是，對於$A$裏頭的每一個字元$A_i$，我都看一次我會遇到哪些字元（$B_i, B _ {i + |A|}, B _ {i + 2\times|A|}, \dots$，也就是所有滿足$(i + k|A|) \mod{|B|} \leq T$的$B _ {(i + k|A|)\mod{|B|}}$，然後再$\mathcal{O}(1)$更新答案。這樣複雜度依然為$\mathcal{O}(T)$，因為還是每一個時間點都有戳到一次，只是改變順序而已了。不過！這個順序很重要，因為可以優化！
若我們看$A_i$，我們先考慮它會遇到那些$B$的字元$$B_i, B _ {i + |A|}, B _ {i + 2\times|A|}, \dots $$，也就是所有的$B _ {i + k|A| \mod{|B|}}$。可以知道，這樣分可以將$B$的所有字元分成若干個相斥的群組$G_t$！具體做法就是，先看$A_i$，如果$B_i$尚未在一個群組裡面，就創立一個新的群組然後將所有的$B _ {i + k|A|}$加進去這個群組裡面。現在，就想要用這個新的資料儲存方式來加快我們的運算。</description></item><item><title>TIOJ-1171</title><link>https://omeletwithoutegg.github.io/2019/12/04/TIOJ-1171/</link><pubDate>Wed, 04 Dec 2019 23:41:02 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2019/12/04/TIOJ-1171/</guid><description>我要成為海賊王 https://tioj.ck.tp.edu.tw/problems/1171
Description 給定一棵樹，一開始所有頂點都是白色的，有$q$次操作，每次操作可以把一個頂點塗成黑色，或者詢問某個頂點$x$到所有黑色頂點的距離和
Solution 可能算是經典題吧，這邊提供兩種寫法: 重心剖分和輕重鍊剖分
重心剖分 重心剖分的核心想法是樹分治，每次拔掉一個點，並統計有經過這個點的答案並遞迴計算沒經過該點的答案
為了確保複雜度，每次拔掉重心是一個好選擇
也許可以發現每個頂點都會當一次重心(?)
並且若把每次拔掉的重心$c$和分治下去的每個子樹找到的重心$c'$都連邊，也會是一棵樹，稱為重心樹
假設我要查詢$x$這個點，我們就枚舉$x$在重心樹上的祖先
對於所有黑色頂點$b$來說都可以找到恰一個祖先$c$使得$b,x$最後是被$c$分開的
可以想到紀錄$cnt_c, sum_c$分別代表分治到以$c$為重心的時候的子樹中，黑色節點的數量以及與$c$的距離和
加加減減就能得到答案了
算式好難推QQ去查了YP的題解才知道怎麼寫
記得在重心樹往上爬的時候必須減掉和下一層有關的一些東西，要避免有重複的邊的路徑被計算到
式子可能長得像這樣吧
$$
\sum _ {p\not=croot} sum_q + cnt_q \cdot path(q,x) - sum_p - cnt_p \cdot path(p,q)
$$
其中$q$是$p$在重心樹上的父節點
每次詢問的複雜度是重心樹的深度也就是$\mathcal{O}(\log n)$
輕重鍊剖分 用$b$和$B$代表黑色頂點和他們的集合，$dis_v$代表從根走到$v$的距離
把所求寫成
$$
\sum _ {b\in B} dis_x + \sum _ {b\in B} dis_b - 2\sum _ {b\in B} dis _ {LCA(b,x)} = |B|dis_x + \sum _ {b\in B}dis_b - 2 \sum _ {b\in B} dis _ {LCA(b,x)}</description></item><item><title>TIOJ-1197</title><link>https://omeletwithoutegg.github.io/2019/12/04/TIOJ-1197/</link><pubDate>Wed, 04 Dec 2019 14:18:31 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2019/12/04/TIOJ-1197/</guid><description>排教室問題 https://tioj.ck.tp.edu.tw/problems/1197
Description 某校有M種不同的課程，其中有些課程的時間會有衝堂。如果學校中總共有N間不同的教室，請問共有多少種安排各課程上課教室的方式？最少要用到幾間教室？
$M,N \leq 10$
註: 衝堂的意思是他們不能被安排在同一個教室
Solution 題目可以想成給定一張圖，每個頂點有$k$種顏色可以塗，定義合法塗色是讓相鄰頂點無同色的塗色方式，問有幾種合法塗色的方式以及至少要用多少顏色才能合法塗色
一開始覺得這是暴搜題，但忽然想到可能不連通也可能會有環之後就不太知道怎麼實作
另外題敘好像沒有講到，不過這題讀邊的時候要用EOF讀
這題我的寫法是位元DP，考慮狀態$dp[S][c]$代表$c$之前的顏色都用過了，並且$S$這個subset已經被塗過了
那轉移可以想成把$S$的一個subset$X$都塗上$c$這個顏色，當然$X$中任意兩個頂點都不相鄰(也就是說$X$是獨立集)，式子長得像
$$
dp[S][c] = \sum\limits _ {X \subseteq S, Valid(X)} dp[S \setminus X][c-1]
$$
其中$Valid(X)$代表$X$是否為獨立集，可以先預處理
預處理獨立集可以做到$\mathcal{O}(n \cdot 2^n)$，而後面枚舉$k$次子集則是$\mathcal{O}(k \cdot 3^n)$
註: 一次枚舉複雜度是$\mathcal{O}(3^n)$的原因可以參考 https://cp-algorithms.com/algebra/all-submasks.html
AC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std; const int N = 10; typedef long long ll; int k,n,a,b,valid[1&amp;lt;&amp;lt;N],g[N][N]; ll dp[1&amp;lt;&amp;lt;N][N]; signed main() { scanf(&amp;#34;%d%d&amp;#34;,&amp;amp;n,&amp;amp;k); while(~scanf(&amp;#34;%d%d&amp;#34;,&amp;amp;a,&amp;amp;b)) --a, --b, g[a][b] = g[b][a] = true; for(int s = 0; s &amp;lt; (1&amp;lt;&amp;lt;n); s++) valid[s] = true; for(int s = 0; s &amp;lt; (1&amp;lt;&amp;lt;n); s++) { for(int i = n-1; i &amp;gt;= 0; i--) if(s &amp;amp; (1&amp;lt;&amp;lt;i)) { if(!</description></item><item><title>TIOJ-2021</title><link>https://omeletwithoutegg.github.io/2019/12/04/TIOJ-2021/</link><pubDate>Wed, 04 Dec 2019 11:34:34 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2019/12/04/TIOJ-2021/</guid><description>F.無限兔子問題 https://tioj.ck.tp.edu.tw/problems/2021
Description 令$F_i$是費式數列
給定$s,t$，求$\sum\limits _ {i=s}^t\binom{F_i}{2}$
Solution 這題也是有夠數學OwO
題目所求是$\sum\limits _ {i=s}^t\frac{1}{2}{F_i(F_i - 1)}$
可以想到分別求$\sum\limits _ {i=1}^nF_i$和$\sum\limits _ {i=1}^nF_i^2$
前者可以用
$$
\left[
\begin{matrix}
0 &amp;amp; 1 &amp;amp; 0 \newline
1 &amp;amp; 1 &amp;amp; 0 \newline
1 &amp;amp; 1 &amp;amp; 1
\end{matrix}
\right]
\left[
\begin{matrix}
F _ {i-2} \newline
F _ {i-1} \newline
S _ {i-1}
\end{matrix}
\right] =
\left[
\begin{matrix}
F _ {i-1} \newline
F_i \newline
S_i
\end{matrix}
\right]
$$</description></item><item><title>TIOJ-1282</title><link>https://omeletwithoutegg.github.io/2019/12/04/TIOJ-1282/</link><pubDate>Wed, 04 Dec 2019 09:31:16 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2019/12/04/TIOJ-1282/</guid><description>愛蜜利雅的作業2 https://tioj.ck.tp.edu.tw/problems/1282
Description 給定一個長度$n$的正整數序列，有$q$次操作，每次操作可能會對區間$[l,r]$加上$k$或詢問區間$[l,r]$的最大公因數
$1 \leq n,q \leq 10^5$
Solution 想法是利用區間加值等於對差分的兩個單點修改
然後有一個性質是 $\gcd(a,b) = \gcd(a-b,b)$
所以$[l,r]$區間的GCD會等於$\gcd(\gcd(a _ {l+1}-a_l, a _ {l+2}-a _ {l+1}, \dots, a_r-a _ {r-1}), a_r)$之類的
求$a_r$可以用BIT就好，前面那項我則是用線段樹維護
複雜度$\mathcal{O}(n\log c + q\log n \log c)$
注意算完GCD要加絕對值，因為差分會出現負數，此時__gcd可能回傳負數
AC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 // __________________ // | ________________ | // || ____ || // || /\ | || // || /__\ | || // || / \ |____ || // ||________________|| // |__________________| // \###################\ // \###################\ // \ ____ \ // \_______\___\_______\ // An AC a day keeps the doctor away.</description></item><item><title>Hello World</title><link>https://omeletwithoutegg.github.io/2019/12/01/hello-world/</link><pubDate>Sun, 01 Dec 2019 23:25:02 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2019/12/01/hello-world/</guid><description>這是一篇測試用的文章
A quick brown fox jumps over the lazy dog.
引用文字
標題 二級標題 1 2 3 4 5 #include &amp;lt;iostream&amp;gt; int main() { std::cout &amp;lt;&amp;lt; &amp;#34;Hello hexo&amp;#34; &amp;lt;&amp;lt; std::endl; } 1 2 3 $ hexo clean $ hexo s -g $ echo 7122</description></item></channel></rss>